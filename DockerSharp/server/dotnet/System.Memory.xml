<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Memory</name>
    </assembly>
    <members>
        <member name="T:System.SequencePosition">
            <summary>
            Represents position in non-contiguous set of memory.
            Properties of this type should not be interpreted by anything but the type that created it.
            </summary>
        </member>
        <member name="M:System.SequencePosition.#ctor(System.Object,System.Int32)">
            <summary>
            Creates new <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetObject">
            <summary>
            Returns object part of this <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetInteger">
            <summary>
            Returns integer part of this <see cref="T:System.SequencePosition"/>
            </summary>
        </member>
        <member name="M:System.SequencePosition.Equals(System.SequencePosition)">
            <summary>
            Indicates whether the current <see cref="T:System.SequencePosition"/> is equal to another <see cref="T:System.SequencePosition"/>.
            <see cref="T:System.SequencePosition"/> equality does not guarantee that they point to the same location in <see cref="T:System.Buffers.ReadOnlySequence`1" />
            </summary>
        </member>
        <member name="M:System.SequencePosition.Equals(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:System.SequencePosition"/> is equal to another <see cref="T:System.Object"/>.
            <see cref="T:System.SequencePosition"/> equality does not guarantee that they point to the same location in <see cref="T:System.Buffers.ReadOnlySequence`1" />
            </summary>
        </member>
        <member name="M:System.SequencePosition.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:System.Buffers.BuffersExtensions">
            <summary>
            Extension methods for <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.PositionOf``1(System.Buffers.ReadOnlySequence{``0}@,``0)">
            <summary>
            Returns position of first occurrence of item in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.CopyTo``1(System.Buffers.ReadOnlySequence{``0}@,System.Span{``0})">
            <summary>
            Copy the <see cref="T:System.Buffers.ReadOnlySequence`1"/> to the specified <see cref="T:System.Span`1"/>.
            </summary>
            <param name="source">The source <see cref="T:System.Buffers.ReadOnlySequence`1"/>.</param>
            <param name="destination">The destination <see cref="T:System.Span`1"/>.</param>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.ToArray``1(System.Buffers.ReadOnlySequence{``0}@)">
            <summary>
            Converts the <see cref="T:System.Buffers.ReadOnlySequence`1"/> to an array
            </summary>
        </member>
        <member name="M:System.Buffers.BuffersExtensions.Write``1(System.Buffers.IBufferWriter{``0},System.ReadOnlySpan{``0})">
            <summary>
            Writes contents of <paramref name="value"/> to <paramref name="writer"/>
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the <paramref name="writer"/> is shorter than the <paramref name="value"/>.
            </exception>
        </member>
        <member name="T:System.Buffers.IBufferWriter`1">
            <summary>
            Represents an output sink into which <typeparam name="T"/> data can be written.
            </summary>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)">
            <summary>
            Notifies <see cref="T:System.Buffers.IBufferWriter`1"/> that <paramref name="count"/> amount of data was written to the output <see cref="T:System.Span`1"/>/<see cref="T:System.Memory`1"/>
            </summary>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <remarks>
            This must never return an empty <see cref="T:System.Memory`1"/> but it can throw
            if the requested buffer size is not available.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Span`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <remarks>
            This must never return an empty <see cref="T:System.Span`1"/> but it can throw
            if the requested buffer size is not available.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="T:System.Buffers.MemoryPool`1">
            <summary>
            Represents a pool of memory blocks.
            </summary>
        </member>
        <member name="P:System.Buffers.MemoryPool`1.Shared">
            <summary>
            Returns a singleton instance of a MemoryPool based on arrays.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryPool`1.Rent(System.Int32)">
            <summary>
            Returns a memory block capable of holding at least <paramref name="minBufferSize" /> elements of T.
            </summary>
            <param name="minBufferSize">If -1 is passed, this is set to a default value for the pool.</param>
        </member>
        <member name="P:System.Buffers.MemoryPool`1.MaxBufferSize">
            <summary>
            Returns the maximum buffer size supported by this pool.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryPool`1.#ctor">
            <summary>
            Constructs a new instance of a memory pool.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryPool`1.Dispose">
            <summary>
            Frees all resources used by the memory pool.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryPool`1.Dispose(System.Boolean)">
            <summary>
            Frees all resources used by the memory pool.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:System.Buffers.ReadOnlySequence`1">
            <summary>
            Represents a sequence that can read a sequential series of <typeparam name="T" />.
            </summary>
        </member>
        <member name="F:System.Buffers.ReadOnlySequence`1.Empty">
            <summary>
            Returns empty <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Length">
            <summary>
            Length of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.IsEmpty">
            <summary>
            Determines if the <see cref="T:System.Buffers.ReadOnlySequence`1"/> is empty.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.IsSingleSegment">
            <summary>
            Determines if the <see cref="T:System.Buffers.ReadOnlySequence`1"/> contains a single <see cref="T:System.ReadOnlyMemory`1"/> segment.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.First">
            <summary>
            Gets <see cref="T:System.ReadOnlyMemory`1"/> from the first segment.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.FirstSpan">
            <summary>
            Gets <see cref="T:System.ReadOnlySpan`1"/> from the first segment.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Start">
            <summary>
            A position to the start of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.End">
            <summary>
            A position to the end of the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.Buffers.ReadOnlySequenceSegment{`0},System.Int32,System.Buffers.ReadOnlySequenceSegment{`0},System.Int32)">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from linked memory list represented by start and end segments
            and corresponding indexes in them.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[])">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="T:T[]"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="T:T[]"/>, start and index.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Creates an instance of <see cref="T:System.Buffers.ReadOnlySequence`1"/> from the <see cref="T:System.ReadOnlyMemory`1"/>.
            Consumer is expected to manage lifetime of memory until <see cref="T:System.Buffers.ReadOnlySequence`1"/> is not used anymore.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.Int64)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The length of the slice.</param>
            <returns>A slice that consists of <paramref name="length" /> elements from the current instance starting at index <paramref name="start" />.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64,System.SequencePosition)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/> and ending at <paramref name="end"/> (exclusive).
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="end">The ending (exclusive) <see cref="T:System.SequencePosition"/> of the slice.</param>
            <returns>A slice that consists of items from the <paramref name="start" /> index to, but not including, the <paramref name="end" /> sequence position in the current read-only sequence.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int64)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items.
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="length">The length of the slice.</param>
            <returns>A slice that consists of <paramref name="length" /> elements from the current instance starting at sequence position <paramref name="start" />.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The length of the slice.</param>
            <returns>A slice that consists of <paramref name="length" /> elements from the current instance starting at index <paramref name="start" />.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int32,System.SequencePosition)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/> and ending at <paramref name="end"/> (exclusive).
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="end">The ending (exclusive) <see cref="T:System.SequencePosition"/> of the slice.</param>
            <returns>A slice that consists of items from the <paramref name="start" /> index to, but not including, the <paramref name="end" /> sequence position in the current read-only sequence.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.Int32)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, with <paramref name="length"/> items.
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="length">The length of the slice.</param>
            <returns>A slice that consists of <paramref name="length" /> elements from the current instance starting at sequence position <paramref name="start" />.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition,System.SequencePosition)">
            <summary>
            Forms a slice out of the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>, beginning at <paramref name="start"/>, ending at <paramref name="end"/> (exclusive).
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <param name="end">The ending (exclusive) <see cref="T:System.SequencePosition"/> of the slice.</param>
            <returns>A slice that consists of items from the <paramref name="start" /> sequence position to, but not including, the <paramref name="end" /> sequence position in the current read-only sequence.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.SequencePosition)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1" />, beginning at a specified sequence position and continuing to the end of the read-only sequence.
            </summary>
            <param name="start">The starting (inclusive) <see cref="T:System.SequencePosition"/> at which to begin this slice.</param>
            <returns>A slice starting at sequence position <paramref name="start" /> and continuing to the end of the current read-only sequence.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Slice(System.Int64)">
            <summary>
            Forms a slice out of the current <see cref="T:System.Buffers.ReadOnlySequence`1" /> , beginning at a specified index and continuing to the end of the read-only sequence.
            </summary>
            <param name="start">The start index at which to begin this slice.</param>
            <returns>A slice starting at index <paramref name="start" /> and continuing to the end of the current read-only sequence.</returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetEnumerator">
            <summary>
            Returns an enumerator over the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64)">
            <summary>
            Returns a new <see cref="T:System.SequencePosition"/> at an <paramref name="offset"/> from the start of the sequence.
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetPosition(System.Int64,System.SequencePosition)">
            <summary>
            Returns a new <see cref="T:System.SequencePosition"/> at an <paramref name="offset"/> from the <paramref name="origin"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.TryGet(System.SequencePosition@,System.ReadOnlyMemory{`0}@,System.Boolean)">
            <summary>
            Tries to retrieve next segment after <paramref name="position"/> and return its contents in <paramref name="memory"/>.
            Returns <code>false</code> if end of <see cref="T:System.Buffers.ReadOnlySequence`1"/> was reached otherwise <code>true</code>.
            Sets <paramref name="position"/> to the beginning of next segment if <paramref name="advance"/> is set to <code>true</code>.
            </summary>
        </member>
        <member name="T:System.Buffers.ReadOnlySequence`1.Enumerator">
            <summary>
            An enumerator over the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
            <summary>Initialize the enumerator.</summary>
            <param name="sequence">The <see cref="T:System.Buffers.ReadOnlySequence`1"/> to enumerate.</param>
        </member>
        <member name="P:System.Buffers.ReadOnlySequence`1.Enumerator.Current">
            <summary>
            The current <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.Enumerator.MoveNext">
            <summary>
            Moves to the next <see cref="T:System.ReadOnlyMemory`1"/> in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Buffers.ReadOnlySequence`1.GetFirstSpan(System.ReadOnlySpan{`0}@,System.SequencePosition@)">
            <summary>
            Helper to efficiently prepare the <see cref="T:System.Buffers.SequenceReader`1"/>
            </summary>
            <param name="first">The first span in the sequence.</param>
            <param name="next">The next position.</param>
        </member>
        <member name="T:System.Buffers.ReadOnlySequenceSegment`1">
            <summary>
            Represents a linked list of <see cref="T:System.ReadOnlyMemory`1"/> nodes.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Memory">
            <summary>
            The <see cref="T:System.ReadOnlyMemory`1"/> value for current node.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.Next">
            <summary>
            The next node.
            </summary>
        </member>
        <member name="P:System.Buffers.ReadOnlySequenceSegment`1.RunningIndex">
            <summary>
            The sum of node length before current.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0})">
            <summary>
            Create a <see cref="T:System.Buffers.SequenceReader`1"/> over the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.End">
            <summary>
            True when there is no more data in the <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Sequence">
            <summary>
            The underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/> for the reader.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Position">
            <summary>
            The current position in the <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.CurrentSpan">
            <summary>
            The current segment in the <see cref="P:System.Buffers.SequenceReader`1.Sequence"/> as a span.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.CurrentSpanIndex">
            <summary>
            The index in the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.UnreadSpan">
            <summary>
            The unread portion of the <see cref="P:System.Buffers.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Consumed">
            <summary>
            The total number of <typeparamref name="T"/>'s processed by the reader.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Remaining">
            <summary>
            Remaining <typeparamref name="T"/>'s in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.SequenceReader`1.Length">
            <summary>
            Count of <typeparamref name="T"/> in the reader's <see cref="P:System.Buffers.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryPeek(`0@)">
            <summary>
            Peeks at the next value without advancing the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryRead(`0@)">
            <summary>
            Read the next value and advance the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.Rewind(System.Int64)">
            <summary>
            Move the reader back the specified number of items.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if trying to rewind a negative amount or more than <see cref="P:System.Buffers.SequenceReader`1.Consumed"/>.
            </exception>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.GetNextSpan">
            <summary>
            Get the next segment with available data, if any.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.Advance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvanceCurrentSpan(System.Int64)">
            <summary>
            Unchecked helper to avoid unnecessary checks where you know count is valid.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvanceWithinSpan(System.Int64)">
            <summary>
            Only call this helper if you know that you are advancing in the current span
            with valid count and there is no need to fetch the next one.
            </summary>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies data from the current <see cref="P:System.Buffers.SequenceReader`1.Position"/> to the given <paramref name="destination"/> span if there
            is enough data to fill it.
            </summary>
            <remarks>
            This API is used to copy a fixed amount of data out of the sequence if possible. It does not advance
            the reader. To look ahead for a specific stream of data <see cref="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)"/> can be used.
            </remarks>
            <param name="destination">Destination span to copy to.</param>
            <returns>True if there is enough data to completely fill the <paramref name="destination"/> span.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,System.Boolean)">
            <summary>
            Try to read everything up to the given <paramref name="delimiter"/>.
            </summary>
            <param name="span">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.ReadOnlySpan{`0}@,`0,`0,System.Boolean)">
            <summary>
            Try to read everything up to the given <paramref name="delimiter"/>, ignoring delimiters that are
            preceded by <paramref name="delimiterEscape"/>.
            </summary>
            <param name="span">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="delimiterEscape">If found prior to <paramref name="delimiter"/> it will skip that occurrence.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,System.Boolean)">
            <summary>
            Try to read everything up to the given <paramref name="delimiter"/>.
            </summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,`0,`0,System.Boolean)">
            <summary>
            Try to read everything up to the given <paramref name="delimiter"/>, ignoring delimiters that are
            preceded by <paramref name="delimiterEscape"/>.
            </summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiter">The delimiter to look for.</param>
            <param name="delimiterEscape">If found prior to <paramref name="delimiter"/> it will skip that occurrence.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.ReadOnlySpan{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
            <summary>
            Try to read everything up to the given <paramref name="delimiters"/>.
            </summary>
            <param name="span">The read data, if any.</param>
            <param name="delimiters">The delimiters to look for.</param>
            <param name="advancePastDelimiter">True to move past the first found instance of any of the given <paramref name="delimiters"/>.</param>
            <returns>True if any of the <paramref name="delimiters"/> were found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryReadToAny(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
            <summary>
            Try to read everything up to the given <paramref name="delimiters"/>.
            </summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiters">The delimiters to look for.</param>
            <param name="advancePastDelimiter">True to move past the first found instance of any of the given <paramref name="delimiters"/>.</param>
            <returns>True if any of the <paramref name="delimiters"/> were found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryReadTo(System.Buffers.ReadOnlySequence{`0}@,System.ReadOnlySpan{`0},System.Boolean)">
            <summary>
            Try to read data until the entire given <paramref name="delimiter"/> matches.
            </summary>
            <param name="sequence">The read data, if any.</param>
            <param name="delimiter">The multi (T) delimiter.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryAdvanceTo(`0,System.Boolean)">
            <summary>
            Advance until the given <paramref name="delimiter"/>, if found.
            </summary>
            <param name="delimiter">The delimiter to search for.</param>
            <param name="advancePastDelimiter">True to move past the <paramref name="delimiter"/> if found.</param>
            <returns>True if the given <paramref name="delimiter"/> was found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.TryAdvanceToAny(System.ReadOnlySpan{`0},System.Boolean)">
            <summary>
            Advance until any of the given <paramref name="delimiters"/>, if found.
            </summary>
            <param name="delimiters">The delimiters to search for.</param>
            <param name="advancePastDelimiter">True to move past the first found instance of any of the given <paramref name="delimiters"/>.</param>
            <returns>True if any of the given <paramref name="delimiters"/> were found.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvancePast(`0)">
            <summary>
            Advance past consecutive instances of the given <paramref name="value"/>.
            </summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(System.ReadOnlySpan{`0})">
            <summary>
            Skip consecutive instances of any of the given <paramref name="values"/>.
            </summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0,`0)">
            <summary>
            Advance past consecutive instances of any of the given values.
            </summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0,`0)">
            <summary>
            Advance past consecutive instances of any of the given values.
            </summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.AdvancePastAny(`0,`0)">
            <summary>
            Advance past consecutive instances of any of the given values.
            </summary>
            <returns>How many positions the reader has been advanced.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.IsNext(`0,System.Boolean)">
            <summary>
            Check to see if the given <paramref name="next"/> value is next.
            </summary>
            <param name="next">The value to compare the next items to.</param>
            <param name="advancePast">Move past the <paramref name="next"/> value if found.</param>
        </member>
        <member name="M:System.Buffers.SequenceReader`1.IsNext(System.ReadOnlySpan{`0},System.Boolean)">
            <summary>
            Check to see if the given <paramref name="next"/> values are next.
            </summary>
            <param name="next">The span to compare the next items to.</param>
            <param name="advancePast">Move past the <paramref name="next"/> values if found.</param>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
            <summary>
            Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
            structs- see remarks for full details.
            </summary>
            <remarks>
            IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of it's members to
            behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
            overloads such as <see cref="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int16@)"/>
            </remarks>
            <returns>
            True if successful. <paramref name="value"/> will be default if failed (due to lack of space).
            </returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int16@)">
            <summary>
            Reads an <see cref="T:System.Int16"/> as little endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int16@)">
            <summary>
            Reads an <see cref="T:System.Int16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int32@)">
            <summary>
            Reads an <see cref="T:System.Int32"/> as little endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int32@)">
            <summary>
            Reads an <see cref="T:System.Int32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int64@)">
            <summary>
            Reads an <see cref="T:System.Int64"/> as little endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:System.Buffers.SequenceReaderExtensions.TryReadBigEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int64@)">
            <summary>
            Reads an <see cref="T:System.Int64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="T:System.Buffers.Text.Base64">
            <summary>
            Convert between binary data and UTF-8 encoded text that is represented in base 64.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            Decode the span of UTF-8 encoded text represented as base 64 into binary data.
            If the input is not a multiple of 4, it will decode as much as it can, to the closest multiple of 4.
            </summary>
            <param name="utf8">The input span which contains UTF-8 encoded text in base 64 that needs to be decoded.</param>
            <param name="bytes">The output span which contains the result of the operation, i.e. the decoded binary data.</param>
            <param name="bytesConsumed">The number of input bytes consumed during the operation. This can be used to slice the input for subsequent calls, if necessary.</param>
            <param name="bytesWritten">The number of bytes written into the output span. This can be used to slice the output for subsequent calls, if necessary.</param>
            <param name="isFinalBlock">True (default) when the input span contains the entire data to decode.
            Set to false only if it is known that the input span contains partial data with more data to follow.</param>
            <returns>It returns the OperationStatus enum values:
            - Done - on successful processing of the entire input span
            - DestinationTooSmall - if there is not enough space in the output span to fit the decoded input
            - NeedMoreData - only if isFinalBlock is false and the input is not a multiple of 4, otherwise the partial input would be considered as InvalidData
            - InvalidData - if the input contains bytes outside of the expected base 64 range, or if it contains invalid/more than two padding characters,
              or if the input is incomplete (i.e. not a multiple of 4) and isFinalBlock is true.
            </returns>
        </member>
        <member name="M:System.Buffers.Text.Base64.GetMaxDecodedFromUtf8Length(System.Int32)">
            <summary>
            Returns the maximum length (in bytes) of the result if you were to deocde base 64 encoded text within a byte span of size "length".
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is less than 0.
            </exception>
        </member>
        <member name="M:System.Buffers.Text.Base64.DecodeFromUtf8InPlace(System.Span{System.Byte},System.Int32@)">
            <summary>
            Decode the span of UTF-8 encoded text in base 64 (in-place) into binary data.
            The decoded binary output is smaller than the text data contained in the input (the operation deflates the data).
            If the input is not a multiple of 4, it will not decode any.
            </summary>
            <param name="buffer">The input span which contains the base 64 text data that needs to be decoded.</param>
            <param name="bytesWritten">The number of bytes written into the buffer.</param>
            <returns>It returns the OperationStatus enum values:
            - Done - on successful processing of the entire input span
            - InvalidData - if the input contains bytes outside of the expected base 64 range, or if it contains invalid/more than two padding characters,
              or if the input is incomplete (i.e. not a multiple of 4).
            It does not return DestinationTooSmall since that is not possible for base 64 decoding.
            It does not return NeedMoreData since this method tramples the data in the buffer and
            hence can only be called once with all the data in the buffer.
            </returns>
        </member>
        <member name="M:System.Buffers.Text.Base64.EncodeToUtf8(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean)">
            <summary>
            Encode the span of binary data into UTF-8 encoded text represented as base 64.
            </summary> 
            <param name="bytes">The input span which contains binary data that needs to be encoded.</param>
            <param name="utf8">The output span which contains the result of the operation, i.e. the UTF-8 encoded text in base 64.</param>
            <param name="bytesConsumed">The number of input bytes consumed during the operation. This can be used to slice the input for subsequent calls, if necessary.</param>
            <param name="bytesWritten">The number of bytes written into the output span. This can be used to slice the output for subsequent calls, if necessary.</param>
            <param name="isFinalBlock">True (default) when the input span contains the entire data to encode.
            Set to false only if it is known that the input span contains partial data with more data to follow.</param>
            <returns>It returns the OperationStatus enum values:
            - Done - on successful processing of the entire input span
            - DestinationTooSmall - if there is not enough space in the output span to fit the encoded input
            - NeedMoreData - only if isFinalBlock is false, otherwise the output is padded if the input is not a multiple of 3
            It does not return InvalidData since that is not possible for base 64 encoding.
            </returns>
        </member>
        <member name="M:System.Buffers.Text.Base64.GetMaxEncodedToUtf8Length(System.Int32)">
            <summary>
            Returns the maximum length (in bytes) of the result if you were to encode binary data within a byte span of size "length".
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is less than 0 or larger than 1610612733 (since encode inflates the data by 4/3).
            </exception>
        </member>
        <member name="M:System.Buffers.Text.Base64.EncodeToUtf8InPlace(System.Span{System.Byte},System.Int32,System.Int32@)">
            <summary>
            Encode the span of binary data (in-place) into UTF-8 encoded text represented as base 64.
            The encoded text output is larger than the binary data contained in the input (the operation inflates the data).
            </summary>
            <param name="buffer">The input span which contains binary data that needs to be encoded.
            It needs to be large enough to fit the result of the operation.</param>
            <param name="dataLength">The amount of binary data contained within the buffer that needs to be encoded
            (and needs to be smaller than the buffer length).</param>
            <param name="bytesWritten">The number of bytes written into the buffer.</param>
            <returns>It returns the OperationStatus enum values:
            - Done - on successful processing of the entire buffer
            - DestinationTooSmall - if there is not enough space in the buffer beyond dataLength to fit the result of encoding the input
            It does not return NeedMoreData since this method tramples the data in the buffer and hence can only be called once with all the data in the buffer.
            It does not return InvalidData since that is not possible for base 64 encoding.
            </returns>
        </member>
        <member name="T:System.Buffers.ArrayBufferWriter`1">
            <summary>
            Represents a heap-based, array-backed output sink into which <typeparam name="T"/> data can be written.
            </summary>
        </member>
        <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor">
            <summary>
            Creates an instance of an <see cref="T:System.Buffers.ArrayBufferWriter`1"/>, in which data can be written to,
            with the default initial capacity.
            </summary>
        </member>
        <member name="M:System.Buffers.ArrayBufferWriter`1.#ctor(System.Int32)">
            <summary>
            Creates an instance of an <see cref="T:System.Buffers.ArrayBufferWriter`1"/>, in which data can be written to,
            with an initial capacity specified.
            </summary>
            <param name="initialCapacity">The minimum capacity with which to initialize the underlying buffer.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="initialCapacity"/> is not positive (i.e. less than or equal to 0).
            </exception>
        </member>
        <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenMemory">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenSpan">
            <summary>
            Returns the data written to the underlying buffer so far, as a <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="P:System.Buffers.ArrayBufferWriter`1.WrittenCount">
            <summary>
            Returns the amount of data written to the underlying buffer so far.
            </summary>
        </member>
        <member name="P:System.Buffers.ArrayBufferWriter`1.Capacity">
            <summary>
            Returns the total amount of space within the underlying buffer.
            </summary>
        </member>
        <member name="P:System.Buffers.ArrayBufferWriter`1.FreeCapacity">
            <summary>
            Returns the amount of space available that can still be written into without forcing the underlying buffer to grow.
            </summary>
        </member>
        <member name="M:System.Buffers.ArrayBufferWriter`1.Clear">
            <summary>
            Clears the data written to the underlying buffer.
            </summary>
            <remarks>
            You must clear the <see cref="T:System.Buffers.ArrayBufferWriter`1"/> before trying to re-use it.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayBufferWriter`1.Advance(System.Int32)">
            <summary>
            Notifies <see cref="T:System.Buffers.IBufferWriter`1"/> that <paramref name="count"/> amount of data was written to the output <see cref="T:System.Span`1"/>/<see cref="T:System.Memory`1"/>
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="count"/> is negative.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when attempting to advance past the end of the underlying buffer.
            </exception>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayBufferWriter`1.GetMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Memory`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayBufferWriter`1.GetSpan(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Span`1"/> to write to that is at least the requested length (specified by <paramref name="sizeHint"/>).
            If no <paramref name="sizeHint"/> is provided (or it's equal to <code>0</code>), some non-empty buffer is returned.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="sizeHint"/> is negative.
            </exception>
            <remarks>
            This will never return an empty <see cref="T:System.Span`1"/>.
            </remarks>
            <remarks>
            There is no guarantee that successive calls will return the same buffer or the same-sized buffer.
            </remarks>
            <remarks>
            You must request a new buffer after calling Advance to continue writing more data and cannot write to a previously acquired buffer.
            </remarks>
        </member>
        <member name="T:System.Runtime.InteropServices.SequenceMarshal">
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Buffers.ReadOnlySequence`1"/>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlySequenceSegment``1(System.Buffers.ReadOnlySequence{``0},System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@,System.Buffers.ReadOnlySequenceSegment{``0}@,System.Int32@)">
            <summary>
            Get <see cref="T:System.Buffers.ReadOnlySequenceSegment`1"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.Buffers.ReadOnlySequenceSegment`1"/>, return false.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetArray``1(System.Buffers.ReadOnlySequence{``0},System.ArraySegment{``0}@)">
            <summary>
            Get an array segment from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the array segment, return false with a default array segment.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetReadOnlyMemory``1(System.Buffers.ReadOnlySequence{``0},System.ReadOnlyMemory{``0}@)">
            <summary>
            Get <see cref="T:System.ReadOnlyMemory`1"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.ReadOnlyMemory`1"/>, return false.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryGetString(System.Buffers.ReadOnlySequence{System.Char},System.String@,System.Int32@,System.Int32@)">
            <summary>
            Get <see cref="T:System.String"/> from the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            If unable to get the <see cref="T:System.String"/>, return false.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SequenceMarshal.TryRead``1(System.Buffers.SequenceReader{System.Byte}@,``0@)">
            <summary>
            Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
            structs- see remarks for full details.
            </summary>
            <remarks>
            IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of it's members to
            behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
            overloads such as <see cref="M:System.Buffers.SequenceReaderExtensions.TryReadLittleEndian(System.Buffers.SequenceReader{System.Byte}@,System.Int32@)"/>
            </remarks>
            <returns>
            True if successful. <paramref name="value"/> will be default if failed (due to lack of space).
            </returns>
        </member>
        <member name="P:System.SR.NotSupported_CannotCallEqualsOnSpan">
            <summary>Equals() on Span and ReadOnlySpan is not supported. Use operator== instead.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CannotCallGetHashCodeOnSpan">
            <summary>GetHashCode() on Span and ReadOnlySpan is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidTypeWithPointersNotSupported">
            <summary>Cannot use type '{0}'. Only value types without pointers or references are supported.</summary>
        </member>
        <member name="P:System.SR.Argument_DestinationTooShort">
            <summary>Destination is too short.</summary>
        </member>
        <member name="P:System.SR.OutstandingReferences">
            <summary>Release all references before disposing this instance.</summary>
        </member>
        <member name="P:System.SR.Argument_BadFormatSpecifier">
            <summary>Format specifier was invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_OverlapAlignmentMismatch">
            <summary>Overlapping spans have mismatching alignment.</summary>
        </member>
        <member name="P:System.SR.EndPositionNotReached">
            <summary>End position was not reached during enumeration.</summary>
        </member>
        <member name="P:System.SR.UnexpectedSegmentType">
            <summary>Unexpected segment type.</summary>
        </member>
        <member name="P:System.SR.BufferWriterAdvancedTooFar">
            <summary>Cannot advance past the end of the buffer, which has a size of {0}.</summary>
        </member>
    </members>
</doc>
