<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Private.CoreLib</name>
    </assembly>
    <members>
        <member name="T:Internal.Runtime.InteropServices.IsolatedComponentLoadContext">
             <summary>
             An <see cref="T:Internal.Runtime.InteropServices.IsolatedComponentLoadContext" /> is an AssemblyLoadContext that can be used to isolate components such as COM components
             or IJW components loaded from native. It provides a load context that uses an <see cref="T:System.Runtime.Loader.AssemblyDependencyResolver" /> to resolve the component's
             dependencies within the ALC and not pollute the default ALC.
            </summary>
        </member>
        <member name="M:Internal.Runtime.InteropServices.ComponentActivator.LoadAssemblyAndGetFunctionPointer(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Native hosting entry point for creating a native delegate
            </summary>
            <param name="assemblyPathNative">Fully qualified path to assembly</param>
            <param name="typeNameNative">Assembly qualified type name</param>
            <param name="methodNameNative">Public static method name compatible with delegateType</param>
            <param name="delegateTypeNative">Assembly qualified delegate type name</param>
            <param name="reserved">Extensibility parameter (currently unused)</param>
            <param name="functionHandle">Pointer where to store the function pointer result</param>
        </member>
        <member name="T:Internal.Runtime.CompilerServices.Unsafe">
            <summary>
            For internal use only. Contains generic, low-level functionality for manipulating pointers.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.AsPointer``1(``0@)">
            <summary>
            Returns a pointer to the given by-ref parameter.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.SizeOf``1">
            <summary>
            Returns the size of an object of the given type parameter.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.As``1(System.Object)">
            <summary>
            Casts the given object to the specified type, performs no dynamic type checking.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.As``2(``0@)">
            <summary>
            Reinterprets the given reference as a reference to a value of type <typeparamref name="TTo"/>.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.Int32)">
            <summary>
            Adds an element offset to the given reference.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.IntPtr)">
            <summary>
            Adds an element offset to the given reference.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.Add``1(System.Void*,System.Int32)">
            <summary>
            Adds an element offset to the given pointer.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.UInt32)">
            <summary>
            Adds an element offset to the given reference.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.AreSame``1(``0@,``0@)">
            <summary>
            Determines whether the specified references point to the same location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.IsAddressGreaterThan``1(``0@,``0@)">
            <summary>
            Determines whether the memory address referenced by <paramref name="left"/> is greater than
            the memory address referenced by <paramref name="right"/>.
            </summary>
            <remarks>
            This check is conceptually similar to "(void*)(&amp;left) &gt; (void*)(&amp;right)".
            </remarks>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.IsAddressLessThan``1(``0@,``0@)">
            <summary>
            Determines whether the memory address referenced by <paramref name="left"/> is less than
            the memory address referenced by <paramref name="right"/>.
            </summary>
            <remarks>
            This check is conceptually similar to "(void*)(&amp;left) &lt; (void*)(&amp;right)".
            </remarks>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.InitBlockUnaligned(System.Byte@,System.Byte,System.UInt32)">
            <summary>
            Initializes a block of memory at the given location with a given initial value 
            without assuming architecture dependent alignment of the address.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Void*)">
            <summary>
            Reads a value of type <typeparamref name="T"/> from the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Byte@)">
            <summary>
            Reads a value of type <typeparamref name="T"/> from the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Void*,``0)">
            <summary>
            Writes a value of type <typeparamref name="T"/> to the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Byte@,``0)">
            <summary>
            Writes a value of type <typeparamref name="T"/> to the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.IntPtr)">
            <summary>
            Adds an element offset to the given reference.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.Read``1(System.Void*)">
            <summary>
            Reads a value of type <typeparamref name="T"/> from the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.Read``1(System.Byte@)">
            <summary>
            Reads a value of type <typeparamref name="T"/> from the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.Write``1(System.Void*,``0)">
            <summary>
            Writes a value of type <typeparamref name="T"/> to the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.Write``1(System.Byte@,``0)">
            <summary>
            Writes a value of type <typeparamref name="T"/> to the given location.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.AsRef``1(System.Void*)">
            <summary>
            Reinterprets the given location as a reference to a value of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.AsRef``1(``0@)">
            <summary>
            Reinterprets the given location as a reference to a value of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Internal.Runtime.CompilerServices.Unsafe.ByteOffset``1(``0@,``0@)">
            <summary>
            Determines the byte offset from origin to target from the given references.
            </summary>
        </member>
        <member name="T:Internal.PaddingHelpers">
            <summary>A class for common padding constants and eventually routines.</summary>
        </member>
        <member name="F:Internal.PaddingHelpers.CACHE_LINE_SIZE">
            <summary>A size greater than or equal to the size of the most common CPU cache lines.</summary>
        </member>
        <member name="T:Internal.PaddingFor32">
            <summary>Padding structure used to minimize false sharing</summary>
        </member>
        <member name="M:Microsoft.Win32.SafeHandles.SafeFileHandle.Open(System.String,Interop.Sys.OpenFlags,System.Int32)">
            <summary>Opens the specified file with the requested flags and mode.</summary>
            <param name="path">The path to the file.</param>
            <param name="flags">The flags with which to open the file.</param>
            <param name="mode">The mode for opening the file.</param>
            <returns>A SafeFileHandle for the opened file.</returns>
        </member>
        <member name="M:Microsoft.Win32.SafeHandles.SafeFileHandle.Open(System.Func{Microsoft.Win32.SafeHandles.SafeFileHandle})">
            <summary>Opens a SafeFileHandle for a file descriptor created by a provided delegate.</summary>
            <param name="fdFunc">
            The function that creates the file descriptor. Returns the file descriptor on success, or an invalid
            file descriptor on error with Marshal.GetLastWin32Error() set to the error code.
            </param>
            <returns>The created SafeFileHandle.</returns>
        </member>
        <member name="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)">
            <summary>
            Try to get the value of the switch.
            </summary>
            <param name="switchName">The name of the switch</param>
            <param name="isEnabled">A variable where to place the value of the switch</param>
            <returns>A return value of true represents that the switch was set and <paramref name="isEnabled"/> contains the value of the switch</returns>
        </member>
        <member name="M:System.AppContext.SetSwitch(System.String,System.Boolean)">
            <summary>
            Assign a switch a value
            </summary>
            <param name="switchName">The name of the switch</param>
            <param name="isEnabled">The value to assign</param>
        </member>
        <member name="T:System.Collections.EmptyReadOnlyDictionaryInternal">
               This is a simple implementation of IDictionary that is empty and readonly.
        </member>
        <member name="T:System.Collections.Generic.ComparerHelpers">
            <summary>
            Helper class for creating the default <see cref="T:System.Collections.Generic.Comparer`1"/> and <see cref="T:System.Collections.Generic.EqualityComparer`1"/>.
            </summary>
            <remarks>
            This class is intentionally type-unsafe and non-generic to minimize the generic instantiation overhead of creating
            the default comparer/equality comparer for a new type parameter. Efficiency of the methods in here does not matter too
            much since they will only be run once per type parameter, but generic code involved in creating the comparers needs to be
            kept to a minimum.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.ComparerHelpers.CreateDefaultComparer(System.Type)">
            <summary>
            Creates the default <see cref="T:System.Collections.Generic.Comparer`1"/>.
            </summary>
            <param name="type">The type to create the default comparer for.</param>
            <remarks>
            The logic in this method is replicated in vm/compile.cpp to ensure that NGen saves the right instantiations,
            and in vm/jitinterface.cpp so the jit can model the behavior of this method.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.ComparerHelpers.TryCreateNullableComparer(System.RuntimeType)">
            <summary>
            Creates the default <see cref="T:System.Collections.Generic.Comparer`1"/> for a nullable type.
            </summary>
            <param name="nullableType">The nullable type to create the default comparer for.</param>
        </member>
        <member name="M:System.Collections.Generic.ComparerHelpers.TryCreateEnumComparer(System.RuntimeType)">
            <summary>
            Creates the default <see cref="T:System.Collections.Generic.Comparer`1"/> for an enum type.
            </summary>
            <param name="enumType">The enum type to create the default comparer for.</param>
        </member>
        <member name="M:System.Collections.Generic.ComparerHelpers.CreateDefaultEqualityComparer(System.Type)">
            <summary>
            Creates the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/>.
            </summary>
            <param name="type">The type to create the default equality comparer for.</param>
            <remarks>
            The logic in this method is replicated in vm/compile.cpp to ensure that NGen saves the right instantiations.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.ComparerHelpers.TryCreateNullableEqualityComparer(System.RuntimeType)">
            <summary>
            Creates the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for a nullable type.
            </summary>
            <param name="nullableType">The nullable type to create the default equality comparer for.</param>
        </member>
        <member name="M:System.Collections.Generic.ComparerHelpers.TryCreateEnumEqualityComparer(System.RuntimeType)">
            <summary>
            Creates the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for an enum type.
            </summary>
            <param name="enumType">The enum type to create the default equality comparer for.</param>
        </member>
        <member name="T:System.Collections.Generic.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Dictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Dictionary`2.TrimExcess">
            <summary>
            Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            
            To allocate minimum size storage array, execute the following statements:
            
            dictionary.Clear();
            dictionary.TrimExcess();
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Dictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            </summary>
        </member>
        <member name="T:System.Collections.Generic.IAsyncEnumerable`1">
            <summary>Exposes an enumerator that provides asynchronous iteration over values of a specified type.</summary>
            <typeparam name="T">The type of values to enumerate.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IAsyncEnumerable`1.GetAsyncEnumerator(System.Threading.CancellationToken)">
            <summary>Returns an enumerator that iterates asynchronously through the collection.</summary>
            <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken"/> that may be used to cancel the asynchronous iteration.</param>
            <returns>An enumerator that can be used to iterate asynchronously through the collection.</returns>
        </member>
        <member name="T:System.Collections.Generic.IAsyncEnumerator`1">
            <summary>Supports a simple asynchronous iteration over a generic collection.</summary>
            <typeparam name="T">The type of objects to enumerate.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IAsyncEnumerator`1.MoveNextAsync">
            <summary>Advances the enumerator asynchronously to the next element of the collection.</summary>
            <returns>
            A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that will complete with a result of <c>true</c> if the enumerator
            was successfully advanced to the next element, or <c>false</c> if the enumerator has passed the end
            of the collection.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.IAsyncEnumerator`1.Current">
            <summary>Gets the element in the collection at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Collections.Generic.KeyValuePair.PairToString(System.Object,System.Object)">
            <summary>
            Used by KeyValuePair.ToString to reduce generic code
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueue`1">
            <summary>
            Represents a thread-safe first-in, first-out collection of objects.
            </summary>
            <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
            <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1.InitialSegmentLength">
            <summary>Initial length of the segments used in the queue.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1.MaxSegmentLength">
            <summary>
            Maximum length of the segments used in the queue.  This is a somewhat arbitrary limit:
            larger means that as long as we don't exceed the size, we avoid allocating more segments,
            but if we do exceed it, then the segment becomes garbage.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1._crossSegmentLock">
            <summary>
            Lock used to protect cross-segment operations, including any updates to <see cref="F:System.Collections.Concurrent.ConcurrentQueue`1._tail"/> or <see cref="F:System.Collections.Concurrent.ConcurrentQueue`1._head"/>
            and any operations that need to get a consistent view of them.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1._tail">
            <summary>The current tail segment.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueue`1._head">
            <summary>The current head segment.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> class.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> class that contains elements copied
            from the specified collection.
            </summary>
            <param name="collection">
            The collection whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is null.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
            cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array">Array</see> that is the destination of the
            elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>. <paramref name="array"/> must have
            zero-based indexing.
            </param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see
            cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>. The value can be a null
            reference (Nothing in Visual Basic) for reference types.
            </param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this operation will always add the object to the
            end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            and return true.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">
            When this method returns, if the operation was successful, <paramref name="item"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this operation will attempt to remove the object
            from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is empty; otherwise, false.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count"/> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/> returns, thus invalidating
            the result.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToArray">
            <summary>Copies the elements stored in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> to a new array.</summary>
            <returns>A new array containing a snapshot of elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</value>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/>
            property is recommended rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count"/>
            property and comparing it to 0.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetCount(System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32,System.Int32)">
            <summary>Computes the number of items in a segment based on a fixed head and tail in that segment.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetCount(System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32,System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32)">
            <summary>Gets the number of items in snapped region.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> elements to an existing one-dimensional <see
            cref="T:System.Array">Array</see>, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>. The <see cref="T:System.Array">Array</see> must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref
            name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</summary>
            <returns>An enumerator for the contents of the <see
            cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the queue.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the queue.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.SnapForObservation(System.Collections.Concurrent.ConcurrentQueueSegment{`0}@,System.Int32@,System.Collections.Concurrent.ConcurrentQueueSegment{`0}@,System.Int32@)">
            <summary>
            Gets the head and tail information of the current contents of the queue.
            After this call returns, the specified region can be enumerated any number
            of times and will not change.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetItemWhenAvailable(System.Collections.Concurrent.ConcurrentQueueSegment{`0},System.Int32)">
            <summary>Gets the item stored in the <paramref name="i"/>th entry in <paramref name="segment"/>.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Enqueue(`0)">
            <summary>Adds an object to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</summary>
            <param name="item">
            The object to add to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            The value can be a null reference (Nothing in Visual Basic) for reference types.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.EnqueueSlow(`0)">
            <summary>Adds to the end of the queue, adding a new segment if necessary.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            Attempts to remove and return the object at the beginning of the <see
            cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <param name="result">
            When this method returns, if the operation was successful, <paramref name="result"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the beginning of the
            <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> successfully; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeueSlow(`0@)">
            <summary>Tries to dequeue an item, removing empty segments as needed.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            without removing it.
            </summary>
            <param name="result">
            When this method returns, <paramref name="result"/> contains an object from
            the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> or default(T)
            if the operation failed.
            </param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/>
            property is recommended rather than peeking.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@,System.Boolean)">
            <summary>Attempts to retrieve the value for the first element in the queue.</summary>
            <param name="result">The value of the first element, if found.</param>
            <param name="resultUsed">true if the result is needed; otherwise false if only the true/false outcome is needed.</param>
            <returns>true if an element was found; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Clear">
            <summary>
            Removes all objects from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueueSegment`1">
            <summary>
            Provides a multi-producer, multi-consumer thread-safe bounded segment.  When the queue is full,
            enqueues fail and return false.  When the queue is empty, dequeues fail and return null.
            These segments are linked together to form the unbounded <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>. 
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._slots">
            <summary>The array of items in this queue.  Each slot contains the item in that slot and its "sequence number".</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._slotsMask">
            <summary>Mask for quickly accessing a position within the queue's array.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._headAndTail">
            <summary>The head and tail positions, with padding to help avoid false sharing contention.</summary>
            <remarks>Dequeuing happens from the head, enqueuing happens at the tail.</remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._preservedForObservation">
            <summary>Indicates whether the segment has been marked such that dequeues don't overwrite the removed data.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._frozenForEnqueues">
            <summary>Indicates whether the segment has been marked such that no additional items may be enqueued.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._nextSegment">
            <summary>The segment following this one in the queue, or null if this segment is the last in the queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.#ctor(System.Int32)">
            <summary>Creates the segment.</summary>
            <param name="boundedLength">
            The maximum number of elements the segment can contain.  Must be a power of 2.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.RoundUpToPowerOf2(System.Int32)">
            <summary>Round the specified value up to the next power of 2, if it isn't one already.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueueSegment`1.Capacity">
            <summary>Gets the number of elements this segment can store.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueueSegment`1.FreezeOffset">
            <summary>Gets the "freeze offset" for this segment.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.EnsureFrozenForEnqueues">
            <summary>
            Ensures that the segment will not accept any subsequent enqueues that aren't already underway.
            </summary>
            <remarks>
            When we mark a segment as being frozen for additional enqueues,
            we set the <see cref="F:System.Collections.Concurrent.ConcurrentQueueSegment`1._frozenForEnqueues"/> bool, but that's mostly
            as a small helper to avoid marking it twice.  The real marking comes
            by modifying the Tail for the segment, increasing it by this
            <see cref="P:System.Collections.Concurrent.ConcurrentQueueSegment`1.FreezeOffset"/>.  This effectively knocks it off the
            sequence expected by future enqueuers, such that any additional enqueuer
            will be unable to enqueue due to it not lining up with the expected
            sequence numbers.  This value is chosen specially so that Tail will grow
            to a value that maps to the same slot but that won't be confused with
            any other enqueue/dequeue sequence number.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.TryDequeue(`0@)">
            <summary>Tries to dequeue an element from the queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.TryPeek(`0@,System.Boolean)">
            <summary>Tries to peek at an element from the queue, without removing it.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueueSegment`1.TryEnqueue(`0)">
            <summary>
            Attempts to enqueue the item.  If successful, the item will be stored
            in the queue and true will be returned; otherwise, the item won't be stored, and false
            will be returned.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueueSegment`1.Slot">
            <summary>Represents a slot in the queue.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1.Slot.Item">
            <summary>The item.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentQueueSegment`1.Slot.SequenceNumber">
            <summary>The sequence number for this slot, used to synchronize between enqueuers and dequeuers.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.PaddedHeadAndTail">
            <summary>Padded head and tail indices, to avoid false sharing between producers and consumers.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerCollection`1">
            <summary>
            A common interface for all concurrent collections.
            Defines methods to manipulate thread-safe collections intended for producer/consumer usage.
            </summary>
            <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
            <remarks>
            All implementations of this interface must enable all members of this interface
            to be used concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> to
            an
            <see cref="T:System.Array"/>, starting at a specified index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
            the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            The array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref
            name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.</param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="item"/> was invalid for this collection.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">
            When this method returns, if the object was removed and returned successfully, <paramref
            name="item"/> contains the removed object. If no object was available to be removed, the value is
            unspecified.
            </param>
            <returns>true if an object was removed and returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
            <summary>
            Copies the elements contained in the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> to a new array.
            </summary>
            <returns>A new array containing the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.</returns>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1">
            <summary>
            A debugger view of the IProducerConsumerCollection that makes it simple to browse the
            collection's contents at a point in time.
            </summary>
            <typeparam name="T">The type of elements stored within.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Constructs a new debugger view object for the provided collection object.
            </summary>
            <param name="collection">A collection to browse in the debugger.</param>
        </member>
        <member name="P:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.Items">
            <summary>
            Returns a snapshot of the underlying collection's elements.
            </summary>
        </member>
        <member name="T:System.Collections.IHashCodeProvider">
            <summary>
            Provides a mechanism for a <see cref="T:System.Collections.Hashtable"/> user to override the default
            GetHashCode() function on Objects, providing their own hash function.
            </summary>
        </member>
        <member name="M:System.Collections.IHashCodeProvider.GetHashCode(System.Object)">
            <summary>Returns a hash code for the given object.</summary>
        </member>
        <member name="T:System.Collections.ListDictionaryInternal">
               This is a simple implementation of IDictionary using a singly linked list. This
               will be smaller and faster than a Hashtable if the number of elements is 10 or less.
               This should not be used if performance is important for large numbers of elements.
        </member>
        <member name="T:System.Decimal.DecCalc">
            <summary>
            Class that contains all the mathematical calculations for decimal. Most of which have been ported from oleaut32.
            </summary>
        </member>
        <member name="F:System.Decimal.DecCalc.ulomidLE">
            <summary>
            The low and mid fields combined in little-endian order
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.Div96By32(System.Decimal.DecCalc.Buf12@,System.UInt32)">
            <summary>
            Do full divide, yielding 96-bit result and 32-bit remainder.
            </summary>
            <param name="bufNum">96-bit dividend as array of uints, least-sig first</param>
            <param name="den">32-bit divisor</param>
            <returns>Returns remainder. Quotient overwrites dividend.</returns>
        </member>
        <member name="M:System.Decimal.DecCalc.Unscale(System.UInt32@,System.UInt64@,System.Int32@)">
            <summary>
            Normalize (unscale) the number by trying to divide out 10^8, 10^4, 10^2, and 10^1.
            If a division by one of these powers returns a zero remainder, then we keep the quotient.
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.Div96By64(System.Decimal.DecCalc.Buf12@,System.UInt64)">
            <summary>
            Do partial divide, yielding 32-bit result and 64-bit remainder.
            Divisor must be larger than upper 64 bits of dividend.
            </summary>
            <param name="bufNum">96-bit dividend as array of uints, least-sig first</param>
            <param name="den">64-bit divisor</param>
            <returns>Returns quotient. Remainder overwrites lower 64-bits of dividend.</returns>
        </member>
        <member name="M:System.Decimal.DecCalc.Div128By96(System.Decimal.DecCalc.Buf16@,System.Decimal.DecCalc.Buf12@)">
            <summary>
            Do partial divide, yielding 32-bit result and 96-bit remainder.
            Top divisor uint must be larger than top dividend uint. This is
            assured in the initial call because the divisor is normalized
            and the dividend can't be. In subsequent calls, the remainder
            is multiplied by 10^9 (max), so it can be no more than 1/4 of
            the divisor which is effectively multiplied by 2^32 (4 * 10^9).
            </summary>
            <param name="bufNum">128-bit dividend as array of uints, least-sig first</param>
            <param name="bufDen">96-bit divisor</param>
            <returns>Returns quotient. Remainder overwrites lower 96-bits of dividend.</returns>
        </member>
        <member name="M:System.Decimal.DecCalc.IncreaseScale(System.Decimal.DecCalc.Buf12@,System.UInt32)">
            <summary>
            Multiply the two numbers. The low 96 bits of the result overwrite
            the input. The last 32 bits of the product are the return value.
            </summary>
            <param name="bufNum">96-bit number as array of uints, least-sig first</param>
            <param name="power">Scale factor to multiply by</param>
            <returns>Returns highest 32 bits of product</returns>
        </member>
        <member name="M:System.Decimal.DecCalc.ScaleResult(System.Decimal.DecCalc.Buf24*,System.UInt32,System.Int32)">
            <summary>
            See if we need to scale the result to fit it in 96 bits.
            Perform needed scaling. Adjust scale factor accordingly.
            </summary>
            <param name="bufRes">Array of uints with value, least-significant first</param>
            <param name="hiRes">Index of last non-zero value in bufRes</param>
            <param name="scale">Scale factor for this value, range 0 - 2 * DEC_SCALE_MAX</param>
            <returns>Returns new scale factor. bufRes updated in place, always 3 uints.</returns>
        </member>
        <member name="M:System.Decimal.DecCalc.OverflowUnscale(System.Decimal.DecCalc.Buf12@,System.Int32,System.Boolean)">
            <summary>
            Adjust the quotient to deal with an overflow.
            We need to divide by 10, feed in the high bit to undo the overflow and then round as required.
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.SearchScale(System.Decimal.DecCalc.Buf12@,System.Int32)">
            <summary>
            Determine the max power of 10, &lt;= 9, that the quotient can be scaled
            up by and still fit in 96 bits.
            </summary>
            <param name="bufQuo">96-bit quotient</param>
            <param name="scale ">Scale factor of quotient, range -DEC_SCALE_MAX to DEC_SCALE_MAX-1</param>
            <returns>power of 10 to scale by</returns>
        </member>
        <member name="M:System.Decimal.DecCalc.Add32To96(System.Decimal.DecCalc.Buf12@,System.UInt32)">
            <summary>
            Add a 32-bit uint to an array of 3 uints representing a 96-bit integer.
            </summary>
            <returns>Returns false if there is an overflow</returns>
        </member>
        <member name="M:System.Decimal.DecCalc.DecAddSub(System.Decimal.DecCalc@,System.Decimal.DecCalc@,System.Boolean)">
            <summary>
            Adds or subtracts two decimal values.
            On return, d1 contains the result of the operation and d2 is trashed.
            </summary>
            <param name="sign">True means subtract and false means add.</param>
        </member>
        <member name="M:System.Decimal.DecCalc.VarCyFromDec(System.Decimal.DecCalc@)">
            <summary>
            Convert Decimal to Currency (similar to OleAut32 api.)
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarDecCmp(System.Decimal@,System.Decimal@)">
            <summary>
            Decimal Compare updated to return values similar to ICompareTo
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarDecMul(System.Decimal.DecCalc@,System.Decimal.DecCalc@)">
            <summary>
            Decimal Multiply
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarDecFromR4(System.Single,System.Decimal.DecCalc@)">
            <summary>
            Convert float to Decimal
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarDecFromR8(System.Double,System.Decimal.DecCalc@)">
            <summary>
            Convert double to Decimal
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarR4FromDec(System.Decimal@)">
            <summary>
            Convert Decimal to float
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarR8FromDec(System.Decimal@)">
            <summary>
            Convert Decimal to double
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarDecDiv(System.Decimal.DecCalc@,System.Decimal.DecCalc@)">
            <summary>
            Divides two decimal values.
            On return, d1 contains the result of the operation.
            </summary>
        </member>
        <member name="M:System.Decimal.DecCalc.VarDecMod(System.Decimal.DecCalc@,System.Decimal.DecCalc@)">
            <summary>
            Computes the remainder between two decimals.
            On return, d1 contains the result of the operation and d2 is trashed.
            </summary>
        </member>
        <member name="P:System.Decimal.DecCalc.Buf12.High64">
            <summary>
            U1-U2 combined (overlaps with Low64)
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.NativeRuntimeEventSource">
            <summary>
            NativeRuntimeEventSource is an EventSource that represents the ETW/EventPipe events emitted by the native runtime.
            Most of NativeRuntimeEventSource is auto-generated by scripts/genRuntimeEventSources.py based on the contents of the Microsoft-Windows-DotNETRuntime provider.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.NativeRuntimeEventSource.ProcessEvent(System.UInt32,System.UInt32,System.DateTime,System.Guid,System.Guid,System.ReadOnlySpan{System.Byte})">
            <summary>
            Dispatch a single event with the specified event ID and payload.
            </summary>
            <param name="eventID">The eventID corresponding to the event as defined in the auto-generated portion of the NativeRuntimeEventSource class.</param>
            <param name="payload">A span pointing to the data payload for the event.</param>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventPipeController">
            <summary>
            Simple out-of-process listener for controlling EventPipe.
            The following environment variables are used to configure EventPipe:
             - COMPlus_EnableEventPipe=1 : Enable EventPipe immediately for the life of the process.
             - COMPlus_EventPipeConfig : Provides the configuration in xperf string form for which providers/keywords/levels to be enabled.
                                         If not specified, the default configuration is used.
             - COMPlus_EventPipeOutputFile : The full path to the netperf file to be written.
             - COMPlus_EventPipeCircularMB : The size in megabytes of the circular buffer.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventPipeController.Config_EnableEventPipe">
            <summary>
            Returns -1 if the EnableEventPipe environment variable is not set at all (or is illegal)
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventPipeEventDispatcher.TimeStampToDateTime(System.Int64)">
            <summary>
            Converts a QueryPerformanceCounter (QPC) timestamp to a UTC DateTime.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventPipePayloadDecoder.DecodePayload(System.Diagnostics.Tracing.EventSource.EventMetadata@,System.ReadOnlySpan{System.Byte})">
            <summary>
            Given the metadata for an event and an event payload, decode and deserialize the event payload.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.RuntimeEventSource">
            <summary>
            RuntimeEventSource is an EventSource that represents events emitted by the managed runtime.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.TraceLoggingEventHandleTable">
            <summary>
            Per-EventSource data structure for caching EventPipe EventHandles associated with TraceLogging events.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ActivityTracker">
             <summary>
             Tracks activities.  This is meant to be a singleton (accessed by the ActivityTracer.Instance static property)
              
             Logically this is simply holds the m_current variable that holds the async local that holds the current ActivityInfo
             An ActivityInfo is represents a activity (which knows its creator and thus knows its path). 
            
             Most of the magic is in the async local (it gets copied to new tasks)
             
             On every start event call OnStart 
             
                 Guid activityID;
                 Guid relatedActivityID;
                 if (OnStart(activityName, out activityID, out relatedActivityID, ForceStop, options))
                     // Log Start event with activityID and relatedActivityID
                 
             On every stop event call OnStop
             
                 Guid activityID;
                 if (OnStop(activityName, ref activityID  ForceStop))
                     // Stop event with activityID
                        
             On any normal event log the event with activityTracker.CurrentActivityId
             </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.OnStart(System.String,System.String,System.Int32,System.Guid@,System.Guid@,System.Diagnostics.Tracing.EventActivityOptions)">
            <summary>
            Called on work item begins.  The activity name = providerName + activityName without 'Start' suffix.
            It updates CurrentActivityId to track.   
            
            It returns true if the Start should be logged, otherwise (if it is illegal recursion) it return false. 
            
            The start event should use as its activity ID the CurrentActivityId AFTER calling this routine and its
            RelatedActivityID the CurrentActivityId BEFORE calling this routine (the creator).  
            
            If activity tracing is not on, then activityId and relatedActivityId are not set
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.OnStop(System.String,System.String,System.Int32,System.Guid@)">
             <summary>
             Called when a work item stops.  The activity name = providerName + activityName without 'Stop' suffix.
             It updates m_current variable to track this fact.   The Stop event associated with stop should log the ActivityID associated with the event.
            
             If activity tracing is not on, then activityId and relatedActivityId are not set
             </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.Enable">
            <summary>
            Turns on activity tracking.    It is sticky, once on it stays on (race issues otherwise)
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.ActivityTracker.Instance">
            <summary>
            An activity tracker is a singleton, this is how you get the one and only instance.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.FindActiveActivity(System.String,System.Diagnostics.Tracing.ActivityTracker.ActivityInfo)">
            <summary>
            Searched for a active (nonstopped) activity with the given name.  Returns null if not found.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.NormalizeActivityName(System.String,System.String,System.Int32)">
            <summary>
            Strip out "Start" or "End" suffix from activity name and add providerName prefix.
            If 'task'  it does not end in Start or Stop and Task is non-zero use that as the name of the activity
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ActivityTracker.ActivityInfo">
            <summary>
            An ActivityInfo represents a particular activity.   It is almost read-only.   The only
            fields that change after creation are
               m_lastChildID - used to generate unique IDs for the children activities and for the most part can be ignored.
               m_stopped - indicates that this activity is dead 
            This read-only-ness is important because an activity's  m_creator chain forms the 
            'Path of creation' for the activity (which is also its unique ID) but is also used as
            the 'list of live parents' which indicate of those ancestors, which are alive (if they
            are not marked dead they are alive).   
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.ActivityInfo.CreateActivityPathGuid(System.Guid@,System.Int32@)">
             <summary>
             Logically every activity Path (see Path()) that describes the activities that caused this 
             (rooted in an activity that predates activity tracking.  
            
             We wish to encode this path in the Guid to the extent that we can.  Many of the paths have
             many small numbers in them and we take advantage of this in the encoding to output as long
             a path in the GUID as possible.   
             
             Because of the possibility of GUID collision, we only use 96 of the 128 bits of the GUID
             for encoding the path.  The last 32 bits are a simple checksum (and random number) that 
             identifies this as using the convention defined here.   
            
             It returns both the GUID which has the path as well as the offset that points just beyond
             the end of the activity (so it can be appended to).  Note that if the end is in a nibble
             (it uses nibbles instead of bytes as the unit of encoding, then it will point at the unfinished
             byte (since the top nibble can't be zero you can determine if this is true by seeing if 
             this byte is nonZero.   This offset is needed to efficiently create the ID for child activities. 
             </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.ActivityInfo.CreateOverflowGuid(System.Guid*)">
            <summary>
            If we can't fit the activity Path into the GUID we come here.   What we do is simply
            generate a 4 byte number (s_nextOverflowId).  Then look for an ancestor that has  
            sufficient space for this ID.   By doing this, we preserve the fact that this activity
            is a child (of unknown depth) from that ancestor.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ActivityTracker.ActivityInfo.NumberListCodes">
            <summary>
            The encoding for a list of numbers used to make Activity  GUIDs.   Basically
            we operate on nibbles (which are nice because they show up as hex digits).  The
            list is ended with a end nibble (0) and depending on the nibble value (Below)
            the value is either encoded into nibble itself or it can spill over into the
            bytes that follow.   
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.ActivityInfo.AddIdToGuid(System.Guid*,System.Int32,System.UInt32,System.Boolean)">
            Add the activity id 'id' to the output Guid 'outPtr' starting at the offset 'whereToAddId'
            Thus if this number is 6 that is where 'id' will be added.    This will return 13 (12
            is the maximum number of bytes that fit in a GUID) if the path did not fit.  
            If 'overflow' is true, then the number is encoded as an 'overflow number (which has a
            special (longer prefix) that indicates that this ID is allocated differently 
        </member>
        <member name="M:System.Diagnostics.Tracing.ActivityTracker.ActivityInfo.WriteNibble(System.Byte*@,System.Byte*,System.UInt32)">
            <summary>
            Write a single Nible 'value' (must be 0-15) to the byte buffer represented by *ptr.  
            Will not go past 'endPtr'.  Also it assumes that we never write 0 so we can detect
            whether a nibble has already been written to ptr  because it will be nonzero.   
            Thus if it is non-zero it adds to the current byte, otherwise it advances and writes
            the new byte (in the high bits) of the next byte.  
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.ActivityTracker.m_current">
            <summary>
            Async local variables have the property that the are automatically copied whenever a task is created and used
            while that task is running.   Thus m_current 'flows' to any task that is caused by the current thread that
            last set it.   
            
            This variable points to a linked list that represents all Activities that have started but have not stopped.  
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.DiagnosticCounter">
            <summary>
            DiagnosticCounter is an abstract class that serves as the parent class for various Counter* classes, 
            namely EventCounter, PollingCounter, IncrementingEventCounter, and IncrementingPollingCounter.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.DiagnosticCounter.#ctor(System.String,System.Diagnostics.Tracing.EventSource)">
            <summary>
            All Counters live as long as the EventSource that they are attached to unless they are
            explicitly Disposed.   
            </summary>
            <param name="name">The name.</param>
            <param name="eventSource">The event source.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.DiagnosticCounter.Dispose">
            <summary>
            Removes the counter from set that the EventSource will report on.  After being disposed, this
            counter will do nothing and its resource will be reclaimed if all references to it are removed.
            If an EventCounter is not explicitly disposed it will be cleaned up automatically when the
            EventSource it is attached to dies.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.DiagnosticCounter.AddMetadata(System.String,System.String)">
            <summary>
            Adds a key-value metadata to the EventCounter that will be included as a part of the payload
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventActivityOptions">
            <summary>
            EventActivityOptions flags allow to specify different activity related characteristics.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventActivityOptions.None">
            <summary>
            No special options are added to the event.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventActivityOptions.Disable">
            <summary>
            Disable Implicit Activity Tracking
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventActivityOptions.Recursive">
            <summary>
            Allow activity event to call itself (directly or indirectly)
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventActivityOptions.Detachable">
            <summary>
            Allows event activity to live beyond its parent.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventCounter">
            <summary>
            Provides the ability to collect statistics through EventSource
            
            See https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md
            for a tutorial guide.  
            
            See https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Tracing/tests/BasicEventSourceTest/TestEventCounter.cs
            which shows tests, which are also useful in seeing actual use.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventCounter.#ctor(System.String,System.Diagnostics.Tracing.EventSource)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.Tracing.EventCounter"/> class.
            EVentCounters live as long as the EventSource that they are attached to unless they are
            explicitly Disposed.   
            </summary>
            <param name="name">The name.</param>
            <param name="eventSource">The event source.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventCounter.WriteMetric(System.Single)">
            <summary>
            Writes 'value' to the stream of values tracked by the counter.  This updates the sum and other statistics that will 
            be logged on the next timer interval.  
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="T:System.Diagnostics.Tracing.CounterPayloadType">
            <summary>
            This is the payload that is sent in the with EventSource.Write
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventProvider">
            <summary>
            Only here because System.Diagnostics.EventProvider needs one more extensibility hook (when it gets a 
            controller callback)
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventProvider.SessionInfo">
            <summary>
            A struct characterizing ETW sessions (identified by the etwSessionId) as
            activity-tracing-aware or legacy. A session that's activity-tracing-aware
            has specified one non-zero bit in the reserved range 44-47 in the 
            'allKeywords' value it passed in for a specific EventProvider.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.Register(System.Diagnostics.Tracing.EventSource)">
            <summary>
            This method registers the controlGuid of this class with ETW. We need to be running on
            Vista or above. If not a PlatformNotSupported exception will be thrown. If for some 
            reason the ETW Register call failed a NotSupported exception will be thrown. 
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.Close">
            <summary>
            This method deregisters the controlGuid of this class with ETW.
            
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.GetSessions">
             <summary>
             Determines the ETW sessions that have been added and/or removed to the set of
             sessions interested in the current provider. It does so by (1) enumerating over all
             ETW sessions that enabled 'this.m_Guid' for the current process ID, and (2)
             comparing the current list with a list it cached on the previous invocation.
            
             The return value is a list of tuples, where the SessionInfo specifies the
             ETW session that was added or remove, and the bool specifies whether the
             session was added or whether it was removed from the set.
             </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.GetSessionInfoCallback(System.Int32,System.Int64,System.Collections.Generic.List{System.Diagnostics.Tracing.EventProvider.SessionInfo}@)">
            <summary>
            This method is the callback used by GetSessions() when it calls into GetSessionInfo().
            It updates a List{SessionInfo} based on the etwSessionId and matchAllKeywords that
            GetSessionInfo() passes in.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.GetSessionInfo(System.Diagnostics.Tracing.EventProvider.SessionInfoCallback,System.Collections.Generic.List{System.Diagnostics.Tracing.EventProvider.SessionInfo}@)">
            <summary>
            This method enumerates over all active ETW sessions that have enabled 'this.m_Guid' 
            for the current process ID, calling 'action' for each session, and passing it the
            ETW session and the 'AllKeywords' the session enabled for the current provider.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.IndexOfSessionInList(System.Collections.Generic.List{System.Diagnostics.Tracing.EventProvider.SessionInfo},System.Int32)">
            <summary>
            Returns the index of the SesisonInfo from 'sessions' that has the specified 'etwSessionId'
            or -1 if the value is not present.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.GetDataFromController(System.Int32,Interop.Advapi32.EVENT_FILTER_DESCRIPTOR*,System.Diagnostics.Tracing.ControllerCommand@,System.Byte[]@,System.Int32@)">
            <summary>
            Gets any data to be passed from the controller to the provider.  It starts with what is passed
            into the callback, but unfortunately this data is only present for when the provider is active
            at the time the controller issues the command.  To allow for providers to activate after the
            controller issued a command, we also check the registry and use that to get the data.  The function
            returns an array of bytes representing the data, the index into that byte array where the data
            starts, and the command being issued associated with that data.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.IsEnabled">
            <summary>
            IsEnabled, method used to test if provider is enabled
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.IsEnabled(System.Byte,System.Int64)">
            <summary>
            IsEnabled, method used to test if event is enabled
            </summary>
            <param name="level">
            Level  to test
            </param>
            <param name="keywords">
            Keyword  to test
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.WriteEvent(System.Diagnostics.Tracing.EventDescriptor@,System.IntPtr,System.Guid*,System.Guid*,System.Object[])">
            <summary>
            WriteEvent, method to write a parameters with event schema properties
            </summary>
            <param name="eventDescriptor">
            Event Descriptor for this event. 
            </param>
            <param name="activityID">
            A pointer to the activity ID GUID to log 
            </param>
            <param name="childActivityID">
            childActivityID is marked as 'related' to the current activity ID. 
            </param>
            <param name="eventPayload">
            Payload for the ETW event. 
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventProvider.WriteEvent(System.Diagnostics.Tracing.EventDescriptor@,System.IntPtr,System.Guid*,System.Guid*,System.Int32,System.IntPtr)">
            <summary>
            WriteEvent, method to be used by generated code on a derived class
            </summary>
            <param name="eventDescriptor">
            Event Descriptor for this event. 
            </param>
            <param name="activityID">
            A pointer to the activity ID to log 
            </param>
            <param name="childActivityID">
            If this event is generating a child activity (WriteEventTransfer related activity) this is child activity
            This can be null for events that do not generate a child activity.  
            </param>
            <param name="dataCount">
            number of event descriptors 
            </param>
            <param name="data">
            pointer  do the event data
            </param>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSource">
            <summary>
            This class is meant to be inherited by a user-defined event source in order to define a managed
            ETW provider.   Please See DESIGN NOTES above for the internal architecture.  
            The minimal definition of an EventSource simply specifies a number of ETW event methods that
            call one of the EventSource.WriteEvent overloads, <see cref="M:System.Diagnostics.Tracing.EventSource.WriteEventCore(System.Int32,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)"/>, 
            or <see cref="M:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore(System.Int32,System.Guid*,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)"/> to log them. This functionality 
            is sufficient for many users.
            <para>
            To achieve more control over the ETW provider manifest exposed by the event source type, the 
            [<see cref="T:System.Diagnostics.Tracing.EventAttribute"/>] attributes can be specified for the ETW event methods.
            </para><para>
            For very advanced EventSources, it is possible to intercept the commands being given to the
            eventSource and change what filtering is done (see EventListener.EnableEvents and 
            <see cref="M:System.Diagnostics.Tracing.EventListener.DisableEvents(System.Diagnostics.Tracing.EventSource)"/>) or cause actions to be performed by the eventSource, 
            e.g. dumping a data structure (see EventSource.SendCommand and
            <see cref="M:System.Diagnostics.Tracing.EventSource.OnEventCommand(System.Diagnostics.Tracing.EventCommandEventArgs)"/>).
            </para><para>
            The eventSources can be turned on with Windows ETW controllers (e.g. logman), immediately. 
            It is also possible to control and intercept the data dispatcher programmatically.  See 
            <see cref="T:System.Diagnostics.Tracing.EventListener"/> for more.
            </para>
            </summary>
            <remarks>
            This is a minimal definition for a custom event source:
            <code>
            [EventSource(Name="Samples-Demos-Minimal")]
            sealed class MinimalEventSource : EventSource
            {
                public static MinimalEventSource Log = new MinimalEventSource();
                public void Load(long ImageBase, string Name) { WriteEvent(1, ImageBase, Name); }
                public void Unload(long ImageBase) { WriteEvent(2, ImageBase); }
                private MinimalEventSource() {}
            }
            </code>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.Name">
            <summary>
            The human-friendly name of the eventSource.  It defaults to the simple name of the class
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.Guid">
            <summary>
            Every eventSource is assigned a GUID to uniquely identify it to the system. 
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.IsEnabled">
            <summary>
            Returns true if the eventSource has been enabled at all. This is the preferred test
            to be performed before a relatively expensive EventSource operation.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.IsEnabled(System.Diagnostics.Tracing.EventLevel,System.Diagnostics.Tracing.EventKeywords)">
            <summary>
            Returns true if events with greater than or equal 'level' and have one of 'keywords' set are enabled. 
            
            Note that the result of this function is only an approximation on whether a particular
            event is active or not. It is only meant to be used as way of avoiding expensive
            computation for logging when logging is not on, therefore it sometimes returns false
            positives (but is always accurate when returning false).  EventSources are free to 
            have additional filtering.    
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.IsEnabled(System.Diagnostics.Tracing.EventLevel,System.Diagnostics.Tracing.EventKeywords,System.Diagnostics.Tracing.EventChannel)">
            <summary>
            Returns true if events with greater than or equal 'level' and have one of 'keywords' set are enabled, or
            if 'keywords' specifies a channel bit for a channel that is enabled.
            
            Note that the result of this function only an approximation on whether a particular
            event is active or not. It is only meant to be used as way of avoiding expensive
            computation for logging when logging is not on, therefore it sometimes returns false
            positives (but is always accurate when returning false).  EventSources are free to 
            have additional filtering.    
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.Settings">
            <summary>
            Returns the settings for the event source instance
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.GetGuid(System.Type)">
            <summary>
            Returns the GUID that uniquely identifies the eventSource defined by 'eventSourceType'.  
            This API allows you to compute this without actually creating an instance of the EventSource.   
            It only needs to reflect over the type.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.GetName(System.Type)">
            <summary>
            Returns the official ETW Provider name for the eventSource defined by 'eventSourceType'.  
            This API allows you to compute this without actually creating an instance of the EventSource.   
            It only needs to reflect over the type.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.GenerateManifest(System.Type,System.String)">
            <summary>
            Returns a string of the XML manifest associated with the eventSourceType. The scheme for this XML is
            documented at in EventManifest Schema https://docs.microsoft.com/en-us/windows/desktop/WES/eventmanifestschema-schema.
            This is the preferred way of generating a manifest to be embedded in the ETW stream as it is fast and
            the fact that it only includes localized entries for the current UI culture is an acceptable tradeoff.
            </summary>
            <param name="eventSourceType">The type of the event source class for which the manifest is generated</param>
            <param name="assemblyPathToIncludeInManifest">The manifest XML fragment contains the string name of the DLL name in
            which it is embedded.  This parameter specifies what name will be used</param>
            <returns>The XML data string</returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.GenerateManifest(System.Type,System.String,System.Diagnostics.Tracing.EventManifestOptions)">
            <summary>
            Returns a string of the XML manifest associated with the eventSourceType. The scheme for this XML is
            documented at in EventManifest Schema https://docs.microsoft.com/en-us/windows/desktop/WES/eventmanifestschema-schema.
            Pass EventManifestOptions.AllCultures when generating a manifest to be registered on the machine. This
            ensures that the entries in the event log will be "optimally" localized.
            </summary>
            <param name="eventSourceType">The type of the event source class for which the manifest is generated</param>
            <param name="assemblyPathToIncludeInManifest">The manifest XML fragment contains the string name of the DLL name in
            which it is embedded.  This parameter specifies what name will be used</param>
            <param name="flags">The flags to customize manifest generation. If flags has bit OnlyIfNeededForRegistration specified
            this returns null when the eventSourceType does not require explicit registration</param>
            <returns>The XML data string or null</returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.GetSources">
            <summary>
            returns a list (IEnumerable) of all sources in the appdomain).  EventListeners typically need this.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.SendCommand(System.Diagnostics.Tracing.EventSource,System.Diagnostics.Tracing.EventCommand,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send a command to a particular EventSource identified by 'eventSource'.
            Calling this routine simply forwards the command to the EventSource.OnEventCommand
            callback.  What the EventSource does with the command and its arguments are from 
            that point EventSource-specific.  
            </summary>
            <param name="eventSource">The instance of EventSource to send the command to</param>
            <param name="command">A positive user-defined EventCommand, or EventCommand.SendManifest</param>
            <param name="commandArguments">A set of (name-argument, value-argument) pairs associated with the command</param>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.ConstructionException">
            <summary>
            Because
            
                1) Logging is often optional and thus should not generate fatal errors (exceptions)
                2) EventSources are often initialized in class constructors (which propagate exceptions poorly)
                
            The event source constructor does not throw exceptions.  Instead we remember any exception that 
            was generated (it is also logged to Trace.WriteLine).
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.GetTrait(System.String)">
            <summary>
            EventSources can have arbitrary string key-value pairs associated with them called Traits.  
            These traits are not interpreted by the EventSource but may be interpreted by EventListeners
            (e.g. like the built in ETW listener).   These traits are specified at EventSource 
            construction time and can be retrieved by using this GetTrait API.  
            </summary>
            <param name="key">The key to look up in the set of key-value pairs passed to the EventSource constructor</param>
            <returns>The value string associated with key.  Will return null if there is no such key.</returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.ToString">
            <summary>
            Displays the name and GUID for the eventSource for debugging purposes.  
            </summary>
        </member>
        <member name="E:System.Diagnostics.Tracing.EventSource.EventCommandExecuted">
            <summary>
            Fires when a Command (e.g. Enable) comes from a an EventListener.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId(System.Guid)">
            <summary>
            When a thread starts work that is on behalf of 'something else' (typically another 
            thread or network request) it should mark the thread as working on that other work.
            This API marks the current thread as working on activity 'activityID'. This API
            should be used when the caller knows the thread's current activity (the one being
            overwritten) has completed. Otherwise, callers should prefer the overload that
            return the oldActivityThatWillContinue (below).
            
            All events created with the EventSource on this thread are also tagged with the 
            activity ID of the thread. 
            
            It is common, and good practice after setting the thread to an activity to log an event
            with a 'start' opcode to indicate that precise time/thread where the new activity 
            started.
            </summary>
            <param name="activityId">A Guid that represents the new activity with which to mark 
            the current thread</param>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.CurrentThreadActivityId">
            <summary>
            Retrieves the ETW activity ID associated with the current thread.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.SetCurrentThreadActivityId(System.Guid,System.Guid@)">
            <summary>
            When a thread starts work that is on behalf of 'something else' (typically another 
            thread or network request) it should mark the thread as working on that other work.
            This API marks the current thread as working on activity 'activityID'. It returns 
            whatever activity the thread was previously marked with. There is a convention that
            callers can assume that callees restore this activity mark before the callee returns. 
            To encourage this, this API returns the old activity, so that it can be restored later.
            
            All events created with the EventSource on this thread are also tagged with the 
            activity ID of the thread. 
            
            It is common, and good practice after setting the thread to an activity to log an event
            with a 'start' opcode to indicate that precise time/thread where the new activity 
            started.
            </summary>
            <param name="activityId">A Guid that represents the new activity with which to mark 
            the current thread</param>
            <param name="oldActivityThatWillContinue">The Guid that represents the current activity  
            which will continue at some point in the future, on the current thread</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.#ctor">
            <summary>
            This is the constructor that most users will use to create their eventSource.   It takes 
            no parameters.  The ETW provider name and GUID of the EventSource are determined by the EventSource 
            custom attribute (so you can determine these things declaratively).   If the GUID for the eventSource
            is not specified in the EventSourceAttribute (recommended), it is Generated by hashing the name.
            If the ETW provider name of the EventSource is not given, the name of the EventSource class is used as
            the ETW provider name.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.#ctor(System.Boolean)">
            <summary>
            By default calling the 'WriteEvent' methods do NOT throw on errors (they silently discard the event).  
            This is because in most cases users assume logging is not 'precious' and do NOT wish to have logging failures
            crash the program. However for those applications where logging is 'precious' and if it fails the caller
            wishes to react, setting 'throwOnEventWriteErrors' will cause an exception to be thrown if WriteEvent
            fails. Note the fact that EventWrite succeeds does not necessarily mean that the event reached its destination
            only that operation of writing it did not fail. These EventSources will not generate self-describing ETW events.
            
            For compatibility only use the EventSourceSettings.ThrowOnEventWriteErrors flag instead.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.#ctor(System.Diagnostics.Tracing.EventSourceSettings)">
            <summary>
            Construct an EventSource with additional non-default settings (see EventSourceSettings for more)  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.#ctor(System.Diagnostics.Tracing.EventSourceSettings,System.String[])">
            <summary>
            Construct an EventSource with additional non-default settings.  
            
            Also specify a list of key-value pairs called traits (you must pass an even number of strings).   
            The first string is the key and the second is the value.   These are not interpreted by EventSource
            itself but may be interpreted the listeners.  Can be fetched with GetTrait(string).   
            </summary>
            <param name="settings">See EventSourceSettings for more.</param>
            <param name="traits">A collection of key-value strings (must be an even number).</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.OnEventCommand(System.Diagnostics.Tracing.EventCommandEventArgs)">
            <summary>
            This method is called when the eventSource is updated by the controller.  
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSource.EventData">
            <summary>
            Used to construct the data structure to be passed to the native ETW APIs - EventWrite and EventWriteTransfer.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.EventData.DataPointer">
            <summary>
            Address where the one argument lives (if this points to managed memory you must ensure the
            managed object is pinned.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.EventData.Size">
            <summary>
            Size of the argument referenced by DataPointer
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSource.EventData.Reserved">
            <summary>
            Reserved by ETW.  This property is present to ensure that we can zero it
            since System.Private.CoreLib uses are not zero'd.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.EventData.SetMetadata(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Initializes the members of this EventData object to point at a previously-pinned
            tracelogging-compatible metadata blob.
            </summary>
            <param name="pointer">Pinned tracelogging-compatible metadata blob.</param>
            <param name="size">The size of the metadata blob.</param>
            <param name="reserved">Value for reserved: 2 for per-provider metadata, 1 for per-event metadata</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteEventCore(System.Int32,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)">
            <summary>
            This routine allows you to create efficient WriteEvent helpers, however the code that you use to
            do this, while straightforward, is unsafe.
            </summary>
            <remarks>
            <code>
               protected unsafe void WriteEvent(int eventId, string arg1, long arg2)
               {
                   if (IsEnabled())
                   {
                       if (arg2 == null) arg2 = "";
                       fixed (char* string2Bytes = arg2)
                       {
                           EventSource.EventData* descrs = stackalloc EventSource.EventData[2];
                           descrs[0].DataPointer = (IntPtr)(&amp;arg1);
                           descrs[0].Size = 8;
                           descrs[0].Reserved = 0;
                           descrs[1].DataPointer = (IntPtr)string2Bytes;
                           descrs[1].Size = ((arg2.Length + 1) * 2);
                           descrs[1].Reserved = 0;
                           WriteEventCore(eventId, 2, descrs);
                       }
                   }
               }
            </code>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore(System.Int32,System.Guid*,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)">
            <summary>
            This routine allows you to create efficient WriteEventWithRelatedActivityId helpers, however the code 
            that you use to do this, while straightforward, is unsafe. The only difference from
            <see cref="M:System.Diagnostics.Tracing.EventSource.WriteEventCore(System.Int32,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)"/> is that you pass the relatedActivityId from caller through to this API
            </summary>
            <remarks>
            <code>
               protected unsafe void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, string arg1, long arg2)
               {
                   if (IsEnabled())
                   {
                       if (arg2 == null) arg2 = "";
                       fixed (char* string2Bytes = arg2)
                       {
                           EventSource.EventData* descrs = stackalloc EventSource.EventData[2];
                           descrs[0].DataPointer = (IntPtr)(&amp;arg1);
                           descrs[0].Size = 8;
                           descrs[1].DataPointer = (IntPtr)string2Bytes;
                           descrs[1].Size = ((arg2.Length + 1) * 2);
                           WriteEventWithRelatedActivityIdCore(eventId, relatedActivityId, 2, descrs);
                       }
                   }
               }
            </code>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteEvent(System.Int32,System.Object[])">
            <summary>
            This is the varargs helper for writing an event. It does create an array and box all the arguments so it is
            relatively inefficient and should only be used for relatively rare events (e.g. less than 100 / sec). If your
            rates are faster than that you should use <see cref="M:System.Diagnostics.Tracing.EventSource.WriteEventCore(System.Int32,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)"/> to create fast helpers for your particular 
            method signature. Even if you use this for rare events, this call should be guarded by an <see cref="M:System.Diagnostics.Tracing.EventSource.IsEnabled"/> 
            check so that the varargs call is not made when the EventSource is not active.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityId(System.Int32,System.Guid,System.Object[])">
            <summary>
            This is the varargs helper for writing an event which also specifies a related activity. It is completely analogous
            to corresponding WriteEvent (they share implementation). It does create an array and box all the arguments so it is
            relatively inefficient and should only be used for relatively rare events (e.g. less than 100 / sec).  If your
            rates are faster than that you should use <see cref="M:System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore(System.Int32,System.Guid*,System.Int32,System.Diagnostics.Tracing.EventSource.EventData*)"/> to create fast helpers for your 
            particular method signature. Even if you use this for rare events, this call should be guarded by an <see cref="M:System.Diagnostics.Tracing.EventSource.IsEnabled"/>
            check so that the varargs call is not made when the EventSource is not active.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Dispose">
            <summary>
            Disposes of an EventSource.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Dispose(System.Boolean)">
            <summary>
            Disposes of an EventSource.
            </summary>
            <remarks>
            Called from Dispose() with disposing=true, and from the finalizer (~EventSource) with disposing=false.
            Guidelines:
            1. We may be called more than once: do nothing after the first call.
            2. Avoid throwing exceptions if disposing is false, i.e. if we're being finalized.
            </remarks>
            <param name="disposing">True if called from Dispose(), false if called from the finalizer.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Finalize">
            <summary>
            Finalizer for EventSource
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Initialize(System.Guid,System.String,System.String[])">
            <summary>
            This method is responsible for the common initialization path from our constructors. It must
            not leak any exceptions (otherwise, since most EventSource classes define a static member, 
            "Log", such an exception would become a cached exception for the initialization of the static
            member, and any future access to the "Log" would throw the cached exception).
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSource.Sha1ForNonSecretPurposes">
            <summary>
            Implements the SHA1 hashing algorithm. Note that this
            implementation is for hashing public information. Do not
            use this code to hash private data, as this implementation does
            not take any steps to avoid information disclosure.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Sha1ForNonSecretPurposes.Start">
            <summary>
            Call Start() to initialize the hash object.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Sha1ForNonSecretPurposes.Append(System.Byte)">
            <summary>
            Adds an input byte to the hash.
            </summary>
            <param name="input">Data to include in the hash.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Sha1ForNonSecretPurposes.Append(System.Byte[])">
            <summary>
            Adds input bytes to the hash.
            </summary>
            <param name="input">
            Data to include in the hash. Must not be null.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Sha1ForNonSecretPurposes.Finish(System.Byte[])">
            <summary>
            Retrieves the hash value.
            Note that after calling this function, the hash object should
            be considered uninitialized. Subsequent calls to Append or
            Finish will produce useless results. Call Start() to
            reinitialize.
            </summary>
            <param name="output">
            Buffer to receive the hash value. Must not be null.
            Up to 20 bytes of hash will be written to the output buffer.
            If the buffer is smaller than 20 bytes, the remaining hash
            bytes will be lost. If the buffer is larger than 20 bytes, the
            rest of the buffer is left unmodified.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Sha1ForNonSecretPurposes.Drain">
            <summary>
            Called when this.pos reaches 64.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.LogEventArgsMismatches(System.Reflection.ParameterInfo[],System.Object[])">
            <summary>
            We expect that the arguments to the Event method and the arguments to WriteEvent match. This function 
            checks that they in fact match and logs a warning to the debugger if they don't.
            </summary>
            <param name="infos"></param>
            <param name="args"></param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteStringToAllListeners(System.String,System.String)">
            <summary>
            Since this is a means of reporting errors (see ReportoutOfBandMessage) any failure encountered 
            while writing the message to any one of the listeners will be silently ignored.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.IsEnabledByDefault(System.Int32,System.Boolean,System.Diagnostics.Tracing.EventLevel,System.Diagnostics.Tracing.EventKeywords)">
            <summary>
            Returns true if 'eventNum' is enabled if you only consider the level and matchAnyKeyword filters.
            It is possible that eventSources turn off the event based on additional filtering criteria.  
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSource.OverideEventProvider">
            <summary>
            This class lets us hook the 'OnEventCommand' from the eventSource.  
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSource.EventMetadata">
            <summary>
            Used to hold all the static information about an event.  This includes everything in the event
            descriptor as well as some stuff we added specifically for EventSource. see the
            code:m_eventData for where we use this.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.DoCommand(System.Diagnostics.Tracing.EventCommandEventArgs)">
            <summary>
            We want the eventSource to be fully initialized when we do commands because that way we can send 
            error messages and other logging directly to the event stream.   Unfortunately we can get callbacks
            when we are not fully initialized.  In that case we store them in 'commandArgs' and do them later. 
            This helper actually does all actual command logic. 
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.EnableEventForDispatcher(System.Diagnostics.Tracing.EventDispatcher,System.Diagnostics.Tracing.EventProviderType,System.Int32,System.Boolean)">
            <summary>
            If 'value is 'true' then set the eventSource so that 'dispatcher' will receive event with the eventId
            of 'eventId.  If value is 'false' disable the event for that dispatcher.   If 'eventId' is out of
            range return false, otherwise true.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.AnyEventEnabled">
            <summary>
            Returns true if any event at all is on.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.AttributeTypeNamesMatch(System.Type,System.Type)">
            <summary>
            Evaluates if two related "EventSource"-domain types should be considered the same
            </summary>
            <param name="attributeType">The attribute type in the load context - it's associated with the running 
            EventSource type. This type may be different fromt he base type of the user-defined EventSource.</param>
            <param name="reflectedAttributeType">The attribute type in the reflection context - it's associated with
            the user-defined EventSource, and is in the same assembly as the eventSourceType passed to 
            </param>
            <returns>True - if the types should be considered equivalent, False - otherwise</returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.GetHelperCallFirstArg(System.Reflection.MethodInfo)">
            <summary>
            This method looks at the IL and tries to pattern match against the standard
            'boilerplate' event body 
            <code>
                { if (Enabled()) WriteEvent(#, ...) } 
            </code>
            If the pattern matches, it returns the literal number passed as the first parameter to
            the WriteEvent.  This is used to find common user errors (mismatching this
            number with the EventAttribute ID).  It is only used for validation.   
            </summary>
            <param name="method">The method to probe.</param>
            <returns>The literal value or -1 if the value could not be determined. </returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.ReportOutOfBandMessage(System.String,System.Boolean)">
            <summary>
            Sends an error message to the debugger (outputDebugString), as well as the EventListeners 
            It will do this even if the EventSource is not enabled.  
            TODO remove flush parameter it is not used.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.#ctor(System.String)">
            <summary>
            Construct an EventSource with a given name for non-contract based events (e.g. those using the Write() API).
            </summary>
            <param name="eventSourceName">
            The name of the event source. Must not be null.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.#ctor(System.String,System.Diagnostics.Tracing.EventSourceSettings)">
            <summary>
            Construct an EventSource with a given name for non-contract based events (e.g. those using the Write() API).
            </summary>
            <param name="eventSourceName">
            The name of the event source. Must not be null.
            </param>
            <param name="config">
            Configuration options for the EventSource as a whole. 
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.#ctor(System.String,System.Diagnostics.Tracing.EventSourceSettings,System.String[])">
            <summary>
            Construct an EventSource with a given name for non-contract based events (e.g. those using the Write() API).
            
            Also specify a list of key-value pairs called traits (you must pass an even number of strings).   
            The first string is the key and the second is the value.   These are not interpreted by EventSource
            itself but may be interpreted the listeners.  Can be fetched with GetTrait(string).   
            </summary>
            <param name="eventSourceName">
            The name of the event source. Must not be null.
            </param>
            <param name="config">
            Configuration options for the EventSource as a whole. 
            </param>
            <param name="traits">A collection of key-value strings (must be an even number).</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Write(System.String)">
            <summary>
            Writes an event with no fields and default options.
            (Native API: EventWriteTransfer)
            </summary>
            <param name="eventName">The name of the event.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Write(System.String,System.Diagnostics.Tracing.EventSourceOptions)">
            <summary>
            Writes an event with no fields.
            (Native API: EventWriteTransfer)
            </summary>
            <param name="eventName">The name of the event.</param>
            <param name="options">
            Options for the event, such as the level, keywords, and opcode. Unset
            options will be set to default values.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,``0)">
            <summary>
            Writes an event.
            (Native API: EventWriteTransfer)
            </summary>
            <typeparam name="T">
            The type that defines the event and its payload. This must be an
            anonymous type or a type with an [EventData] attribute.
            </typeparam>
            <param name="eventName">
            The name for the event. If null, the event name is automatically
            determined based on T, either from the Name property of T's EventData
            attribute or from typeof(T).Name.
            </param>
            <param name="data">
            The object containing the event payload data. The type T must be
            an anonymous type or a type with an [EventData] attribute. The
            public instance properties of data will be written recursively to
            create the fields of the event.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,System.Diagnostics.Tracing.EventSourceOptions,``0)">
            <summary>
            Writes an event.
            (Native API: EventWriteTransfer)
            </summary>
            <typeparam name="T">
            The type that defines the event and its payload. This must be an
            anonymous type or a type with an [EventData] attribute.
            </typeparam>
            <param name="eventName">
            The name for the event. If null, the event name is automatically
            determined based on T, either from the Name property of T's EventData
            attribute or from typeof(T).Name.
            </param>
            <param name="options">
            Options for the event, such as the level, keywords, and opcode. Unset
            options will be set to default values.
            </param>
            <param name="data">
            The object containing the event payload data. The type T must be
            an anonymous type or a type with an [EventData] attribute. The
            public instance properties of data will be written recursively to
            create the fields of the event.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,System.Diagnostics.Tracing.EventSourceOptions@,``0@)">
            <summary>
            Writes an event.
            This overload is for use with extension methods that wish to efficiently
            forward the options or data parameter without performing an extra copy.
            (Native API: EventWriteTransfer)
            </summary>
            <typeparam name="T">
            The type that defines the event and its payload. This must be an
            anonymous type or a type with an [EventData] attribute.
            </typeparam>
            <param name="eventName">
            The name for the event. If null, the event name is automatically
            determined based on T, either from the Name property of T's EventData
            attribute or from typeof(T).Name.
            </param>
            <param name="options">
            Options for the event, such as the level, keywords, and opcode. Unset
            options will be set to default values.
            </param>
            <param name="data">
            The object containing the event payload data. The type T must be
            an anonymous type or a type with an [EventData] attribute. The
            public instance properties of data will be written recursively to
            create the fields of the event.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.Write``1(System.String,System.Diagnostics.Tracing.EventSourceOptions@,System.Guid@,System.Guid@,``0@)">
            <summary>
            Writes an event.
            This overload is meant for clients that need to manipuate the activityId
            and related ActivityId for the event.  
            </summary>
            <typeparam name="T">
            The type that defines the event and its payload. This must be an
            anonymous type or a type with an [EventData] attribute.
            </typeparam>
            <param name="eventName">
            The name for the event. If null, the event name is automatically
            determined based on T, either from the Name property of T's EventData
            attribute or from typeof(T).Name.
            </param>
            <param name="options">
            Options for the event, such as the level, keywords, and opcode. Unset
            options will be set to default values.
            </param>
            <param name="activityId">
            The GUID of the activity associated with this event.
            </param>
            <param name="relatedActivityId">
            The GUID of another activity that is related to this activity, or Guid.Empty
            if there is no related activity. Most commonly, the Start operation of a
            new activity specifies a parent activity as its related activity.
            </param>
            <param name="data">
            The object containing the event payload data. The type T must be
            an anonymous type or a type with an [EventData] attribute. The
            public instance properties of data will be written recursively to
            create the fields of the event.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteMultiMerge(System.String,System.Diagnostics.Tracing.EventSourceOptions@,System.Diagnostics.Tracing.TraceLoggingEventTypes,System.Guid*,System.Guid*,System.Object[])">
            <summary>
            Writes an extended event, where the values of the event are the
            combined properties of any number of values. This method is
            intended for use in advanced logging scenarios that support a
            dynamic set of event context providers.
            This method does a quick check on whether this event is enabled.
            </summary>
            <param name="eventName">
            The name for the event. If null, the name from eventTypes is used.
            (Note that providing the event name via the name parameter is slightly
            less efficient than using the name from eventTypes.)
            </param>
            <param name="options">
            Optional overrides for the event, such as the level, keyword, opcode,
            activityId, and relatedActivityId. Any settings not specified by options
            are obtained from eventTypes.
            </param>
            <param name="eventTypes">
            Information about the event and the types of the values in the event.
            Must not be null. Note that the eventTypes object should be created once and
            saved. It should not be recreated for each event.
            </param>
            <param name="activityID">
            A pointer to the activity ID GUID to log 
            </param>
            <param name="childActivityID">
            A pointer to the child activity ID to log (can be null) </param>
            <param name="values">
            The values to include in the event. Must not be null. The number and types of
            the values must match the number and types of the fields described by the
            eventTypes parameter.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteMultiMergeInner(System.String,System.Diagnostics.Tracing.EventSourceOptions@,System.Diagnostics.Tracing.TraceLoggingEventTypes,System.Guid*,System.Guid*,System.Object[])">
            <summary>
            Writes an extended event, where the values of the event are the
            combined properties of any number of values. This method is
            intended for use in advanced logging scenarios that support a
            dynamic set of event context providers.
            Attention: This API does not check whether the event is enabled or not. 
            Please use WriteMultiMerge to avoid spending CPU cycles for events that are 
            not enabled.
            </summary>
            <param name="eventName">
            The name for the event. If null, the name from eventTypes is used.
            (Note that providing the event name via the name parameter is slightly
            less efficient than using the name from eventTypes.)
            </param>
            <param name="options">
            Optional overrides for the event, such as the level, keyword, opcode,
            activityId, and relatedActivityId. Any settings not specified by options
            are obtained from eventTypes.
            </param>
            <param name="eventTypes">
            Information about the event and the types of the values in the event.
            Must not be null. Note that the eventTypes object should be created once and
            saved. It should not be recreated for each event.
            </param>
            <param name="activityID">
            A pointer to the activity ID GUID to log 
            </param>
            <param name="childActivityID">
            A pointer to the child activity ID to log (can be null)
            </param>
            <param name="values">
            The values to include in the event. Must not be null. The number and types of
            the values must match the number and types of the fields described by the
            eventTypes parameter.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.WriteMultiMerge(System.String,System.Diagnostics.Tracing.EventSourceOptions@,System.Diagnostics.Tracing.TraceLoggingEventTypes,System.Guid*,System.Guid*,System.Diagnostics.Tracing.EventSource.EventData*)">
            <summary>
            Writes an extended event, where the values of the event have already
            been serialized in "data".
            </summary>
            <param name="eventName">
            The name for the event. If null, the name from eventTypes is used.
            (Note that providing the event name via the name parameter is slightly
            less efficient than using the name from eventTypes.)
            </param>
            <param name="options">
            Optional overrides for the event, such as the level, keyword, opcode,
            activityId, and relatedActivityId. Any settings not specified by options
            are obtained from eventTypes.
            </param>
            <param name="eventTypes">
            Information about the event and the types of the values in the event.
            Must not be null. Note that the eventTypes object should be created once and
            saved. It should not be recreated for each event.
            </param>
            <param name="activityID">
            A pointer to the activity ID GUID to log 
            </param>
            <param name="childActivityID">
            A pointer to the child activity ID to log (can be null)
            </param> 
            <param name="data">
            The previously serialized values to include in the event. Must not be null.
            The number and types of the values must match the number and types of the 
            fields described by the eventTypes parameter.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSource.HexDigit(System.Char)">
            <summary>
            Returns a value 0-15 if 'c' is a hexadecimal digit.   If  it throws an argument exception.  
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSourceSettings">
            <summary>
            Enables specifying event source configuration options to be used in the EventSource constructor.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventSourceSettings.Default">
            <summary>
            This specifies none of the special configuration options should be enabled.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventSourceSettings.ThrowOnEventWriteErrors">
            <summary>
            Normally an EventSource NEVER throws; setting this option will tell it to throw when it encounters errors.  
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventSourceSettings.EtwManifestEventFormat">
            <summary>
            Setting this option is a directive to the ETW listener should use manifest-based format when
            firing events. This is the default option when defining a type derived from EventSource 
            (using the protected EventSource constructors).
            Only one of EtwManifestEventFormat or EtwSelfDescribingEventFormat should be specified
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventSourceSettings.EtwSelfDescribingEventFormat">
            <summary>
            Setting this option is a directive to the ETW listener should use self-describing event format
            when firing events. This is the default option when creating a new instance of the EventSource
            type (using the public EventSource constructors).  
            Only one of EtwManifestEventFormat or EtwSelfDescribingEventFormat should be specified
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventListener">
            <summary>
            An EventListener represents a target for the events generated by EventSources (that is subclasses
            of <see cref="T:System.Diagnostics.Tracing.EventSource"/>), in the current appdomain. When a new EventListener is created
            it is logically attached to all eventSources in that appdomain. When the EventListener is Disposed, then
            it is disconnected from the event eventSources. Note that there is a internal list of STRONG references
            to EventListeners, which means that relying on the lack of references to EventListeners to clean up
            EventListeners will NOT work. You must call EventListener.Dispose explicitly when a dispatcher is no
            longer needed.
            <para>
            Once created, EventListeners can enable or disable on a per-eventSource basis using verbosity levels
            (<see cref="T:System.Diagnostics.Tracing.EventLevel"/>) and bitfields (<see cref="T:System.Diagnostics.Tracing.EventKeywords"/>) to further restrict the set of 
            events to be sent to the dispatcher. The dispatcher can also send arbitrary commands to a particular 
            eventSource using the 'SendCommand' method. The meaning of the commands are eventSource specific.
            </para><para>
            The Null Guid (that is (new Guid()) has special meaning as a wildcard for 'all current eventSources in
            the appdomain'. Thus it is relatively easy to turn on all events in the appdomain if desired.
            </para><para>
            It is possible for there to be many EventListener's defined in a single appdomain. Each dispatcher is
            logically independent of the other listeners. Thus when one dispatcher enables or disables events, it
            affects only that dispatcher (other listeners get the events they asked for). It is possible that
            commands sent with 'SendCommand' would do a semantic operation that would affect the other listeners
            (like doing a GC, or flushing data ...), but this is the exception rather than the rule.
            </para><para>
            Thus the model is that each EventSource keeps a list of EventListeners that it is sending events
            to. Associated with each EventSource-dispatcher pair is a set of filtering criteria that determine for
            that eventSource what events that dispatcher will receive.
            </para><para>
            Listeners receive the events on their 'OnEventWritten' method. Thus subclasses of EventListener must
            override this method to do something useful with the data.
            </para><para>
            In addition, when new eventSources are created, the 'OnEventSourceCreate' method is called. The
            invariant associated with this callback is that every eventSource gets exactly one
            'OnEventSourceCreate' call for ever eventSource that can potentially send it log messages. In
            particular when a EventListener is created, typically a series of OnEventSourceCreate' calls are
            made to notify the new dispatcher of all the eventSources that existed before the EventListener was
            created.
            </para>
            </summary>
        </member>
        <member name="E:System.Diagnostics.Tracing.EventListener.EventSourceCreated">
            <summary>
            This event is raised whenever a new eventSource is 'attached' to the dispatcher.
            This can happen for all existing EventSources when the EventListener is created
            as well as for any EventSources that come into existence after the EventListener
            has been created.
            
            These 'catch up' events are called during the construction of the EventListener.
            Subclasses need to be prepared for that.
            
            In a multi-threaded environment, it is possible that 'EventSourceEventWrittenCallback' 
            events for a particular eventSource to occur BEFORE the EventSourceCreatedCallback is issued.
            </summary>
        </member>
        <member name="E:System.Diagnostics.Tracing.EventListener.EventWritten">
            <summary>
            This event is raised whenever an event has been written by a EventSource for which 
            the EventListener has enabled events.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.#ctor">
            <summary>
            Create a new EventListener in which all events start off turned off (use EnableEvents to turn
            them on).  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.Dispose">
            <summary>
            Dispose should be called when the EventListener no longer desires 'OnEvent*' callbacks. Because
            there is an internal list of strong references to all EventListeners, calling 'Dispose' directly
            is the only way to actually make the listen die. Thus it is important that users of EventListener
            call Dispose when they are done with their logging.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.EnableEvents(System.Diagnostics.Tracing.EventSource,System.Diagnostics.Tracing.EventLevel)">
             <summary>
             Enable all events from the eventSource identified by 'eventSource' to the current 
             dispatcher that have a verbosity level of 'level' or lower.
               
             This call can have the effect of REDUCING the number of events sent to the 
             dispatcher if 'level' indicates a less verbose level than was previously enabled.
             
             This call never has an effect on other EventListeners.
            
             </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.EnableEvents(System.Diagnostics.Tracing.EventSource,System.Diagnostics.Tracing.EventLevel,System.Diagnostics.Tracing.EventKeywords)">
            <summary>
            Enable all events from the eventSource identified by 'eventSource' to the current
            dispatcher that have a verbosity level of 'level' or lower and have a event keyword
            matching any of the bits in 'matchAnyKeyword'.
            
            This call can have the effect of REDUCING the number of events sent to the 
            dispatcher if 'level' indicates a less verbose level than was previously enabled or
            if 'matchAnyKeyword' has fewer keywords set than where previously set.
            
            This call never has an effect on other EventListeners.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.EnableEvents(System.Diagnostics.Tracing.EventSource,System.Diagnostics.Tracing.EventLevel,System.Diagnostics.Tracing.EventKeywords,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Enable all events from the eventSource identified by 'eventSource' to the current
            dispatcher that have a verbosity level of 'level' or lower and have a event keyword
            matching any of the bits in 'matchAnyKeyword' as well as any (eventSource specific)
            effect passing additional 'key-value' arguments 'arguments' might have.  
            
            This call can have the effect of REDUCING the number of events sent to the 
            dispatcher if 'level' indicates a less verbose level than was previously enabled or
            if 'matchAnyKeyword' has fewer keywords set than where previously set.
            
            This call never has an effect on other EventListeners.
            </summary>       
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.DisableEvents(System.Diagnostics.Tracing.EventSource)">
            <summary>
            Disables all events coming from eventSource identified by 'eventSource'.  
            
            This call never has an effect on other EventListeners.      
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.EventSourceIndex(System.Diagnostics.Tracing.EventSource)">
            <summary>
            EventSourceIndex is small non-negative integer (suitable for indexing in an array)
            identifying EventSource. It is unique per-appdomain. Some EventListeners might find
            it useful to store additional information about each eventSource connected to it,
            and EventSourceIndex allows this extra information to be efficiently stored in a
            (growable) array (eg List(T)).
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated(System.Diagnostics.Tracing.EventSource)">
            <summary>
            This method is called whenever a new eventSource is 'attached' to the dispatcher.
            This can happen for all existing EventSources when the EventListener is created
            as well as for any EventSources that come into existence after the EventListener
            has been created.
            
            These 'catch up' events are called during the construction of the EventListener.
            Subclasses need to be prepared for that.
            
            In a multi-threaded environment, it is possible that 'OnEventWritten' callbacks
            for a particular eventSource to occur BEFORE the OnEventSourceCreated is issued.
            </summary>
            <param name="eventSource"></param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.OnEventWritten(System.Diagnostics.Tracing.EventWrittenEventArgs)">
            <summary>
            This method is called whenever an event has been written by a EventSource for which 
            the EventListener has enabled events.  
            </summary>
            <param name="eventData"></param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.AddEventSource(System.Diagnostics.Tracing.EventSource)">
            <summary>
            This routine adds newEventSource to the global list of eventSources, it also assigns the
            ID to the eventSource (which is simply the ordinal in the global list).
            
            EventSources currently do not pro-actively remove themselves from this list. Instead
            when eventSources's are GCed, the weak handle in this list naturally gets nulled, and
            we will reuse the slot. Today this list never shrinks (but we do reuse entries
            that are in the list). This seems OK since the expectation is that EventSources
            tend to live for the lifetime of the appdomain anyway (they tend to be used in
            global variables).
            </summary>
            <param name="newEventSource"></param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.RemoveReferencesToListenerInEventSources(System.Diagnostics.Tracing.EventListener)">
            <summary>
            Helper used in code:Dispose that removes any references to 'listenerToRemove' in any of the
            eventSources in the appdomain.  
            
            The EventListenersLock must be held before calling this routine. 
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventListener.Validate">
            <summary>
            Checks internal consistency of EventSources/Listeners. 
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventListener.EventListenersLock">
            <summary>
            Gets a global lock that is intended to protect the code:s_Listeners linked list and the
            code:s_EventSources WeakReference list.  (We happen to use the s_EventSources list as
            the lock object)
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventListener.s_Listeners">
            <summary>
            The list of all listeners in the appdomain.  Listeners must be explicitly disposed to remove themselves 
            from this list.   Note that EventSources point to their listener but NOT the reverse.  
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventListener.s_EventSources">
            <summary>
            The list of all active eventSources in the appdomain.  Note that eventSources do NOT 
            remove themselves from this list this is a weak list and the GC that removes them may
            not have happened yet.  Thus it can contain event sources that are dead (thus you have 
            to filter those out.  
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventListener.s_CreatingListener">
            <summary>
            Used to disallow reentrancy.  
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventListener.s_EventSourceShutdownRegistered">
            <summary>
            Used to register AD/Process shutdown callbacks.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventCommandEventArgs">
            <summary>
            Passed to the code:EventSource.OnEventCommand callback
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventCommandEventArgs.Command">
            <summary>
            Gets the command for the callback.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventCommandEventArgs.Arguments">
            <summary>
            Gets the arguments for the callback.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventCommandEventArgs.EnableEvent(System.Int32)">
            <summary>
            Enables the event that has the specified identifier.
            </summary>
            <param name="eventId">Event ID of event to be enabled</param>
            <returns>true if eventId is in range</returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventCommandEventArgs.DisableEvent(System.Int32)">
            <summary>
            Disables the event that have the specified identifier.
            </summary>
            <param name="eventId">Event ID of event to be disabled</param>
            <returns>true if eventId is in range</returns>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSourceCreatedEventArgs">
            <summary>
            EventSourceCreatedEventArgs is passed to <see cref="E:System.Diagnostics.Tracing.EventListener.EventSourceCreated"/>
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceCreatedEventArgs.EventSource">
            <summary>
            The EventSource that is attaching to the listener.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventWrittenEventArgs">
            <summary>
            EventWrittenEventArgs is passed to the user-provided override for
            <see cref="M:System.Diagnostics.Tracing.EventListener.OnEventWritten(System.Diagnostics.Tracing.EventWrittenEventArgs)"/> when an event is fired.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.EventName">
            <summary>
            The name of the event.   
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.EventId">
            <summary>
            Gets the event ID for the event that was written.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.ActivityId">
            <summary>
            Gets the activity ID for the thread on which the event was written.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.RelatedActivityId">
            <summary>
            Gets the related activity ID if one was specified when the event was written.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Payload">
            <summary>
            Gets the payload for the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.PayloadNames">
            <summary>
            Gets the payload argument names.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.EventSource">
            <summary>
            Gets the event source object.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Keywords">
            <summary>
            Gets the keywords for the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Opcode">
            <summary>
            Gets the operation code for the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Task">
            <summary>
            Gets the task for the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Tags">
            <summary>
            Any provider/user defined options associated with the event.  
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Message">
            <summary>
            Gets the message for the event.  If the message has {N} parameters they are NOT substituted.  
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Channel">
            <summary>
            Gets the channel for the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Version">
            <summary>
            Gets the version of the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.Level">
            <summary>
            Gets the level for the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.OSThreadId">
            <summary>
            Gets the identifier for the OS thread that wrote the event.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventWrittenEventArgs.TimeStamp">
            <summary>
            Gets a UTC DateTime that specifies when the event was written.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSourceAttribute">
            <summary>
            Allows customizing defaults and specifying localization support for the event source class to which it is applied. 
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceAttribute.Name">
            <summary>
            Overrides the ETW name of the event source (which defaults to the class name)
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceAttribute.Guid">
            <summary>
            Overrides the default (calculated) Guid of an EventSource type. Explicitly defining a GUID is discouraged, 
            except when upgrading existing ETW providers to using event sources.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceAttribute.LocalizationResources">
            <summary>
            <para>
            EventSources support localization of events. The names used for events, opcodes, tasks, keywords and maps 
            can be localized to several languages if desired. This works by creating a ResX style string table 
            (by simply adding a 'Resource File' to your project). This resource file is given a name e.g. 
            'DefaultNameSpace.ResourceFileName' which can be passed to the ResourceManager constructor to read the 
            resources. This name is the value of the LocalizationResources property. 
            </para><para>
            If LocalizationResources property is non-null, then EventSource will look up the localized strings for events by 
            using the following resource naming scheme
            </para>
                <para>* event_EVENTNAME</para>
                <para>* task_TASKNAME</para>
                <para>* keyword_KEYWORDNAME</para>
                <para>* map_MAPNAME</para>
            <para>
            where the capitalized name is the name of the event, task, keyword, or map value that should be localized.   
            Note that the localized string for an event corresponds to the Message string, and can have {0} values 
            which represent the payload values.  
            </para>
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventAttribute">
            <summary>
            Any instance methods in a class that subclasses <see cref="T:System.Diagnostics.Tracing.EventSource"/> and that return void are
            assumed by default to be methods that generate an ETW event. Enough information can be deduced from the
            name of the method and its signature to generate basic schema information for the event. The
            <see cref="T:System.Diagnostics.Tracing.EventAttribute"/> class allows you to specify additional event schema information for an event if
            desired.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventAttribute.#ctor(System.Int32)">
            <summary>Construct an EventAttribute with specified eventId</summary>
            <param name="eventId">ID of the ETW event (an integer between 1 and 65535)</param>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.EventId">
            <summary>Event's ID</summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Level">
            <summary>Event's severity level: indicates the severity or verbosity of the event</summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Keywords">
            <summary>Event's keywords: allows classification of events by "categories"</summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Opcode">
            <summary>Event's operation code: allows defining operations, generally used with Tasks</summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Task">
            <summary>Event's task: allows logical grouping of events</summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Channel">
            <summary>Event's channel: defines an event log as an additional destination for the event</summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Version">
            <summary>Event's version</summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Message">
            <summary>
            This can be specified to enable formatting and localization of the event's payload. You can 
            use standard .NET substitution operators (eg {1}) in the string and they will be replaced 
            with the 'ToString()' of the corresponding part of the  event payload.   
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.Tags">
            <summary>
            User defined options associated with the event.  These do not have meaning to the EventSource but
            are passed through to listeners which given them semantics.  
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventAttribute.ActivityOptions">
            <summary>
            Allows fine control over the Activity IDs generated by start and stop events
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.NonEventAttribute">
            <summary>
            By default all instance methods in a class that subclasses code:EventSource that and return
            void are assumed to be methods that generate an event. This default can be overridden by specifying
            the code:NonEventAttribute
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.NonEventAttribute.#ctor">
            <summary>
            Constructs a default NonEventAttribute
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventChannelAttribute">
            <summary>
            EventChannelAttribute allows customizing channels supported by an EventSource. This attribute must be
            applied to an member of type EventChannel defined in a Channels class nested in the EventSource class:
            <code>
                public static class Channels
                {
                    [Channel(Enabled = true, EventChannelType = EventChannelType.Admin)]
                    public const EventChannel Admin = (EventChannel)16;
                
                    [Channel(Enabled = false, EventChannelType = EventChannelType.Operational)]
                    public const EventChannel Operational = (EventChannel)17;
                }
            </code>
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventChannelAttribute.Enabled">
            <summary>
            Specified whether the channel is enabled by default
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventChannelAttribute.EventChannelType">
            <summary>
            Legal values are in EventChannelType
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventChannelType">
            <summary>
            Allowed channel types
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannelType.Admin">
            <summary>The admin channel</summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannelType.Operational">
            <summary>The operational channel</summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannelType.Analytic">
            <summary>The Analytic channel</summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannelType.Debug">
            <summary>The debug channel</summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventCommand">
            <summary>
            Describes the pre-defined command (EventCommandEventArgs.Command property) that is passed to the OnEventCommand callback.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventCommand.Update">
            <summary>
            Update EventSource state
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventCommand.SendManifest">
            <summary>
            Request EventSource to generate and send its manifest
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventCommand.Enable">
            <summary>
            Enable event
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventCommand.Disable">
            <summary>
            Disable event
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.SessionMask">
            <summary>
            A SessionMask represents a set of (at most MAX) sessions as a bit mask. The perEventSourceSessionId
            is the index in the SessionMask of the bit that will be set. These can translate to
            EventSource's reserved keywords bits using the provided ToEventKeywords() and
            FromEventKeywords() methods.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventDispatcher">
            <summary>
            code:EventDispatchers are a simple 'helper' structure that holds the filtering state
            (m_EventEnabled) for a particular EventSource X EventListener tuple
            
            Thus a single EventListener may have many EventDispatchers (one for every EventSource 
            that EventListener has activate) and a Single EventSource may also have many
            event Dispatchers (one for every EventListener that has activated it). 
            
            Logically a particular EventDispatcher belongs to exactly one EventSource and exactly  
            one EventListener (although EventDispatcher does not 'remember' the EventSource it is
            associated with. 
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventManifestOptions">
            <summary>
            Flags that can be used with EventSource.GenerateManifest to control how the ETW manifest for the EventSource is
            generated.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventManifestOptions.None">
            <summary>
            Only the resources associated with current UI culture are included in the  manifest
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventManifestOptions.Strict">
            <summary>
            Throw exceptions for any inconsistency encountered
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventManifestOptions.AllCultures">
            <summary>
            Generate a "resources" node under "localization" for every satellite assembly provided
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventManifestOptions.OnlyIfNeededForRegistration">
            <summary>
            Generate the manifest only if the event source needs to be registered on the machine,
            otherwise return null (but still perform validation if Strict is specified)
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventManifestOptions.AllowEventSourceOverride">
            <summary>
            When generating the manifest do *not* enforce the rule that the current EventSource class
            must be the base class for the user-defined type passed in. This allows validation of .net
            event sources using the new validation code
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ManifestBuilder">
            <summary>
            ManifestBuilder is designed to isolate the details of the message of the event from the
            rest of EventSource.  This one happens to create XML. 
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ManifestBuilder.#ctor(System.String,System.Guid,System.String,System.Resources.ResourceManager,System.Diagnostics.Tracing.EventManifestOptions)">
            <summary>
            Build a manifest for 'providerName' with the given GUID, which will be packaged into 'dllName'.
            'resources, is a resource manager.  If specified all messages are localized using that manager.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ManifestBuilder.AddChannel(System.String,System.Int32,System.Diagnostics.Tracing.EventChannelAttribute)">
            <summary>
            Add a channel.  channelAttribute can be null
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.ManifestBuilder.ManifestError(System.String,System.Boolean)">
            <summary>
            When validating an event source it adds the error to the error collection.
            When not validating it throws an exception if runtimeCritical is "true".
            Otherwise the error is ignored.
            </summary>
            <param name="msg"></param>
            <param name="runtimeCritical"></param>
        </member>
        <member name="M:System.Diagnostics.Tracing.ManifestBuilder.GetSupportedCultures(System.Resources.ResourceManager)">
            <summary>
            There's no API to enumerate all languages an assembly is localized into, so instead
            we enumerate through all the "known" cultures and attempt to load a corresponding satellite 
            assembly
            </summary>
            <param name="resources"></param>
            <returns></returns>
        </member>
        <member name="T:System.Diagnostics.Tracing.ManifestEnvelope">
            <summary>
            Used to send the m_rawManifest into the event dispatcher as a series of events.  
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSourceException">
            <summary>
            Exception that is thrown when an error occurs during EventSource operation.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceException.#ctor">
            <summary>
            Initializes a new instance of the EventSourceException class.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the EventSourceException class with a specified error message.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the EventSourceException class with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the EventSourceException class with serialized data.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.FrameworkEventSource.Tasks">
            <summary>ETW tasks that have start/stop events.</summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.FrameworkEventSource.Tasks.ThreadTransfer">
            <summary>Send / Receive - begin transfer/end transfer</summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.IncrementingEventCounter">
            <summary>
            IncrementingEventCounter is a variant of EventCounter for variables that are ever-increasing. 
            Ex) # of exceptions in the runtime.
            It does not calculate statistics like mean, standard deviation, etc. because it only accumulates
            the counter value.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.IncrementingEventCounter.#ctor(System.String,System.Diagnostics.Tracing.EventSource)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.Tracing.IncrementingEventCounter"/> class.
            IncrementingEventCounter live as long as the EventSource that they are attached to unless they are
            explicitly Disposed.   
            </summary>
            <param name="name">The name.</param>
            <param name="eventSource">The event source.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.IncrementingEventCounter.Increment(System.Double)">
            <summary>
            Writes 'value' to the stream of values tracked by the counter.  This updates the sum and other statistics that will 
            be logged on the next timer interval.  
            </summary>
            <param name="increment">The value to increment by.</param>
        </member>
        <member name="T:System.Diagnostics.Tracing.IncrementingEventCounterPayloadType">
            <summary>
            This is the payload that is sent in the with EventSource.Write
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.IncrementingPollingCounter">
            <summary>
            IncrementingPollingCounter is a variant of EventCounter for variables that are ever-increasing. 
            Ex) # of exceptions in the runtime.
            It does not calculate statistics like mean, standard deviation, etc. because it only accumulates
            the counter value.
            Unlike IncrementingEventCounter, this takes in a polling callback that it can call to update 
            its own metric periodically.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.IncrementingPollingCounter.#ctor(System.String,System.Diagnostics.Tracing.EventSource,System.Func{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.Tracing.IncrementingPollingCounter"/> class.
            IncrementingPollingCounter live as long as the EventSource that they are attached to unless they are
            explicitly Disposed.   
            </summary>
            <param name="name">The name.</param>
            <param name="eventSource">The event source.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.IncrementingPollingCounter.UpdateMetric">
            <summary>
            Calls "_totalValueProvider" to enqueue the counter value to the queue. 
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.IncrementingPollingCounterPayloadType">
            <summary>
            This is the payload that is sent in the with EventSource.Write
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.PollingCounter">
            <summary>
            PollingCounter is a variant of EventCounter - it collects and calculates similar statistics 
            as EventCounter. PollingCounter differs from EventCounter in that it takes in a callback
            function to collect metrics on its own rather than the user having to call WriteMetric() 
            every time.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.PollingCounter.#ctor(System.String,System.Diagnostics.Tracing.EventSource,System.Func{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.Tracing.PollingCounter"/> class.
            PollingCounter live as long as the EventSource that they are attached to unless they are
            explicitly Disposed.
            </summary>
            <param name="name">The name.</param>
            <param name="eventSource">The event source.</param>
        </member>
        <member name="T:System.Diagnostics.Tracing.PollingPayloadType">
            <summary>
            This is the payload that is sent in the with EventSource.Write
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventLevel">
            <summary>
            WindowsEventLevel. Custom values must be in the range from 16 through 255
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventLevel.LogAlways">
            <summary>
            Log always
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventLevel.Critical">
            <summary>
            Only critical errors
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventLevel.Error">
            <summary>
            All errors, including previous levels
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventLevel.Warning">
            <summary>
            All warnings, including previous levels
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventLevel.Informational">
            <summary>
            All informational events, including previous levels
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventLevel.Verbose">
            <summary>
            All events, including previous levels 
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventTask">
            <summary>
            WindowsEventTask. Custom values must be in the range from 1 through 65534
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventTask.None">
            <summary>
            Undefined task
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventOpcode">
            <summary>
            EventOpcode. Custom values must be in the range from 11 through 239
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Info">
            <summary>
            An informational event
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Start">
            <summary>
            An activity start event
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Stop">
            <summary>
            An activity end event 
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.DataCollectionStart">
            <summary>
            A trace collection start event
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.DataCollectionStop">
            <summary>
            A trace collection end event
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Extension">
            <summary>
            An extensional event
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Reply">
            <summary>
            A reply event
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Resume">
            <summary>
            An event representing the activity resuming from the suspension
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Suspend">
            <summary>
            An event representing the activity is suspended, pending another activity's completion
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Send">
            <summary>
            An event representing the activity is transferred to another component, and can continue to work
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventOpcode.Receive">
            <summary>
            An event representing receiving an activity transfer from another component 
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventChannel">
            <summary>
            EventChannel. Custom values must be in the range from 16 through 255. Currently only predefined values allowed.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannel.None">
            <summary>
            No channel
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannel.Admin">
            <summary>The admin channel</summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannel.Operational">
            <summary>The operational channel</summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannel.Analytic">
            <summary>The analytic channel</summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventChannel.Debug">
            <summary>The debug channel</summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventKeywords">
            <summary>
            EventOpcode
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.None">
            <summary>
            No events. 
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.All">
            <summary>
            All Events 
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.MicrosoftTelemetry">
            <summary>
            Telemetry events
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.WdiContext">
            <summary>
            WDI context events
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.WdiDiagnostic">
            <summary>
            WDI diagnostic events
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.Sqm">
            <summary>
            SQM events
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.AuditFailure">
            <summary>
            Failed security audits
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.AuditSuccess">
            <summary>
            Successful security audits
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.CorrelationHint">
            <summary>
            Transfer events where the related Activity ID is a computed value and not a GUID
            N.B. The correct value for this field is 0x40000000000000.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventKeywords.EventLogClassic">
            <summary>
            Events raised using classic eventlog API
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ConcurrentSet`2">
            <summary>
            TraceLogging: A very simple lock-free add-only dictionary.
            Warning: this is a copy-by-value type. Copying performs a snapshot.
            Accessing a readonly field always makes a copy of the field, so the
            GetOrAdd method will not work as expected if called on a readonly field.
            </summary>
            <typeparam name="KeyType">
            The type of the key, used for TryGet.
            </typeparam>
            <typeparam name="ItemType">
            The type of the item, used for GetOrAdd.
            </typeparam>
        </member>
        <member name="T:System.Diagnostics.Tracing.ConcurrentSetItem`2">
            <summary>
            TraceLogging: Abstract base class that must be inherited by items in a
            ConcurrentSet.
            </summary>
            <typeparam name="KeyType">Type of the set's key.</typeparam>
            <typeparam name="ItemType">Type of the derived class.</typeparam>
        </member>
        <member name="T:System.Diagnostics.Tracing.DataCollector">
            <summary>
            TraceLogging: This is the implementation of the DataCollector
            functionality. To enable safe access to the DataCollector from
            untrusted code, there is one thread-local instance of this structure
            per thread. The instance must be Enabled before any data is written to
            it. The instance must be Finished before the data is passed to
            EventWrite. The instance must be Disabled before the arrays referenced
            by the pointers are freed or unpinned.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.DataCollector.Finish">
            <summary>
            Completes the list of scalars. Finish must be called before the data
            descriptor array is passed to EventWrite.
            </summary>
            <returns>
            A pointer to the next unused data descriptor, or datasEnd if they were
            all used. (Descriptors may be unused if a string or array was null.)
            </returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.DataCollector.BeginBufferedArray">
            <summary>
            Marks the start of a non-blittable array or enumerable.
            </summary>
            <returns>Bookmark to be passed to EndBufferedArray.</returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.DataCollector.EndBufferedArray(System.Int32,System.Int32)">
            <summary>
            Marks the end of a non-blittable array or enumerable.
            </summary>
            <param name="bookmark">The value returned by BeginBufferedArray.</param>
            <param name="count">The number of items in the array.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.DataCollector.BeginBuffered">
            <summary>
            Marks the start of dynamically-buffered data.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.DataCollector.EndBuffered">
            <summary>
            Marks the end of dynamically-buffered data.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EmptyStruct">
            <summary>
            TraceLogging: Empty struct indicating no payload data.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventDataAttribute">
            <summary>
            Used when authoring types that will be passed to EventSource.Write.
            EventSource.Write&lt;T> only works when T is either an anonymous type
            or a type with an [EventData] attribute. In addition, the properties
            of T must be supported property types. Supported property types include
            simple built-in types (int, string, Guid, DateTime, DateTimeOffset,
            KeyValuePair, etc.), anonymous types that only contain supported types,
            types with an [EventData] attribute, arrays of the above, and IEnumerable
            of the above.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventDataAttribute.Name">
            <summary>
            Gets or sets the name to use if this type is used for an
            implicitly-named event or an implicitly-named property.
            
            Example 1:
            
                EventSource.Write(null, new T()); // implicitly-named event
                
            The name of the event will be determined as follows:
            
            if (T has an EventData attribute and attribute.Name != null)
                eventName = attribute.Name;
            else
                eventName = typeof(T).Name;
                
            Example 2:
            
                EventSource.Write(name, new { _1 = new T() }); // implicitly-named field
                
            The name of the field will be determined as follows:
            
            if (T has an EventData attribute and attribute.Name != null)
                fieldName = attribute.Name;
            else
                fieldName = typeof(T).Name;
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventDataAttribute.Level">
            <summary>
            Gets or sets the level to use for the event.
            Invalid levels (outside the range 0..255) are treated as unset.
            Note that the Level attribute can bubble-up, i.e. if a type contains
            a sub-object (a field or property), and the sub-object's type has a
            TraceLoggingEvent attribute, the Level from the sub-object's attribute
            can affect the event's level.
            
            Example: for EventSource.Write(name, options, data), the level of the
            event will be determined as follows:
            
            if (options.Level has been set)
                eventLevel = options.Level;
            else if (data.GetType() has a TraceLoggingEvent attribute and attribute.Level has been set)
                eventLevel = attribute.Level;
            else if (a field/property contained in data has a TraceLoggingEvent attribute and attribute.Level has been set)
                eventLevel = attribute.Level;
            else
                eventLevel = EventLevel.LogAlways;
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventDataAttribute.Opcode">
            <summary>
            Gets or sets the opcode to use for the event.
            Invalid opcodes (outside the range 0..255) are treated as unset.
            Note that the Opcode attribute can bubble-up, i.e. if a type contains
            a sub-object (a field or property), and the sub-object's type has a
            TraceLoggingEvent attribute, the Opcode from the sub-object's attribute
            can affect the event's opcode.
            
            Example: for EventSource.Write(name, options, data), the opcode of the
            event will be determined as follows:
            
            if (options.Opcode has been set)
                eventOpcode = options.Opcode;
            else if (data.GetType() has a TraceLoggingEvent attribute and attribute.Opcode has been set)
                eventOpcode = attribute.Opcode;
            else if (a field/property contained in data has a TraceLoggingEvent attribute and attribute.Opcode has been set)
                eventOpcode = attribute.Opcode;
            else
                eventOpcode = EventOpcode.Info;
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventDataAttribute.Keywords">
            <summary>
            Gets or sets the keywords to use for the event.
            Note that the Keywords attribute can bubble-up, i.e. if a type contains
            a sub-object (a field or property), and the sub-object's type has a
            TraceLoggingEvent attribute, the Keywords from the sub-object's attribute
            can affect the event's keywords.
            
            Example: for EventSource.Write(name, options, data), the keywords of the
            event will be determined as follows:
            
            eventKeywords = options.Keywords;
            if (data.GetType() has a TraceLoggingEvent attribute)
                eventKeywords |= attribute.Keywords;
            if (a field/property contained in data has a TraceLoggingEvent attribute)
                eventKeywords |= attribute.Keywords;
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventDataAttribute.Tags">
            <summary>
            Gets or sets the flags for an event. These flags are ignored by ETW,
            but can have meaning to the event consumer.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventFieldTags">
            <summary>
            Tags are flags that are not interpreted by EventSource but are passed along
            to the EventListener. The EventListener determines the semantics of the flags.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldTags.None">
            <summary>
            No special traits are added to the field.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventFieldAttribute">
            <summary>
            TraceLogging: used when authoring types that will be passed to EventSource.Write.
            Controls how a field or property is handled when it is written as a
            field in a TraceLogging event. Apply this attribute to a field or
            property if the default handling is not correct. (Apply the
            TraceLoggingIgnore attribute if the property should not be
            included as a field in the event.)
            The default for Name is null, which means that the name of the
            underlying field or property will be used as the event field's name.
            The default for PiiTag is 0, which means that the event field does not
            contain personally-identifiable information.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventFieldAttribute.Tags">
            <summary>
            User defined options for the field. These are not interpreted by the EventSource
            but are available to the Listener. See EventFieldSettings for details
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventFieldAttribute.Name">
            <summary>
            Gets or sets the name to use for the field. This defaults to null.
            If null, the name of the corresponding property will be used
            as the event field's name.
            TODO REMOVE
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventFieldAttribute.Format">
            <summary>
            Gets or sets a field formatting hint.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventFieldFormat">
            <summary>
            Provides a hint that may be used by an event listener when formatting
            an event field for display. Note that the event listener may ignore the
            hint if it does not recognize a particular combination of type and format.
            Similar to TDH_OUTTYPE.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldFormat.Default">
            <summary>
            Field receives default formatting based on the field's underlying type.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldFormat.String">
            <summary>
            Field should be formatted as character or string data.
            Typically applied to 8-bit or 16-bit integers.
            This is the default format for String and Char types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldFormat.Boolean">
            <summary>
            Field should be formatted as boolean data. Typically applied to 8-bit
            or 32-bit integers. This is the default format for the Boolean type.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldFormat.Hexadecimal">
            <summary>
            Field should be formatted as hexadecimal data. Typically applied to
            integer types.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldFormat.Xml">
            <summary>
            Field should be formatted as XML string data. Typically applied to
            strings or arrays of 8-bit or 16-bit integers.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldFormat.Json">
            <summary>
            Field should be formatted as JSON string data. Typically applied to
            strings or arrays of 8-bit or 16-bit integers.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventFieldFormat.HResult">
            <summary>
            Field should be formatted as an HRESULT code. Typically applied to
            32-bit integer types.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventIgnoreAttribute">
            <summary>
            Used when authoring types that will be passed to EventSource.Write.
            By default, EventSource.Write will write all of an object's public
            properties to the event payload. Apply [EventIgnore] to a public
            property to prevent EventSource.Write from including the property in
            the event.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventPayload">
            <summary>
            EventPayload class holds the list of parameters and their corresponding values for user defined types passed to 
            EventSource APIs.
            Preserving the order of the elements as they were found inside user defined types is the most important characteristic of this class.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSourceActivity">
            <summary>
            Provides support for EventSource activities by marking the start and
            end of a particular operation.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.#ctor(System.Diagnostics.Tracing.EventSource)">
            <summary>
            Initializes a new instance of the EventSourceActivity class that
            is attached to the specified event source. The new activity will
            not be attached to any related (parent) activity.
            The activity is created in the Initialized state.
            </summary>
            <param name="eventSource">
            The event source to which the activity information is written.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.op_Implicit(System.Diagnostics.Tracing.EventSource)~System.Diagnostics.Tracing.EventSourceActivity">
            <summary>
            You can make an activity out of just an EventSource.  
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceActivity.EventSource">
            <summary>
            Gets the event source to which this activity writes events.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceActivity.Id">
            <summary>
            Gets this activity's unique identifier, or the default Guid if the
            event source was disabled when the activity was initialized.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Start``1(System.String,System.Diagnostics.Tracing.EventSourceOptions,``0)">
            <summary>
            Writes a Start event with the specified name and data.   If the start event is not active (because the provider 
            is not on or keyword-level indicates the event is off, then the returned activity is simply the 'this' pointer
            and it is effectively like start did not get called.
            
            A new activityID GUID is generated and the returned
            EventSourceActivity remembers this activity and will mark every event (including the start stop and any writes)
            with this activityID.   In addition the Start activity will log a 'relatedActivityID' that was the activity
            ID before the start event.   This way event processors can form a linked list of all the activities that
            caused this one (directly or indirectly).  
            </summary>
            <param name="eventName">
            The name to use for the event.   It is strongly suggested that this name end in 'Start' (e.g. DownloadStart).  
            If you do this, then the Stop() method will automatically replace the 'Start' suffix with a 'Stop' suffix.  
            </param>
            <param name="options">Allow options (keywords, level) to be set for the write associated with this start 
            These will also be used for the stop event.</param>
            <param name="data">The data to include in the event.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Start(System.String)">
            <summary>
            Shortcut version see Start(string eventName, EventSourceOptions options, T data) Options is empty (no keywords 
            and level==Info) Data payload is empty.  
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Start(System.String,System.Diagnostics.Tracing.EventSourceOptions)">
            <summary>
            Shortcut version see Start(string eventName, EventSourceOptions options, T data).  Data payload is empty. 
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Start``1(System.String,``0)">
            <summary>
            Shortcut version see Start(string eventName, EventSourceOptions options, T data) Options is empty (no keywords 
            and level==Info) 
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Stop``1(``0)">
            <summary>
            Writes a Stop event with the specified data, and sets the activity
            to the Stopped state.  The name is determined by the eventName used in Start.
            If that Start event name is suffixed with 'Start' that is removed, and regardless
            'Stop' is appended to the result to form the Stop event name.  
            May only be called when the activity is in the Started state.
            </summary>
            <param name="data">The data to include in the event.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Stop``1(System.String)">
            <summary>
            Used if you wish to use the non-default stop name (which is the start name with Start replace with 'Stop')
            This can be useful to indicate unusual ways of stopping (but it is still STRONGLY recommended that
            you start with the same prefix used for the start event and you end with the 'Stop' suffix.   
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Stop``1(System.String,``0)">
            <summary>
            Used if you wish to use the non-default stop name (which is the start name with Start replace with 'Stop')
            This can be useful to indicate unusual ways of stopping (but it is still STRONGLY recommended that
            you start with the same prefix used for the start event and you end with the 'Stop' suffix.   
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Write``1(System.String,System.Diagnostics.Tracing.EventSourceOptions,``0)">
            <summary>
            Writes an event associated with this activity to the eventSource associated with this activity.  
            May only be called when the activity is in the Started state.
            </summary>
            <param name="eventName">
            The name to use for the event. If null, the name is determined from
            data's type.
            </param>
            <param name="options">
            The options to use for the event.
            </param>
            <param name="data">The data to include in the event.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Write``1(System.String,``0)">
            <summary>
            Writes an event associated with this activity.
            May only be called when the activity is in the Started state.
            </summary>
            <param name="eventName">
            The name to use for the event. If null, the name is determined from
            data's type.
            </param>
            <param name="data">The data to include in the event.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Write(System.String,System.Diagnostics.Tracing.EventSourceOptions)">
            <summary>
            Writes a trivial event associated with this activity.
            May only be called when the activity is in the Started state.
            </summary>
            <param name="eventName">
            The name to use for the event. Must not be null.
            </param>
            <param name="options">
            The options to use for the event.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Write(System.String)">
            <summary>
            Writes a trivial event associated with this activity.
            May only be called when the activity is in the Started state.
            </summary>
            <param name="eventName">
            The name to use for the event. Must not be null.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Write``1(System.Diagnostics.Tracing.EventSource,System.String,System.Diagnostics.Tracing.EventSourceOptions,``0)">
            <summary>
            Writes an event to a arbitrary eventSource stamped with the activity ID of this activity.   
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.EventSourceActivity.Dispose">
            <summary>
            Releases any unmanaged resources associated with this object.
            If the activity is in the Started state, calls Stop().
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceActivity.StartEventWasFired">
            <summary>
            If eventName is non-null then we logged a start event 
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventSourceOptions">
            <summary>
            Used when calling EventSource.Write.
            Optional overrides for event settings such as Level, Keywords, or Opcode.
            If overrides are not provided for a setting, default values will be used.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceOptions.Level">
            <summary>
            Gets or sets the level to use for the specified event. If this property
            is unset, the event's level will be 5 (Verbose).
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceOptions.Opcode">
            <summary>
            Gets or sets the opcode to use for the specified event. If this property
            is unset, the event's opcode will 0 (Info).
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceOptions.Keywords">
            <summary>
            Gets or sets the keywords to use for the specified event. If this
            property is unset, the event's keywords will be 0.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceOptions.Tags">
            <summary>
            Gets or sets the tags to use for the specified event. If this property is
            unset, the event's tags will be 0.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.EventSourceOptions.ActivityOptions">
            <summary>
            Gets or sets the activity options for this specified events. If this property is
            unset, the event's activity options will be 0.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.FieldMetadata">
            <summary>
            TraceLogging: Contains the information needed to generate tracelogging
            metadata for an event field.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.FieldMetadata.name">
            <summary>
            Name of the field
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.FieldMetadata.nameSize">
            <summary>
            The number of bytes in the UTF8 Encoding of 'name' INCLUDING a null terminator.  
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.FieldMetadata.fixedCount">
            <summary>
            ETW supports fixed sized arrays. If inType has the InTypeFixedCountFlag then this is the
            statically known count for the array. It is also used to encode the number of bytes of
            custom meta-data if InTypeCustomCountFlag set.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.FieldMetadata.#ctor(System.String,System.Diagnostics.Tracing.TraceLoggingDataType,System.Diagnostics.Tracing.EventFieldTags,System.Boolean)">
            <summary>
            Scalar or variable-length array.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.FieldMetadata.#ctor(System.String,System.Diagnostics.Tracing.TraceLoggingDataType,System.Diagnostics.Tracing.EventFieldTags,System.UInt16)">
            <summary>
            Fixed-length array.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.FieldMetadata.#ctor(System.String,System.Diagnostics.Tracing.TraceLoggingDataType,System.Diagnostics.Tracing.EventFieldTags,System.Byte[])">
            <summary>
            Custom serializer
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.FieldMetadata.Encode(System.Int32@,System.Byte[])">
            <summary>
            This is the main routine for FieldMetaData.  Basically it will serialize the data in
            this structure as TraceLogging style meta-data into the array 'metaArray' starting at
            'pos' (pos is updated to reflect the bytes written).  
            
            Note that 'metaData' can be null, in which case it only updates 'pos'.  This is useful
            for a 'two pass' approach where you figure out how big to make the array, and then you
            fill it in.   
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.InvokeTypeInfo">
            <summary>
            TraceLogging: An implementation of TraceLoggingTypeInfo that works
            for arbitrary types. It writes all public instance properties of
            the type.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.NameInfo">
            <summary>
            TraceLogging: Stores the metadata and event identifier corresponding
            to a tracelogging event type+name+tags combination.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.NameInfo.ReserveEventIDsBelow(System.Int32)">
            <summary>
            Insure that eventIds strictly less than 'eventId' will not be
            used by the SelfDescribing events.   
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.PropertyAnalysis">
            <summary>
            TraceLogging: stores the per-property information obtained by
            reflecting over a type.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.PropertyValue">
            <summary>
            Holds property values of any type.  For common value types, we have inline storage so that we don't need
            to box the values.  For all other types, we store the value in a single object reference field.
            
            To get the value of a property quickly, use a delegate produced by <see cref="M:System.Diagnostics.Tracing.PropertyValue.GetPropertyGetter(System.Reflection.PropertyInfo)"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.PropertyValue.Scalar">
            <summary>
            Union of well-known value types, to avoid boxing those types.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.PropertyValue.GetPropertyGetter(System.Reflection.PropertyInfo)">
            <summary>
            Gets a delegate that gets the value of a given property.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.PropertyValue.GetBoxedValueTypePropertyGetter(System.Reflection.PropertyInfo)">
            <summary>
            Gets a delegate that gets the value of a property of a value type.  We unfortunately cannot avoid boxing the value type,
            without making this generic over the value type.  That would result in a large number of generic instantiations, and furthermore
            does not work correctly on .NET Native (we cannot express the needed instantiations in an rd.xml file).  We expect that user-defined
            value types will be rare, and in any case the boxing only happens for events that are actually enabled.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.PropertyValue.GetReferenceTypePropertyGetter(System.Reflection.PropertyInfo)">
            <summary>
            For properties of reference types, we use a generic helper class to get the value.  This enables us to use MethodInfo.CreateDelegate
            to build a fast getter.  We can get away with this on .NET Native, because we really only need one runtime instantiation of the
            generic type, since it's only instantiated over reference types (and thus all instances are shared).
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="T:System.Diagnostics.Tracing.SimpleEventTypes`1">
            <summary>
            TraceLogging: Contains the metadata needed to emit an event, optimized
            for events with one top-level compile-time-typed payload object.
            </summary>
            <typeparam name="T">
            Type of the top-level payload object. Should be EmptyStruct if the
            event has no payload.
            </typeparam>
        </member>
        <member name="T:System.Diagnostics.Tracing.NullTypeInfo">
            <summary>
            TraceLogging: Type handler for empty or unsupported types.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ScalarTypeInfo">
            <summary>
            Type handler for simple scalar types.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ScalarArrayTypeInfo">
            <summary>
            Type handler for arrays of scalars
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.StringTypeInfo">
            <summary>
            TraceLogging: Type handler for String.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.DateTimeTypeInfo">
            <summary>
            TraceLogging: Type handler for DateTime.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.DateTimeOffsetTypeInfo">
            <summary>
            TraceLogging: Type handler for DateTimeOffset.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.TimeSpanTypeInfo">
            <summary>
            TraceLogging: Type handler for TimeSpan.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.DecimalTypeInfo">
            <summary>
            TraceLogging: Type handler for decimal. (Note: not full-fidelity, exposed as Double.)
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.NullableTypeInfo">
            <summary>
            TraceLogging: Type handler for Nullable.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.Statics">
            <summary>
            TraceLogging: Constants and utility functions.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.Statics.MetadataForString(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            A complete metadata chunk can be expressed as:
            length16 + prefix + null-terminated-utf8-name + suffix + additionalData.
            We assume that excludedData will be provided by some other means,
            but that its size is known. This function returns a blob containing
            length16 + prefix + name + suffix, with prefix and suffix initialized
            to 0's. The length16 value is initialized to the length of the returned
            blob plus additionalSize, so that the concatenation of the returned blob
            plus a blob of size additionalSize constitutes a valid metadata blob.
            </summary>
            <param name="name">
            The name to include in the blob.
            </param>
            <param name="prefixSize">
            Amount of space to reserve before name. For provider or field blobs, this
            should be 0. For event blobs, this is used for the tags field and will vary
            from 1 to 4, depending on how large the tags field needs to be.
            </param>
            <param name="suffixSize">
            Amount of space to reserve after name. For example, a provider blob with no
            traits would reserve 0 extra bytes, but a provider blob with a single GroupId
            field would reserve 19 extra bytes.
            </param>
            <param name="additionalSize">
            Amount of additional data in another blob. This value will be counted in the
            blob's length field, but will not be included in the returned byte[] object.
            The complete blob would then be the concatenation of the returned byte[] object
            with another byte[] object of length additionalSize.
            </param>
            <returns>
            A byte[] object with the length and name fields set, with room reserved for
            prefix and suffix. If additionalSize was 0, the byte[] object is a complete
            blob. Otherwise, another byte[] of size additionalSize must be concatenated
            with this one to form a complete blob.
            </returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.Statics.EncodeTags(System.Int32,System.Int32@,System.Byte[])">
            <summary>
            Serialize the low 28 bits of the tags value into the metadata stream,
            starting at the index given by pos. Updates pos. Writes 1 to 4 bytes,
            depending on the value of the tags variable. Usable for event tags and
            field tags.
            
            Note that 'metadata' can be null, in which case it only updates 'pos'.
            This is useful for a two pass approach where you figure out how big to
            make the array, and then you fill it in.   
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.Statics.Format8(System.Diagnostics.Tracing.EventFieldFormat,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adjusts the native type based on format.
            - If format is default, return native.
            - If format is recognized, return the canonical type for that format.
            - Otherwise remove existing format from native and apply the requested format.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.Statics.Format16(System.Diagnostics.Tracing.EventFieldFormat,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adjusts the native type based on format.
            - If format is default, return native.
            - If format is recognized, return the canonical type for that format.
            - Otherwise remove existing format from native and apply the requested format.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.Statics.Format32(System.Diagnostics.Tracing.EventFieldFormat,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adjusts the native type based on format.
            - If format is default, return native.
            - If format is recognized, return the canonical type for that format.
            - Otherwise remove existing format from native and apply the requested format.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.Statics.Format64(System.Diagnostics.Tracing.EventFieldFormat,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adjusts the native type based on format.
            - If format is default, return native.
            - If format is recognized, return the canonical type for that format.
            - Otherwise remove existing format from native and apply the requested format.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.Statics.FormatPtr(System.Diagnostics.Tracing.EventFieldFormat,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adjusts the native type based on format.
            - If format is default, return native.
            - If format is recognized, return the canonical type for that format.
            - Otherwise remove existing format from native and apply the requested format.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.TraceLoggingDataCollector">
            <summary>
            TraceLogging: Used when implementing a custom TraceLoggingTypeInfo.
            The instance of this type is provided to the TypeInfo.WriteData method.
            All operations are forwarded to the current thread's DataCollector.
            Note that this abstraction would allow us to expose the custom
            serialization system to partially-trusted code. If we end up not
            making custom serialization public, or if we only expose it to
            full-trust code, this abstraction is unnecessary (though it probably
            doesn't hurt anything).
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.BeginBufferedArray">
            <summary>
            Marks the start of a non-blittable array or enumerable.
            </summary>
            <returns>Bookmark to be passed to EndBufferedArray.</returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.EndBufferedArray(System.Int32,System.Int32)">
            <summary>
            Marks the end of a non-blittable array or enumerable.
            </summary>
            <param name="bookmark">The value returned by BeginBufferedArray.</param>
            <param name="count">The number of items in the array.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.AddGroup">
            <summary>
            Adds the start of a group to the event.
            This has no effect on the event payload, but is provided to allow
            WriteMetadata and WriteData implementations to have similar
            sequences of calls, allowing for easier verification of correctness.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.AddScalar(System.Int64)">
            <summary>
            Adds an Int64 value to the event payload.
            </summary>
            <param name="value">Value to be added.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.AddScalar(System.Double)">
            <summary>
            Adds a Double value to the event payload.
            </summary>
            <param name="value">Value to be added.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.AddScalar(System.Boolean)">
            <summary>
            Adds a Boolean value to the event payload.
            </summary>
            <param name="value">Value to be added.</param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.AddNullTerminatedString(System.String)">
            <summary>
            Adds a null-terminated String value to the event payload.
            </summary>
            <param name="value">
            Value to be added. A null value is treated as a zero-length string.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingDataCollector.AddBinary(System.String)">
            <summary>
            Adds a counted String value to the event payload.
            </summary>
            <param name="value">
            Value to be added. A null value is treated as a zero-length string.
            </param>
        </member>
        <member name="T:System.Diagnostics.Tracing.TraceLoggingDataType">
            <summary>
            TraceLogging: Used when implementing a custom TraceLoggingTypeInfo.
            These are passed to metadataCollector.Add to specify the low-level
            type of a field in the event payload. Note that a "formatted"
            TraceLoggingDataType consists of a core TraceLoggingDataType value
            (a TraceLoggingDataType with a value less than 32) plus an OutType.
            Any combination of TraceLoggingDataType + OutType is valid, but not
            all are useful. In particular, combinations not explicitly listed
            below are unlikely to be recognized by decoders, and will typically
            be decoded as the corresponding core type (i.e. the decoder will
            mask off any unrecognized OutType value).
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Nil">
            <summary>
            Core type.
            Data type with no value (0-length payload).
            NOTE: arrays of Nil are illegal.
            NOTE: a fixed-length array of Nil is interpreted by the decoder as
            a struct (obsolete but retained for backwards-compatibility).
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Utf16String">
            <summary>
            Core type.
            Encoding assumes null-terminated Char16 string.
            Decoding treats as UTF-16LE string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.MbcsString">
            <summary>
            Core type.
            Encoding assumes null-terminated Char8 string.
            Decoding treats as MBCS string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Int8">
            <summary>
            Core type.
            Encoding assumes 8-bit value.
            Decoding treats as signed integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.UInt8">
            <summary>
            Core type.
            Encoding assumes 8-bit value.
            Decoding treats as unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Int16">
            <summary>
            Core type.
            Encoding assumes 16-bit value.
            Decoding treats as signed integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.UInt16">
            <summary>
            Core type.
            Encoding assumes 16-bit value.
            Decoding treats as unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Int32">
            <summary>
            Core type.
            Encoding assumes 32-bit value.
            Decoding treats as signed integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.UInt32">
            <summary>
            Core type.
            Encoding assumes 32-bit value.
            Decoding treats as unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Int64">
            <summary>
            Core type.
            Encoding assumes 64-bit value.
            Decoding treats as signed integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.UInt64">
            <summary>
            Core type.
            Encoding assumes 64-bit value.
            Decoding treats as unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Float">
            <summary>
            Core type.
            Encoding assumes 32-bit value.
            Decoding treats as Float.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Double">
            <summary>
            Core type.
            Encoding assumes 64-bit value.
            Decoding treats as Double.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Boolean32">
            <summary>
            Core type.
            Encoding assumes 32-bit value.
            Decoding treats as Boolean.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Binary">
            <summary>
            Core type.
            Encoding assumes 16-bit bytecount followed by binary data.
            Decoding treats as binary data.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Guid">
            <summary>
            Core type.
            Encoding assumes 16-byte value.
            Decoding treats as GUID.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.FileTime">
            <summary>
            Core type.
            Encoding assumes 64-bit value.
            Decoding treats as FILETIME.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.SystemTime">
            <summary>
            Core type.
            Encoding assumes 16-byte value.
            Decoding treats as SYSTEMTIME.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.HexInt32">
            <summary>
            Core type.
            Encoding assumes 32-bit value.
            Decoding treats as hexadecimal unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.HexInt64">
            <summary>
            Core type.
            Encoding assumes 64-bit value.
            Decoding treats as hexadecimal unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.CountedUtf16String">
            <summary>
            Core type.
            Encoding assumes 16-bit bytecount followed by Char16 data.
            Decoding treats as UTF-16LE string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.CountedMbcsString">
            <summary>
            Core type.
            Encoding assumes 16-bit bytecount followed by Char8 data.
            Decoding treats as MBCS string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Struct">
            <summary>
            Core type.
            Special case: Struct indicates that this field plus the
            subsequent N logical fields are to be considered as one logical
            field (i.e. a nested structure). The OutType is used to encode N.
            The maximum value for N is 127. This field has no payload by
            itself, but logically contains the payload of the following N
            fields. It is legal to have an array of Struct.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Char16">
            <summary>
            Formatted type.
            Encoding assumes 16-bit value.
            Decoding treats as UTF-16LE character.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Char8">
            <summary>
            Formatted type.
            Encoding assumes 8-bit value.
            Decoding treats as character.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Boolean8">
            <summary>
            Formatted type.
            Encoding assumes 8-bit value.
            Decoding treats as Boolean.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.HexInt8">
            <summary>
            Formatted type.
            Encoding assumes 8-bit value.
            Decoding treats as hexadecimal unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.HexInt16">
            <summary>
            Formatted type.
            Encoding assumes 16-bit value.
            Decoding treats as hexadecimal unsigned integer.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Utf16Xml">
            <summary>
            Formatted type.
            Encoding assumes null-terminated Char16 string.
            Decoding treats as UTF-16LE XML string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.MbcsXml">
            <summary>
            Formatted type.
            Encoding assumes null-terminated Char8 string.
            Decoding treats as MBCS XML string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.CountedUtf16Xml">
            <summary>
            Formatted type.
            Encoding assumes 16-bit bytecount followed by Char16 data.
            Decoding treats as UTF-16LE XML.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.CountedMbcsXml">
            <summary>
            Formatted type.
            Encoding assumes 16-bit bytecount followed by Char8 data.
            Decoding treats as MBCS XML.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.Utf16Json">
            <summary>
            Formatted type.
            Encoding assumes null-terminated Char16 string.
            Decoding treats as UTF-16LE JSON string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.MbcsJson">
            <summary>
            Formatted type.
            Encoding assumes null-terminated Char8 string.
            Decoding treats as MBCS JSON string.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.CountedUtf16Json">
            <summary>
            Formatted type.
            Encoding assumes 16-bit bytecount followed by Char16 data.
            Decoding treats as UTF-16LE JSON.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.CountedMbcsJson">
            <summary>
            Formatted type.
            Encoding assumes 16-bit bytecount followed by Char8 data.
            Decoding treats as MBCS JSON.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.TraceLoggingDataType.HResult">
            <summary>
            Formatted type.
            Encoding assumes 32-bit value.
            Decoding treats as HRESULT.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.EventTags">
            <summary>
            Tags are flags that are not interpreted by EventSource but are passed along
            to the EventListener. The EventListener determines the semantics of the flags.
            </summary>
        </member>
        <member name="F:System.Diagnostics.Tracing.EventTags.None">
            <summary>
            No special traits are added to the event.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.TraceLoggingEventTypes">
            <summary>
            TraceLogging: Used when calling EventSource.WriteMultiMerge.
            Stores the type information to use when writing the event fields.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingEventTypes.#ctor(System.String,System.Diagnostics.Tracing.EventTags,System.Type[])">
            <summary>
            Initializes a new instance of TraceLoggingEventTypes corresponding
            to the name, flags, and types provided. Always uses the default
            TypeInfo for each Type.
            </summary>
            <param name="name">
            The name to use when the name parameter passed to
            EventSource.Write is null. This value must not be null.
            </param>
            <param name="tags">
            Tags to add to the event if the tags are not set via options.
            </param>
            <param name="types">
            The types of the fields in the event. This value must not be null.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingEventTypes.#ctor(System.String,System.Diagnostics.Tracing.EventTags,System.Diagnostics.Tracing.TraceLoggingTypeInfo[])">
            <summary>
            Returns a new instance of TraceLoggingEventInfo corresponding to the name,
            flags, and typeInfos provided.
            </summary>
            <param name="name">
            The name to use when the name parameter passed to
            EventSource.Write is null. This value must not be null.
            </param>
            <param name="tags">
            Tags to add to the event if the tags are not set via options.
            </param>
            <param name="typeInfos">
            The types of the fields in the event. This value must not be null.
            </param>
            <returns>
            An instance of TraceLoggingEventInfo with DefaultName set to the specified name
            and with the specified typeInfos.
            </returns>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingEventTypes.Name">
            <summary>
            Gets the default name that will be used for events with this descriptor.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingEventTypes.Level">
            <summary>
            Gets the default level that will be used for events with this descriptor.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingEventTypes.Opcode">
            <summary>
            Gets the default opcode that will be used for events with this descriptor.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingEventTypes.Keywords">
            <summary>
            Gets the default set of keywords that will added to events with this descriptor.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingEventTypes.Tags">
            <summary>
            Gets the default tags that will be added events with this descriptor.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.TraceLoggingMetadataCollector">
            <summary>
            TraceLogging: used when implementing a custom TraceLoggingTypeInfo.
            An instance of this type is provided to the TypeInfo.WriteMetadata method.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.#ctor">
            <summary>
            Creates a root-level collector.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.#ctor(System.Diagnostics.Tracing.TraceLoggingMetadataCollector,System.Diagnostics.Tracing.FieldMetadata)">
            <summary>
            Creates a collector for a group.
            </summary>
            <param name="other">Parent collector</param>
            <param name="group">The field that starts the group</param>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.Tags">
            <summary>
            The field tags to be used for the next field.
            This will be reset to None each time a field is written.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.AddGroup(System.String)">
            <summary>
            Call this method to add a group to the event and to return
            a new metadata collector that can be used to add fields to the
            group. After all of the fields in the group have been written,
            switch back to the original metadata collector to add fields
            outside of the group.
            Special-case: if name is null, no group is created, and AddGroup
            returns the original metadata collector. This is useful when
            adding the top-level group for an event.
            Note: do not use the original metadata collector while the group's
            metadata collector is in use, and do not use the group's metadata
            collector after switching back to the original.
            </summary>
            <param name="name">
            The name of the group. If name is null, the call to AddGroup is a
            no-op (collector.AddGroup(null) returns collector).
            </param>
            <returns>
            A new metadata collector that can be used to add fields to the group.
            </returns>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.AddScalar(System.String,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adds a scalar field to an event.
            </summary>
            <param name="name">
            The name to use for the added field. This value must not be null.
            </param>
            <param name="type">
            The type code for the added field. This must be a fixed-size type
            (e.g. string types are not supported).
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.AddBinary(System.String,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adds a binary-format field to an event.
            Compatible with core types: Binary, CountedUtf16String, CountedMbcsString.
            Compatible with dataCollector methods: AddBinary(string), AddArray(Any8bitType[]).
            </summary>
            <param name="name">
            The name to use for the added field. This value must not be null.
            </param>
            <param name="type">
            The type code for the added field. This must be a Binary or CountedString type.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.AddNullTerminatedString(System.String,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adds a null-terminated string field to an event.
            Compatible with core types: Utf16String, MbcsString.
            Compatible with dataCollector method: AddNullTerminatedString(string).
            </summary>
            <param name="name">
            The name to use for the added field. This value must not be null.
            </param>
            <param name="type">
            The type code for the added field. This must be a null-terminated string type.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.AddArray(System.String,System.Diagnostics.Tracing.TraceLoggingDataType)">
            <summary>
            Adds an array field to an event.
            </summary>
            <param name="name">
            The name to use for the added field. This value must not be null.
            </param>
            <param name="type">
            The type code for the added field. This must be a fixed-size type.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingMetadataCollector.AddCustom(System.String,System.Diagnostics.Tracing.TraceLoggingDataType,System.Byte[])">
            <summary>
            Adds a custom-serialized field to an event.
            </summary>
            <param name="name">
            The name to use for the added field. This value must not be null.
            </param>
            <param name="type">The encoding type for the field.</param>
            <param name="metadata">Additional information needed to decode the field, if any.</param>
        </member>
        <member name="T:System.Diagnostics.Tracing.TraceLoggingTypeInfo">
            <summary>
            TraceLogging: used when implementing a custom TraceLoggingTypeInfo.
            Non-generic base class for TraceLoggingTypeInfo&lt;DataType>. Do not derive
            from this class. Instead, derive from TraceLoggingTypeInfo&lt;DataType>.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingTypeInfo.Name">
            <summary>
            Gets the name to use for the event if this type is the top-level type,
            or the name to use for an implicitly-named field.
            Never null.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingTypeInfo.Level">
            <summary>
            Gets the event level associated with this type. Any value in the range 0..255
            is an associated event level. Any value outside the range 0..255 is invalid and
            indicates that this type has no associated event level.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingTypeInfo.Opcode">
            <summary>
            Gets the event opcode associated with this type. Any value in the range 0..255
            is an associated event opcode. Any value outside the range 0..255 is invalid and
            indicates that this type has no associated event opcode.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingTypeInfo.Keywords">
            <summary>
            Gets the keyword(s) associated with this type.
            </summary>
        </member>
        <member name="P:System.Diagnostics.Tracing.TraceLoggingTypeInfo.Tags">
            <summary>
            Gets the event tags associated with this type.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingTypeInfo.WriteMetadata(System.Diagnostics.Tracing.TraceLoggingMetadataCollector,System.String,System.Diagnostics.Tracing.EventFieldFormat)">
            <summary>
            When overridden by a derived class, writes the metadata (schema) for
            this type. Note that the sequence of operations in WriteMetadata should be
            essentially identical to the sequence of operations in
            WriteData/WriteObjectData. Otherwise, the metadata and data will not match,
            which may cause trouble when decoding the event.
            </summary>
            <param name="collector">
            The object that collects metadata for this object's type. Metadata is written
            by calling methods on the collector object. Note that if the type contains
            sub-objects, the implementation of this method may need to call the
            WriteMetadata method for the type of the sub-object, e.g. by calling
            TraceLoggingTypeInfo&lt;SubType&gt;.Instance.WriteMetadata(...).
            </param>
            <param name="name">
            The name of the property that contains an object of this type, or null if this
            object is being written as a top-level object of an event. Typical usage
            is to pass this value to collector.AddGroup.
            </param>
            <param name="format">
            The format attribute for the field that contains an object of this type.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingTypeInfo.WriteData(System.Diagnostics.Tracing.TraceLoggingDataCollector,System.Diagnostics.Tracing.PropertyValue)">
            <summary>
            Refer to TraceLoggingTypeInfo.WriteObjectData for information about this
            method.
            </summary>
            <param name="collector">
            Refer to TraceLoggingTypeInfo.WriteObjectData for information about this
            method.
            </param>
            <param name="value">
            Refer to TraceLoggingTypeInfo.WriteObjectData for information about this
            method.
            </param>
        </member>
        <member name="M:System.Diagnostics.Tracing.TraceLoggingTypeInfo.GetData(System.Object)">
            <summary>
            Fetches the event parameter data for internal serialization. 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:System.Diagnostics.Tracing.TypeAnalysis">
            <summary>
            TraceLogging: stores the per-type information obtained by reflecting over a type.
            </summary>
        </member>
        <member name="T:System.Diagnostics.StackFrame">
            <summary>
            There is no good reason for the methods of this class to be virtual.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.#ctor(System.Diagnostics.StackFrameHelper,System.Int32,System.Boolean)">
            <summary>
            Called from the class "StackTrace"
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame._method">
            <summary>
            Reflection information for the method if available, null otherwise.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame._nativeOffset">
            <summary>
            Native offset of the current instruction within the current method if available,
            OFFSET_UNKNOWN otherwise.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame._ilOffset">
            <summary>
            IL offset of the current instruction within the current method if available,
            OFFSET_UNKNOWN otherwise.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame._fileName">
            <summary>
            Source file name representing the current code location if available, null otherwise.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame._lineNumber">
            <summary>
            Line number representing the current code location if available, 0 otherwise.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame._columnNumber">
            <summary>
            Column number representing the current code location if available, 0 otherwise.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame._isLastFrameFromForeignExceptionStackTrace">
            <summary>
            This flag is set to true when the frame represents a rethrow marker.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.#ctor">
            <summary>
            Constructs a StackFrame corresponding to the active stack frame.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.#ctor(System.Boolean)">
            <summary>
            Constructs a StackFrame corresponding to the active stack frame.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.#ctor(System.Int32)">
            <summary>
            Constructs a StackFrame corresponding to a calling stack frame.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a StackFrame corresponding to a calling stack frame.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a "fake" stack frame, just containing the given file
            name and line number.  Use when you don't want to use the
            debugger's line mapping logic.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a "fake" stack frame, just containing the given file
            name, line number and column number.  Use when you don't want to
            use the debugger's line mapping logic.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackFrame.OFFSET_UNKNOWN">
            <summary>
            Constant returned when the native or IL offset is unknown
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.GetMethod">
            <summary>
            Returns the method the frame is executing
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.GetNativeOffset">
            <summary>
            Returns the offset from the start of the native (jitted) code for the
            method being executed
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.GetILOffset">
            <summary>
            Returns the offset from the start of the IL code for the
            method being executed.  This offset may be approximate depending
            on whether the jitter is generating debuggable code or not.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.GetFileName">
            <summary>
            Returns the file name containing the code being executed.  This
            information is normally extracted from the debugging symbols
            for the executable.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.GetFileLineNumber">
            <summary>
            Returns the line number in the file containing the code being executed.
            This information is normally extracted from the debugging symbols
            for the executable.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.GetFileColumnNumber">
            <summary>
            Returns the column number in the line containing the code being executed.
            This information is normally extracted from the debugging symbols
            for the executable.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackFrame.ToString">
            <summary>
            Builds a readable representation of the stack frame
            </summary>
        </member>
        <member name="T:System.Diagnostics.StackTrace">
            <summary>
            Class which represents a description of a stack trace
            There is no good reason for the methods of this class to be virtual.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.CaptureStackTrace(System.Int32,System.Boolean,System.Exception)">
            <summary>
            Retrieves an object with stack trace information encoded.
            It leaves out the first "iSkip" lines of the stacktrace.
            </summary>
        </member>
        <member name="F:System.Diagnostics.StackTrace._stackFrames">
            <summary>
            Stack frames comprising this stack trace.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor">
            <summary>
            Constructs a stack trace from the current location.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Boolean)">
            <summary>
            Constructs a stack trace from the current location.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Int32)">
            <summary>
            Constructs a stack trace from the current location, in a caller's
            frame
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a stack trace from the current location, in a caller's
            frame
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Exception)">
            <summary>
            Constructs a stack trace from the current location.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Exception,System.Boolean)">
            <summary>
            Constructs a stack trace from the current location.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Exception,System.Int32)">
            <summary>
            Constructs a stack trace from the current location, in a caller's
            frame
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Exception,System.Int32,System.Boolean)">
            <summary>
            Constructs a stack trace from the current location, in a caller's
            frame
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.#ctor(System.Diagnostics.StackFrame)">
            <summary>
            Constructs a "fake" stack trace, just containing a single frame.
            Does not have the overhead of a full stack trace.
            </summary>
        </member>
        <member name="P:System.Diagnostics.StackTrace.FrameCount">
            <summary>
            Property to get the number of frames in the stack trace
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.GetFrame(System.Int32)">
            <summary>
            Returns a given stack frame.  Stack frames are numbered starting at
            zero, which is the last stack frame pushed.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.GetFrames">
            <summary>
            Returns an array of all stack frames for this stacktrace.
            The array is ordered and sized such that GetFrames()[i] == GetFrame(i)
            The nth element of this array is the same as GetFrame(n).
            The length of the array is the same as FrameCount.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.ToString">
            <summary>
            Builds a readable representation of the stack trace
            </summary>
        </member>
        <member name="T:System.Diagnostics.StackTrace.TraceFormat">
            <summary>
            TraceFormat is used to specify options for how the 
            string-representation of a StackTrace should be generated.
            </summary>
        </member>
        <member name="M:System.Diagnostics.StackTrace.ToString(System.Diagnostics.StackTrace.TraceFormat)">
            <summary>
            Builds a readable representation of the stack trace, specifying 
            the format for backwards compatibility.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.PureAttribute">
            <summary>
            Methods and classes marked with this attribute can be used within calls to Contract methods. Such methods not make any visible state changes.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractClassAttribute">
            <summary>
            Types marked with this attribute specify that a separate type contains the contracts for this type.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractClassForAttribute">
            <summary>
            Types marked with this attribute specify that they are a contract for the type that is the argument of the constructor.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractInvariantMethodAttribute">
            <summary>
            This attribute is used to mark a method as being the invariant
            method for a class. The method can have any name, but it must
            return "void" and take no parameters. The body of the method
            must consist solely of one or more calls to the method
            Contract.Invariant. A suggested name for the method is 
            "ObjectInvariant".
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute">
            <summary>
            Attribute that specifies that an assembly is a reference assembly with contracts.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute">
            <summary>
            Methods (and properties) marked with this attribute can be used within calls to Contract methods, but have no runtime behavior associated with them.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractVerificationAttribute">
            <summary>
            Instructs downstream tools whether to assume the correctness of this assembly, type or member without performing any verification or not.
            Can use [ContractVerification(false)] to explicitly mark assembly, type or member as one to *not* have verification performed on it.
            Most specific element found (member, type, then assembly) takes precedence.
            (That is useful if downstream tools allow a user to decide which polarity is the default, unmarked case.)
            </summary>
            <remarks>
            Apply this attribute to a type to apply to all members of the type, including nested types.
            Apply this attribute to an assembly to apply to all types and members of the assembly.
            Apply this attribute to a property to apply to both the getter and setter.
            </remarks>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute">
            <summary>
            Allows a field f to be used in the method contracts for a method m when f has less visibility than m.
            For instance, if the method is public, but the field is private.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractArgumentValidatorAttribute">
            <summary>
            Enables factoring legacy if-then-throw into separate methods for reuse and full control over
            thrown exception and arguments
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractAbbreviatorAttribute">
            <summary>
            Enables writing abbreviations for contracts that get copied to other methods
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.ContractOptionAttribute">
            <summary>
            Allows setting contract and tool options at assembly, type, or method granularity.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Contracts.Contract">
            <summary>
            Contains static methods for representing program contracts such as preconditions, postconditions, and invariants.
            </summary>
            <remarks>
            WARNING: A binary rewriter must be used to insert runtime enforcement of these contracts.
            Otherwise some contracts like Ensures can only be checked statically and will not throw exceptions during runtime when contracts are violated.
            Please note this class uses conditional compilation to help avoid easy mistakes.  Defining the preprocessor
            symbol CONTRACTS_PRECONDITIONS will include all preconditions expressed using Contract.Requires in your 
            build.  The symbol CONTRACTS_FULL will include postconditions and object invariants, and requires the binary rewriter.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)">
            <summary>
            Instructs code analysis tools to assume the expression <paramref name="condition"/> is true even if it can not be statically proven to always be true.
            </summary>
            <param name="condition">Expression to assume will always be true.</param>
            <remarks>
            At runtime this is equivalent to an <seealso cref="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)">
            <summary>
            Instructs code analysis tools to assume the expression <paramref name="condition"/> is true even if it can not be statically proven to always be true.
            </summary>
            <param name="condition">Expression to assume will always be true.</param>
            <param name="userMessage">If it is not a constant string literal, then the contract may not be understood by tools.</param>
            <remarks>
            At runtime this is equivalent to an <seealso cref="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)">
            <summary>
            In debug builds, perform a runtime check that <paramref name="condition"/> is true.
            </summary>
            <param name="condition">Expression to check to always be true.</param>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)">
            <summary>
            In debug builds, perform a runtime check that <paramref name="condition"/> is true.
            </summary>
            <param name="condition">Expression to check to always be true.</param>
            <param name="userMessage">If it is not a constant string literal, then the contract may not be understood by tools.</param>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)">
            <summary>
            Specifies a contract such that the expression <paramref name="condition"/> must be true before the enclosing method or property is invoked.
            </summary>
            <param name="condition">Boolean expression representing the contract.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference members at least as visible as the enclosing method.
            Use this form when backward compatibility does not force you to throw a particular exception.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)">
            <summary>
            Specifies a contract such that the expression <paramref name="condition"/> must be true before the enclosing method or property is invoked.
            </summary>
            <param name="condition">Boolean expression representing the contract.</param>
            <param name="userMessage">If it is not a constant string literal, then the contract may not be understood by tools.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference members at least as visible as the enclosing method.
            Use this form when backward compatibility does not force you to throw a particular exception.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)">
            <summary>
            Specifies a contract such that the expression <paramref name="condition"/> must be true before the enclosing method or property is invoked.
            </summary>
            <param name="condition">Boolean expression representing the contract.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference members at least as visible as the enclosing method.
            Use this form when you want to throw a particular exception.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)">
            <summary>
            Specifies a contract such that the expression <paramref name="condition"/> must be true before the enclosing method or property is invoked.
            </summary>
            <param name="condition">Boolean expression representing the contract.</param>
            <param name="userMessage">If it is not a constant string literal, then the contract may not be understood by tools.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference members at least as visible as the enclosing method.
            Use this form when you want to throw a particular exception.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)">
            <summary>
            Specifies a public contract such that the expression <paramref name="condition"/> will be true when the enclosing method or property returns normally.
            </summary>
            <param name="condition">Boolean expression representing the contract.  May include <seealso cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)"/> and <seealso cref="M:System.Diagnostics.Contracts.Contract.Result``1"/>.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference members at least as visible as the enclosing method.
            The contract rewriter must be used for runtime enforcement of this postcondition.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)">
            <summary>
            Specifies a public contract such that the expression <paramref name="condition"/> will be true when the enclosing method or property returns normally.
            </summary>
            <param name="condition">Boolean expression representing the contract.  May include <seealso cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)"/> and <seealso cref="M:System.Diagnostics.Contracts.Contract.Result``1"/>.</param>
            <param name="userMessage">If it is not a constant string literal, then the contract may not be understood by tools.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference members at least as visible as the enclosing method.
            The contract rewriter must be used for runtime enforcement of this postcondition.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)">
            <summary>
            Specifies a contract such that if an exception of type <typeparamref name="TException"/> is thrown then the expression <paramref name="condition"/> will be true when the enclosing method or property terminates abnormally.
            </summary>
            <typeparam name="TException">Type of exception related to this postcondition.</typeparam>
            <param name="condition">Boolean expression representing the contract.  May include <seealso cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)"/> and <seealso cref="M:System.Diagnostics.Contracts.Contract.Result``1"/>.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference types and members at least as visible as the enclosing method.
            The contract rewriter must be used for runtime enforcement of this postcondition.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)">
            <summary>
            Specifies a contract such that if an exception of type <typeparamref name="TException"/> is thrown then the expression <paramref name="condition"/> will be true when the enclosing method or property terminates abnormally.
            </summary>
            <typeparam name="TException">Type of exception related to this postcondition.</typeparam>
            <param name="condition">Boolean expression representing the contract.  May include <seealso cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)"/> and <seealso cref="M:System.Diagnostics.Contracts.Contract.Result``1"/>.</param>
            <param name="userMessage">If it is not a constant string literal, then the contract may not be understood by tools.</param>
            <remarks>
            This call must happen at the beginning of a method or property before any other code.
            This contract is exposed to clients so must only reference types and members at least as visible as the enclosing method.
            The contract rewriter must be used for runtime enforcement of this postcondition.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Result``1">
            <summary>
            Represents the result (a.k.a. return value) of a method or property.
            </summary>
            <typeparam name="T">Type of return value of the enclosing method or property.</typeparam>
            <returns>Return value of the enclosing method or property.</returns>
            <remarks>
            This method can only be used within the argument to the <seealso cref="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)"/> contract.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)">
            <summary>
            Represents the final (output) value of an out parameter when returning from a method.
            </summary>
            <typeparam name="T">Type of the out parameter.</typeparam>
            <param name="value">The out parameter.</param>
            <returns>The output value of the out parameter.</returns>
            <remarks>
            This method can only be used within the argument to the <seealso cref="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)"/> contract.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)">
            <summary>
            Represents the value of <paramref name="value"/> as it was at the start of the method or property.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/>.  This can be inferred.</typeparam>
            <param name="value">Value to represent.  This must be a field or parameter.</param>
            <returns>Value of <paramref name="value"/> at the start of the method or property.</returns>
            <remarks>
            This method can only be used within the argument to the <seealso cref="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)"/> contract.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)">
            <summary>
            Specifies a contract such that the expression <paramref name="condition"/> will be true after every method or property on the enclosing class.
            </summary>
            <param name="condition">Boolean expression representing the contract.</param>
            <remarks>
            This contact can only be specified in a dedicated invariant method declared on a class.
            This contract is not exposed to clients so may reference members less visible as the enclosing method.
            The contract rewriter must be used for runtime enforcement of this invariant.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)">
            <summary>
            Specifies a contract such that the expression <paramref name="condition"/> will be true after every method or property on the enclosing class.
            </summary>
            <param name="condition">Boolean expression representing the contract.</param>
            <param name="userMessage">If it is not a constant string literal, then the contract may not be understood by tools.</param>
            <remarks>
            This contact can only be specified in a dedicated invariant method declared on a class.
            This contract is not exposed to clients so may reference members less visible as the enclosing method.
            The contract rewriter must be used for runtime enforcement of this invariant.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})">
            <summary>
            Returns whether the <paramref name="predicate"/> returns <c>true</c> 
            for all integers starting from <paramref name="fromInclusive"/> to <paramref name="toExclusive"/> - 1.
            </summary>
            <param name="fromInclusive">First integer to pass to <paramref name="predicate"/>.</param>
            <param name="toExclusive">One greater than the last integer to pass to <paramref name="predicate"/>.</param>
            <param name="predicate">Function that is evaluated from <paramref name="fromInclusive"/> to <paramref name="toExclusive"/> - 1.</param>
            <returns><c>true</c> if <paramref name="predicate"/> returns <c>true</c> for all integers 
            starting from <paramref name="fromInclusive"/> to <paramref name="toExclusive"/> - 1.</returns>
            <seealso cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Returns whether the <paramref name="predicate"/> returns <c>true</c> 
            for all elements in the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection from which elements will be drawn from to pass to <paramref name="predicate"/>.</param>
            <param name="predicate">Function that is evaluated on elements from <paramref name="collection"/>.</param>
            <returns><c>true</c> if and only if <paramref name="predicate"/> returns <c>true</c> for all elements in
            <paramref name="collection"/>.</returns>
            <seealso cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})">
            <summary>
            Returns whether the <paramref name="predicate"/> returns <c>true</c> 
            for any integer starting from <paramref name="fromInclusive"/> to <paramref name="toExclusive"/> - 1.
            </summary>
            <param name="fromInclusive">First integer to pass to <paramref name="predicate"/>.</param>
            <param name="toExclusive">One greater than the last integer to pass to <paramref name="predicate"/>.</param>
            <param name="predicate">Function that is evaluated from <paramref name="fromInclusive"/> to <paramref name="toExclusive"/> - 1.</param>
            <returns><c>true</c> if <paramref name="predicate"/> returns <c>true</c> for any integer
            starting from <paramref name="fromInclusive"/> to <paramref name="toExclusive"/> - 1.</returns>
            <seealso cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Returns whether the <paramref name="predicate"/> returns <c>true</c> 
            for any element in the <paramref name="collection"/>.
            </summary>
            <param name="collection">The collection from which elements will be drawn from to pass to <paramref name="predicate"/>.</param>
            <param name="predicate">Function that is evaluated on elements from <paramref name="collection"/>.</param>
            <returns><c>true</c> if and only if <paramref name="predicate"/> returns <c>true</c> for an element in
            <paramref name="collection"/>.</returns>
            <seealso cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.EndContractBlock">
            <summary>
            Marker to indicate the end of the contract section of a method.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.AssertMustUseRewriter(System.Diagnostics.Contracts.ContractFailureKind,System.String)">
            <summary>
            This method is used internally to trigger a failure indicating to the "programmer" that he is using the interface incorrectly.
            It is NEVER used to indicate failure of actual contracts at runtime.
            </summary>
        </member>
        <member name="M:System.Diagnostics.Contracts.Contract.ReportFailure(System.Diagnostics.Contracts.ContractFailureKind,System.String,System.String,System.Exception)">
            <summary>
            Without contract rewriting, failing Assert/Assumes end up calling this method.
            Code going through the contract rewriter never calls this method. Instead, the rewriter produced failures call
            System.Runtime.CompilerServices.ContractHelper.RaiseContractFailedEvent, followed by 
            System.Runtime.CompilerServices.ContractHelper.TriggerFailure.
            </summary>
        </member>
        <member name="E:System.Diagnostics.Contracts.Contract.ContractFailed">
            <summary>
            Allows a managed application environment such as an interactive interpreter (IronPython)
            to be notified of contract failures and 
            potentially "handle" them, either by throwing a particular exception type, etc.  If any of the
            event handlers sets the Cancel flag in the ContractFailedEventArgs, then the Contract class will
            not pop up an assert dialog box or trigger escalation policy.  Hooking this event requires 
            full trust, because it will inform you of bugs in the appdomain and because the event handler
            could allow you to continue execution.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Debug">
            <summary>
            Provides a set of properties and methods for debugging code.
            </summary>
        </member>
        <member name="T:System.Diagnostics.DebuggerStepperBoundaryAttribute">
            <summary>Indicates the code following the attribute is to be executed in run, not step, mode.</summary>
        </member>
        <member name="T:System.Diagnostics.DebuggerVisualizerAttribute">
            <summary>
            Signifies that the attributed type has a visualizer which is pointed
            to by the parameter type name strings.
            </summary>
        </member>
        <member name="T:System.Diagnostics.DebugProvider">
            <summary>
            Provides default implementation for Write and Fail methods in Debug class.
            </summary>
        </member>
        <member name="M:System.Enum.TryParseInt32Enum(System.RuntimeType,System.String,System.ReadOnlySpan{System.Char},System.Int32,System.Int32,System.Boolean,System.Boolean,System.TypeCode,System.Int32@)">
            <summary>Tries to parse the value of an enum with known underlying types that fit in an Int32 (Int32, Int16, and SByte).</summary>
        </member>
        <member name="M:System.Enum.TryParseUInt32Enum(System.RuntimeType,System.String,System.ReadOnlySpan{System.Char},System.UInt32,System.Boolean,System.Boolean,System.TypeCode,System.UInt32@)">
            <summary>Tries to parse the value of an enum with known underlying types that fit in a UInt32 (UInt32, UInt16, and Byte).</summary>
        </member>
        <member name="M:System.Enum.TryParseInt64Enum(System.RuntimeType,System.String,System.ReadOnlySpan{System.Char},System.Boolean,System.Boolean,System.Int64@)">
            <summary>Tries to parse the value of an enum with Int64 as the underlying type.</summary>
        </member>
        <member name="M:System.Enum.TryParseUInt64Enum(System.RuntimeType,System.String,System.ReadOnlySpan{System.Char},System.Boolean,System.Boolean,System.UInt64@)">
            <summary>Tries to parse the value of an enum with UInt64 as the underlying type.</summary>
        </member>
        <member name="M:System.Enum.TryParseRareEnum(System.RuntimeType,System.String,System.ReadOnlySpan{System.Char},System.Boolean,System.Boolean,System.Object@)">
            <summary>Tries to parse the value of an enum with an underlying type that can't be expressed in C# (e.g. char, bool, double, etc.)</summary>
        </member>
        <member name="P:System.Environment.TickCount">
            <summary>Gets the number of milliseconds elapsed since the system started.</summary>
            <value>A 32-bit signed integer containing the amount of time in milliseconds that has passed since the last time the computer was started.</value>
        </member>
        <member name="P:System.Environment.TickCount64">
            <summary>Gets the number of milliseconds elapsed since the system started.</summary>
            <value>A 64-bit signed integer containing the amount of time in milliseconds that has passed since the last time the computer was started.</value>
        </member>
        <member name="F:System.Environment.SpecialFolderOptionValues.CSIDL_FLAG_CREATE">
            <summary>
            Force folder creation in SHGetFolderPath. Equivalent of KF_FLAG_CREATE (0x00008000).
            </summary>
        </member>
        <member name="F:System.Environment.SpecialFolderOptionValues.CSIDL_FLAG_DONT_VERIFY">
            <summary>
            Return an unverified folder path. Equivalent of KF_FLAG_DONT_VERIFY (0x00004000).
            </summary>
        </member>
        <member name="M:System.Environment.CheckedSysConf(Interop.Sys.SysConfName)">
            <summary>Invoke <see cref="M:Interop.Sys.SysConf(Interop.Sys.SysConfName)"/>, throwing if it fails.</summary>
        </member>
        <member name="M:System.GC.GetTotalAllocatedBytes(System.Boolean)">
            <summary>
            Get a count of the bytes allocated over the lifetime of the process.
            <param name="precise">If true, gather a precise number, otherwise gather a fairly count. Gathering a precise value triggers at a significant performance penalty.</param>
            </summary>
        </member>
        <member name="M:System.GC.RegisterMemoryLoadChangeNotification(System.Single,System.Single,System.Action)">
            <summary>
            Register a notification to occur *AFTER* a GC occurs in which the memory load changes from within the bound specified
            to outside of the bound specified. This notification will occur once. If repeated notifications are required, the notification
            must be reregistered. The notification will occur on a thread which should not be blocked. Complex processing in the notification should defer work to the threadpool.
            </summary>
            <param name="lowMemoryPercent">percent of HighMemoryLoadThreshold to use as lower bound. Must be a number >= 0 or an ArgumentOutOfRangeException will be thrown.</param>
            <param name="highMemoryPercent">percent of HighMemoryLoadThreshold use to use as lower bound. Must be a number > lowMemory or an ArgumentOutOfRangeException will be thrown. </param>
            <param name="notification">delegate to invoke when operation occurs</param>s
        </member>
        <member name="P:System.Globalization.Calendar.CurrentEraValue">
            <summary>
            This is used to convert CurrentEra(0) to an appropriate era value.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.AddMilliseconds(System.DateTime,System.Double)">
            <summary>
            Returns the DateTime resulting from adding the given number of
            milliseconds to the specified DateTime. The result is computed by rounding
            the number of milliseconds given by value to the nearest integer,
            and adding that interval to the specified DateTime. The value
            argument is permitted to be negative.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.AddDays(System.DateTime,System.Int32)">
            <summary>
            Returns the DateTime resulting from adding a fractional number of
            days to the specified DateTime. The result is computed by rounding the
            fractional number of days given by value to the nearest
            millisecond, and adding that interval to the specified DateTime. The
            value argument is permitted to be negative.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.AddHours(System.DateTime,System.Int32)">
            <summary>
            Returns the DateTime resulting from adding a fractional number of
            hours to the specified DateTime. The result is computed by rounding the
            fractional number of hours given by value to the nearest
            millisecond, and adding that interval to the specified DateTime. The
            value argument is permitted to be negative.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.AddMinutes(System.DateTime,System.Int32)">
            <summary>
            Returns the DateTime resulting from adding a fractional number of
            minutes to the specified DateTime. The result is computed by rounding the
            fractional number of minutes given by value to the nearest
            millisecond, and adding that interval to the specified DateTime. The
            value argument is permitted to be negative.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.AddMonths(System.DateTime,System.Int32)">
             <summary>
             Returns the DateTime resulting from adding the given number of
             months to the specified DateTime. The result is computed by incrementing
             (or decrementing) the year and month parts of the specified DateTime by
             value months, and, if required, adjusting the day part of the
             resulting date downwards to the last day of the resulting month in the
             resulting year. The time-of-day part of the result is the same as the
             time-of-day part of the specified DateTime.
            
             In more precise terms, considering the specified DateTime to be of the
             form y / m / d + t, where y is the
             year, m is the month, d is the day, and t is the
             time-of-day, the result is y1 / m1 / d1 + t,
             where y1 and m1 are computed by adding value months
             to y and m, and d1 is the largest value less than
             or equal to d that denotes a valid day in month m1 of year
             y1.
             </summary>
        </member>
        <member name="M:System.Globalization.Calendar.AddSeconds(System.DateTime,System.Int32)">
            <summary>
            Returns the DateTime resulting from adding a number of
            seconds to the specified DateTime. The result is computed by rounding the
            fractional number of seconds given by value to the nearest
            millisecond, and adding that interval to the specified DateTime. The
            value argument is permitted to be negative.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.AddYears(System.DateTime,System.Int32)">
            <summary>
            Returns the DateTime resulting from adding the given number of
            years to the specified DateTime. The result is computed by incrementing
            (or decrementing) the year part of the specified DateTime by value
            years. If the month and day of the specified DateTime is 2/29, and if the
            resulting year is not a leap year, the month and day of the resulting
            DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
            parts of the result are the same as those of the specified DateTime.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetDayOfMonth(System.DateTime)">
            <summary>
            Returns the day-of-month part of the specified DateTime. The returned
            value is an integer between 1 and 31.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetDayOfWeek(System.DateTime)">
            <summary>
            Returns the day-of-week part of the specified DateTime. The returned value
            is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
            Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
            Thursday, 5 indicates Friday, and 6 indicates Saturday.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetDayOfYear(System.DateTime)">
            <summary>
            Returns the day-of-year part of the specified DateTime. The returned value
            is an integer between 1 and 366.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetDaysInMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the month given by the year and
            month arguments.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetDaysInMonth(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the month given by the year and
            month arguments for the specified era.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetDaysInYear(System.Int32)">
            <summary>
            Returns the number of days in the year given by the year argument
            for the current era.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetDaysInYear(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the year given by the year argument
            for the current era.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetEra(System.DateTime)">
            <summary>
            Returns the era for the specified DateTime value.
            </summary>
        </member>
        <member name="P:System.Globalization.Calendar.Eras">
            <summary>
            Get the list of era values.
            </summary>
            <returns>The int array of the era names supported in this calendar or null if era is not used.</returns>
        </member>
        <member name="M:System.Globalization.Calendar.GetFirstDayWeekOfYear(System.DateTime,System.Int32)">
             <summary>
             Get the week of year using the FirstDay rule.
             </summary>
             <remarks>
              The CalendarWeekRule.FirstDay rule: Week 1 begins on the first day of the year.
              Assume f is the specifed firstDayOfWeek,
              and n is the day of week for January 1 of the specified year.
              Assign offset = n - f;
              Case 1: offset = 0
                  E.g.
                                 f=1
                      weekday 0  1  2  3  4  5  6  0  1
                      date       1/1
                      week#      1                    2
                  then week of year = (GetDayOfYear(time) - 1) / 7 + 1
            
              Case 2: offset &lt; 0
                  e.g.
                                 n=1   f=3
                      weekday 0  1  2  3  4  5  6  0
                      date       1/1
                      week#      1     2
                  This means that the first week actually starts 5 days before 1/1.
                  So week of year = (GetDayOfYear(time) + (7 + offset) - 1) / 7 + 1
              Case 3: offset > 0
                  e.g.
                              f=0   n=2
                      weekday 0  1  2  3  4  5  6  0  1  2
                      date          1/1
                      week#         1                    2
                  This means that the first week actually starts 2 days before 1/1.
                  So Week of year = (GetDayOfYear(time) + offset - 1) / 7 + 1
             </remarks>
        </member>
        <member name="M:System.Globalization.Calendar.GetWeekOfYear(System.DateTime,System.Globalization.CalendarWeekRule,System.DayOfWeek)">
            <summary>
            Returns the week of year for the specified DateTime. The returned value is an
            integer between 1 and 53.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetYear(System.DateTime)">
            <summary>
            Returns the year part of the specified DateTime. The returned value is an
            integer between 1 and 9999.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.IsLeapDay(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether a given day in the current era is a leap day.
            This method returns true if the date is a leap day, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.IsLeapDay(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether a given day in the specified era is a leap day.
            This method returns true if the date is a leap day, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.IsLeapMonth(System.Int32,System.Int32)">
            <summary>
            Checks whether a given month in the current era is a leap month.
            This method returns true if month is a leap month, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.IsLeapMonth(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether a given month in the specified era is a leap month. This method returns true if
            month is a leap month, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetLeapMonth(System.Int32)">
            <summary>
            Returns  the leap month in a calendar year of the current era.
            This method returns 0 if this calendar does not have leap month,
            or this year is not a leap year.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.GetLeapMonth(System.Int32,System.Int32)">
            <summary>
            Returns  the leap month in a calendar year of the specified era.
            This method returns 0 if this calendar does not have leap month,
            or this year is not a leap year.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.IsLeapYear(System.Int32)">
            <summary>
            Checks whether a given year in the current era is a leap year.
            This method returns true if year is a leap year, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.IsLeapYear(System.Int32,System.Int32)">
            <summary>
            Checks whether a given year in the specified era is a leap year.
            This method returns true if year is a leap year, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.ToDateTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the date and time converted to a DateTime value.
            Throws an exception if the n-tuple is invalid.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.ToDateTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the date and time converted to a DateTime value.
            Throws an exception if the n-tuple is invalid.
            </summary>
        </member>
        <member name="P:System.Globalization.Calendar.TwoDigitYearMax">
            <summary>
            Returns and assigns the maximum value to represent a two digit year.
            This value is the upper boundary of a 100 year range that allows a
            two digit year to be properly translated to a four digit year.
            For example, if 2029 is the upper boundary, then a two digit value of
            30 should be interpreted as 1930 while a two digit value of 29 should
            be interpreted as 2029.  In this example, the 100 year range would be
            from 1930-2029.  See ToFourDigitYear().
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.ToFourDigitYear(System.Int32)">
            <summary>
            Converts the year value to the appropriate century by using the
            TwoDigitYearMax property.  For example, if the TwoDigitYearMax value is 2029,
            then a two digit value of 30 will get converted to 1930 while a two digit
            value of 29 will get converted to 2029.
            </summary>
        </member>
        <member name="M:System.Globalization.Calendar.TimeToTicks(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the tick count corresponding to the given hour, minute, second.
            Will check the if the parameters are valid.
            </summary>
        </member>
        <member name="M:System.Globalization.CalendarData.NormalizeDatePattern(System.String)">
            <summary>
            The ICU date format characters are not exactly the same as the .NET date format characters.
            NormalizeDatePattern will take in an ICU date pattern and return the equivalent .NET date pattern.
            </summary>
            <remarks>
            see Date Field Symbol Table in http://userguide.icu-project.org/formatparse/datetime
            and https://msdn.microsoft.com/en-us/library/8kb3ddd4(v=vs.110).aspx
            </remarks>
        </member>
        <member name="T:System.Globalization.CharUnicodeInfo">
            <summary>
            This class implements a set of methods for retrieving character type
            information. Character type information is independent of culture
            and region.
            </summary>
        </member>
        <member name="M:System.Globalization.CharUnicodeInfo.InternalConvertToUtf32(System.String,System.Int32)">
             <summary>
             Convert the BMP character or surrogate pointed by index to a UTF32 value.
             This is similar to char.ConvertToUTF32, but the difference is that
             it does not throw exceptions when invalid surrogate characters are passed in.
            
             WARNING: since it doesn't throw an exception it CAN return a value
             in the surrogate range D800-DFFF, which are not legal unicode values.
             </summary>
        </member>
        <member name="M:System.Globalization.CharUnicodeInfo.InternalConvertToUtf32(System.String,System.Int32,System.Int32@)">
            <summary>
            Convert a character or a surrogate pair starting at index of string s
            to UTF32 value.
            WARNING: since it doesn't throw an exception it CAN return a value
            in the surrogate range D800-DFFF, which are not legal unicode values.
            </summary>
        </member>
        <member name="M:System.Globalization.CharUnicodeInfo.InternalGetNumericValue(System.Int32)">
            <summary>
            This is called by the public char and string, index versions
            Note that for ch in the range D800-DFFF we just treat it as any
            other non-numeric character
            </summary>
        </member>
        <member name="M:System.Globalization.CharUnicodeInfo.GetNumericValue(System.Char)">
            <summary>
            Returns the numeric value associated with the character c.
            If the character is a fraction,  the return value will not be an
            integer. If the character does not have a numeric value, the return
            value is -1.
            </summary>
        </member>
        <member name="M:System.Globalization.CharUnicodeInfo.InternalGetCategoryValue(System.Int32,System.Int32)">
            <summary>
            Returns the Unicode Category property for the character c.
            Note that this API will return values for D800-DF00 surrogate halves.
            </summary>
        </member>
        <member name="M:System.Globalization.CharUnicodeInfo.InternalGetUnicodeCategory(System.String,System.Int32)">
            <summary>
            Returns the Unicode Category property for the character c.
            </summary>
        </member>
        <member name="M:System.Globalization.CharUnicodeInfo.InternalGetUnicodeCategory(System.String,System.Int32,System.Int32@)">
            <summary>
            Get the Unicode category of the character starting at index.  If the character is in BMP, charLength will return 1.
            If the character is a valid surrogate pair, charLength will return 2.
            </summary>
        </member>
        <member name="T:System.Globalization.CultureData">
             <summary>
             List of culture data
             Note the we cache overrides.
             Note that localized names (resource names) aren't available from here.
             </summary>
             <remarks>
             Our names are a tad confusing.
            
             sWindowsName -- The name that windows thinks this culture is, ie:
                                        en-US if you pass in en-US
                                        de-DE_phoneb if you pass in de-DE_phoneb
                                        fj-FJ if you pass in fj (neutral, on a pre-Windows 7 machine)
                                        fj if you pass in fj (neutral, post-Windows 7 machine)
            
             sRealName -- The name you used to construct the culture, in pretty form
                                   en-US if you pass in EN-us
                                   en if you pass in en
                                   de-DE_phoneb if you pass in de-DE_phoneb
            
             sSpecificCulture -- The specific culture for this culture
                                         en-US for en-US
                                         en-US for en
                                         de-DE_phoneb for alt sort
                                         fj-FJ for fj (neutral)
            
             sName -- The IETF name of this culture (ie: no sort info, could be neutral)
                            en-US if you pass in en-US
                            en if you pass in en
                            de-DE if you pass in de-DE_phoneb
             </remarks>
        </member>
        <member name="P:System.Globalization.CultureData.RegionNames">
            <summary>
            Region Name to Culture Name mapping table
            </summary>
            <remarks>
            Using a property so we avoid creating the dictionary until we need it
            </remarks>
        </member>
        <member name="P:System.Globalization.CultureData.Invariant">
            <summary>
            Build our invariant information
            We need an invariant instance, which we build hard-coded
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.GetCultureData(System.Int32,System.Boolean)">
            We'd rather people use the named version since this doesn't allow custom locales
        </member>
        <member name="P:System.Globalization.CultureData.CultureName">
            <summary>
            The real name used to construct the locale (ie: de-DE_phoneb)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.UseUserOverride">
            <summary>
            Are overrides enabled?
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.Name">
            <summary>
            locale name (ie: de-DE, NO sort information)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.EnglishName">
            <summary>
            English pretty name for this locale (ie: English (United States))
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.NativeName">
            <summary>
            Native pretty name for this locale (ie: Deutsch (Deutschland))
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.SpecificCultureName">
            <summary>
            The culture name to be used in CultureInfo.CreateSpecificCulture()
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.TwoLetterISOLanguageName">
            <summary>
            iso 639 language name, ie: en
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ThreeLetterISOLanguageName">
            <summary>
            iso 639 language name, ie: eng
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ThreeLetterWindowsLanguageName">
            <summary>
            abbreviated windows language name (ie: enu) (non-standard, avoid this)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.LocalizedLanguageName">
            <summary>
            Localized name for this language (Windows Only) ie: Inglis
            This is only valid for Windows 8 and higher neutrals:
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.EnglishLanguageName">
            <summary>
            English name for this language (Windows Only) ie: German
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.NativeLanguageName">
            <summary>
            Native name of this language (Windows Only) ie: Deutsch
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.RegionName">
            <summary>
            region name (eg US)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.LocalizedCountryName">
            <summary>
            localized name for the country
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.EnglishCountryName">
            <summary>
            english country name (RegionInfo) ie: Germany
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.NativeCountryName">
            <summary>
            native country name (RegionInfo) ie: Deutschland
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.TwoLetterISOCountryName">
            <summary>
            ISO 3166 Country Name
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ThreeLetterISOCountryName">
            <summary>
            3 letter ISO 3166 country code
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.SCONSOLEFALLBACKNAME">
            <summary>
            Console fallback name (ie: locale to use for console apps for unicode-only locales)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.NumberGroupSizes">
            <summary>
            (user can override) grouping of digits
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.NaNSymbol">
            <summary>
            Not a Number
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.PositiveInfinitySymbol">
            <summary>
            + Infinity
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.NegativeInfinitySymbol">
            <summary>
            - Infinity
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.PercentNegativePattern">
            <summary>
            Negative Percent (0-3)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.PercentPositivePattern">
            <summary>
            Positive Percent (0-11)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.PercentSymbol">
            <summary>
            Percent (%) symbol
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.PerMilleSymbol">
            <summary>
            PerMille symbol
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.CurrencySymbol">
            <summary>
            (user can override) local monetary symbol, eg: $
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ISOCurrencySymbol">
            <summary>
            international monetary symbol (RegionInfo), eg: USD
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.CurrencyEnglishName">
            <summary>
            English name for this currency (RegionInfo), eg: US Dollar
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.CurrencyNativeName">
            <summary>
            Native name for this currency (RegionInfo), eg: Schweiz Frank
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.CurrencyGroupSizes">
            <summary>
            (user can override) monetary grouping of digits
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.MeasurementSystem">
            <summary>
            (user can override) system of measurement 0=metric, 1=US (RegionInfo)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ListSeparator">
            <summary>
            (user can override) list Separator
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.AMDesignator">
            <summary>
            (user can override) AM designator
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.PMDesignator">
            <summary>
            (user can override) PM designator
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.LongTimes">
            <summary>
            (user can override) time format
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ShortTimes">
            <summary>
            short time format
            Short times (derived from long times format)
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.ShortDates(System.Globalization.CalendarId)">
            <summary>
            (user can override default only) short date format
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.LongDates(System.Globalization.CalendarId)">
            <summary>
            (user can override default only) long date format
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.YearMonths(System.Globalization.CalendarId)">
            <summary>
            (user can override) date year/month format.
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.LeapYearMonthNames(System.Globalization.CalendarId)">
            <remarks>>
            Note: This only applies to Hebrew, and it basically adds a "1" to the 6th month name
            the non-leap names skip the 7th name in the normal month name array
            </remarks>
        </member>
        <member name="P:System.Globalization.CultureData.CalendarIds">
            <summary>
            All available calendar type(s). The first one is the default calendar.
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.CalendarName(System.Globalization.CalendarId)">
            <summary>
            Native calendar names. Index of optional calendar - 1, empty if
            no optional calendar at that number
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ReadingLayout">
            <summary>
            Returns one of the following 4 reading layout values:
            0 - Left to right (eg en-US)
            1 - Right to left (eg arabic locales)
            2 - Vertical top to bottom with columns to the left and also left to right (ja-JP locales)
            3 - Vertical top to bottom with columns proceeding to the right
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.TextInfoName">
            <summary>
            // Text info name to use for text information
            The TextInfo name never includes that alternate sort and is always specific
            For customs, it uses the SortLocale (since the textinfo is not exposed in Win7)
            en -> en-US
            en-US -> en-US
            fj (custom neutral) -> en-US (assuming that en-US is the sort locale for fj)
            fj_FJ (custom specific) -> en-US (assuming that en-US is the sort locale for fj-FJ)
            es-ES_tradnl -> es-ES
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.SortName">
            <summary>
            Compare info name (including sorting key) to use if custom
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.ANSICodePage">
            <summary>
            Default ansi code page ID (ACP)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.OEMCodePage">
            <summary>
            Default oem code page ID (OCP or OEM).
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.MacCodePage">
            <summary>
            Default macintosh code page.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.EBCDICCodePage">
            <summary>
            Default EBCDIC code page.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.DefaultCalendar">
            <summary>
            Get an instance of our default calendar
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.EraNames(System.Globalization.CalendarId)">
            <summary>
            All of our era names
            </summary>
        </member>
        <member name="P:System.Globalization.CultureData.TimeSeparator">
            <summary>
            Time separator (derived from time format)
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.DateSeparator(System.Globalization.CalendarId)">
            <summary>
            Date separator (derived from short date format)
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.UnescapeNlsString(System.String,System.Int32,System.Int32)">
             <summary>
             Unescape a NLS style quote string
            
             This removes single quotes:
                  'fred' -> fred
                  'fred -> fred
                  fred' -> fred
                  fred's -> freds
            
             This removes the first \ of escaped characters:
                  fred\'s -> fred's
                  a\\b -> a\b
                  a\b -> ab
            
             We don't build the stringbuilder unless we find a ' or a \.  If we find a ' or a \, we
             always build a stringbuilder because we need to remove the ' or \.
             </summary>
        </member>
        <member name="M:System.Globalization.CultureData.GetTimeSeparator(System.String)">
            <summary>
            Time format separator (ie: : in 12:39:00)
            We calculate this from the provided time format
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.GetDateSeparator(System.String)">
            <summary>
            Date format separator (ie: / in 9/1/03)
            We calculate this from the provided short date
            </summary>
        </member>
        <member name="M:System.Globalization.CultureData.AnsiToLower(System.String)">
            <remarks>
            This is ONLY used for caching names and shouldn't be used for anything else
            </remarks>
        </member>
        <member name="T:System.Globalization.CultureData.LocaleStringData">
            <remarks>
            The numeric values of the enum members match their Win32 counterparts.  The CultureData Win32 PAL implementation
            takes a dependency on this fact, in order to prevent having to construct a mapping from internal values to LCTypes.
            </remarks>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.LocalizedDisplayName">
            <summary>localized name of locale, eg "German (Germany)" in UI language (corresponds to LOCALE_SLOCALIZEDDISPLAYNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.EnglishDisplayName">
            <summary>Display name (language + country usually) in English, eg "German (Germany)" (corresponds to LOCALE_SENGLISHDISPLAYNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.NativeDisplayName">
            <summary>Display name in native locale language, eg "Deutsch (Deutschland) (corresponds to LOCALE_SNATIVEDISPLAYNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.LocalizedLanguageName">
            <summary>Language Display Name for a language, eg "German" in UI language (corresponds to LOCALE_SLOCALIZEDLANGUAGENAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.EnglishLanguageName">
            <summary>English name of language, eg "German" (corresponds to LOCALE_SENGLISHLANGUAGENAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.NativeLanguageName">
            <summary>native name of language, eg "Deutsch" (corresponds to LOCALE_SNATIVELANGUAGENAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.LocalizedCountryName">
            <summary>localized name of country, eg "Germany" in UI language (corresponds to LOCALE_SLOCALIZEDCOUNTRYNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.EnglishCountryName">
            <summary>English name of country, eg "Germany" (corresponds to LOCALE_SENGLISHCOUNTRYNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.NativeCountryName">
            <summary>native name of country, eg "Deutschland" (corresponds to LOCALE_SNATIVECOUNTRYNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.AbbreviatedWindowsLanguageName">
            <summary>abbreviated language name (corresponds to LOCALE_SABBREVLANGNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.ListSeparator">
            <summary>list item separator (corresponds to LOCALE_SLIST)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.DecimalSeparator">
            <summary>decimal separator (corresponds to LOCALE_SDECIMAL)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.ThousandSeparator">
            <summary>thousand separator (corresponds to LOCALE_STHOUSAND)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.Digits">
            <summary>digit grouping (corresponds to LOCALE_SGROUPING)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.MonetarySymbol">
            <summary>local monetary symbol (corresponds to LOCALE_SCURRENCY)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.CurrencyEnglishName">
            <summary>English currency name (corresponds to LOCALE_SENGCURRNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.CurrencyNativeName">
            <summary>Native currency name (corresponds to LOCALE_SNATIVECURRNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.Iso4217MonetarySymbol">
            <summary>uintl monetary symbol (corresponds to LOCALE_SINTLSYMBOL)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.MonetaryDecimalSeparator">
            <summary>monetary decimal separator (corresponds to LOCALE_SMONDECIMALSEP)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.MonetaryThousandSeparator">
            <summary>monetary thousand separator (corresponds to LOCALE_SMONTHOUSANDSEP)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.AMDesignator">
            <summary>AM designator (corresponds to LOCALE_S1159)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.PMDesignator">
            <summary>PM designator (corresponds to LOCALE_S2359)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.PositiveSign">
            <summary>positive sign (corresponds to LOCALE_SPOSITIVESIGN)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.NegativeSign">
            <summary>negative sign (corresponds to LOCALE_SNEGATIVESIGN)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.Iso639LanguageTwoLetterName">
            <summary>ISO abbreviated language name (corresponds to LOCALE_SISO639LANGNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.Iso639LanguageThreeLetterName">
            <summary>ISO abbreviated country name (corresponds to LOCALE_SISO639LANGNAME2)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.Iso639LanguageName">
            <summary>ISO abbreviated language name (corresponds to LOCALE_SISO639LANGNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.Iso3166CountryName">
            <summary>ISO abbreviated country name (corresponds to LOCALE_SISO3166CTRYNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.Iso3166CountryName2">
            <summary>3 letter ISO country code (corresponds to LOCALE_SISO3166CTRYNAME2)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.NaNSymbol">
            <summary>Not a Number (corresponds to LOCALE_SNAN)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.PositiveInfinitySymbol">
            <summary>+ Infinity (corresponds to LOCALE_SPOSINFINITY)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.NegativeInfinitySymbol">
            <summary>- Infinity (corresponds to LOCALE_SNEGINFINITY)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.ParentName">
            <summary>Fallback name for resources (corresponds to LOCALE_SPARENT)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.ConsoleFallbackName">
            <summary>Fallback name for within the console (corresponds to LOCALE_SCONSOLEFALLBACKNAME)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.PercentSymbol">
            <summary>Returns the percent symbol (corresponds to LOCALE_SPERCENT)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleStringData.PerMilleSymbol">
            <summary>Returns the permille (U+2030) symbol (corresponds to LOCALE_SPERMILLE)</summary>
        </member>
        <member name="T:System.Globalization.CultureData.LocaleGroupingData">
            <remarks>
            The numeric values of the enum members match their Win32 counterparts.  The CultureData Win32 PAL implementation
            takes a dependency on this fact, in order to prevent having to construct a mapping from internal values to LCTypes.
            </remarks>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleGroupingData.Digit">
            <summary>digit grouping (corresponds to LOCALE_SGROUPING)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleGroupingData.Monetary">
            <summary>monetary grouping (corresponds to LOCALE_SMONGROUPING)</summary>
        </member>
        <member name="T:System.Globalization.CultureData.LocaleNumberData">
            <remarks>
            The numeric values of the enum members match their Win32 counterparts.  The CultureData Win32 PAL implementation
            takes a dependency on this fact, in order to prevent having to construct a mapping from internal values to LCTypes.
            </remarks>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.LanguageId">
            <summary>language id (corresponds to LOCALE_ILANGUAGE)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.GeoId">
            <summary>geographical location id, (corresponds to LOCALE_IGEOID)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.DigitSubstitution">
            <summary>0 = context, 1 = none, 2 = national (corresponds to LOCALE_IDIGITSUBSTITUTION)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.MeasurementSystem">
            <summary>0 = metric, 1 = US (corresponds to LOCALE_IMEASURE)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.FractionalDigitsCount">
            <summary>number of fractional digits (corresponds to LOCALE_IDIGITS)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.NegativeNumberFormat">
            <summary>negative number mode (corresponds to LOCALE_INEGNUMBER)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.MonetaryFractionalDigitsCount">
            <summary># local monetary digits (corresponds to LOCALE_ICURRDIGITS)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.PositiveMonetaryNumberFormat">
            <summary>positive currency mode (corresponds to LOCALE_ICURRENCY)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.NegativeMonetaryNumberFormat">
            <summary>negative currency mode (corresponds to LOCALE_INEGCURR)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.CalendarType">
            <summary>type of calendar specifier (corresponds to LOCALE_ICALENDARTYPE)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.FirstDayOfWeek">
            <summary>first day of week specifier (corresponds to LOCALE_IFIRSTDAYOFWEEK)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.FirstWeekOfYear">
            <summary>first week of year specifier (corresponds to LOCALE_IFIRSTWEEKOFYEAR)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.ReadingLayout">
            <summary>
            Returns one of the following 4 reading layout values:
             0 - Left to right (eg en-US)
             1 - Right to left (eg arabic locales)
             2 - Vertical top to bottom with columns to the left and also left to right (ja-JP locales)
             3 - Vertical top to bottom with columns proceeding to the right
            (corresponds to LOCALE_IREADINGLAYOUT)
            </summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.NegativePercentFormat">
            <summary>Returns 0-11 for the negative percent format (corresponds to LOCALE_INEGATIVEPERCENT)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.PositivePercentFormat">
            <summary>Returns 0-3 for the positive percent format (corresponds to LOCALE_IPOSITIVEPERCENT)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.OemCodePage">
            <summary>default ansi code page (corresponds to LOCALE_IDEFAULTCODEPAGE)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.AnsiCodePage">
            <summary>default ansi code page (corresponds to LOCALE_IDEFAULTANSICODEPAGE)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.MacCodePage">
            <summary>default mac code page (corresponds to LOCALE_IDEFAULTMACCODEPAGE)</summary>
        </member>
        <member name="F:System.Globalization.CultureData.LocaleNumberData.EbcdicCodePage">
            <summary>default ebcdic code page (corresponds to LOCALE_IDEFAULTEBCDICCODEPAGE)</summary>
        </member>
        <member name="M:System.Globalization.CultureData.InitCultureData">
            <summary>
            This method uses the sRealName field (which is initialized by the constructor before this is called) to
            initialize the rest of the state of CultureData based on the underlying OS globalization library.
            </summary>
        </member>
        <member name="T:System.Globalization.CultureInfo">
            <summary>
            This class represents the software preferences of a particular culture
            or community. It includes information such as the language, writing
            system and a calendar used by the culture as well as methods for
            common operations such as printing dates and sorting strings.
            </summary>
            <remarks>
            !!!! NOTE WHEN CHANGING THIS CLASS !!!!
            If adding or removing members to this class, please update
            CultureInfoBaseObject in ndp/clr/src/vm/object.h. Note, the "actual"
            layout of the class may be different than the order in which members
            are declared. For instance, all reference types will come first in the
            class before value types (like ints, bools, etc) regardless of the
            order in which they are declared. The best way to see the actual
            order of the class is to do a !dumpobj on an instance of the managed
            object inside of the debugger.
            </remarks>
        </member>
        <member name="M:System.Globalization.CultureInfo.#ctor(System.String,System.String)">
            <summary>
            Constructor called by SQL Server's special munged culture - creates a culture with
            a TextInfo and CompareInfo that come from a supplied alternate source. This object
            is ALWAYS read-only.
            Note that we really cannot use an LCID version of this override as the cached
            name we create for it has to include both names, and the logic for this is in
            the GetCultureInfo override *only*.
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.GetCultureByName(System.String)">
            <summary>
            We do this to try to return the system UI language and the default user languages
            This method will fallback if this fails (like Invariant)
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.CreateSpecificCulture(System.String)">
             <summary>
             Return a specific culture. A tad irrelevent now since we always
             return valid data for neutral locales.
            
             Note that there's interesting behavior that tries to find a
             smaller name, ala RFC4647, if we can't find a bigger name.
             That doesn't help with things like "zh" though, so the approach
             is of questionable value
             </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.CurrentCulture">
            <summary>
            This instance provides methods based on the current user settings.
            These settings are volatile and may change over the lifetime of the
            thread.
            </summary>
            <remarks>
            We use the following order to return CurrentCulture and CurrentUICulture
                 o   Use WinRT to return the current user profile language
                 o   use current thread culture if the user already set one using CurrentCulture/CurrentUICulture
                 o   use thread culture if the user already set one using DefaultThreadCurrentCulture
                     or DefaultThreadCurrentUICulture
                 o   Use NLS default user culture
                 o   Use NLS default system culture
                 o   Use Invariant culture
            </remarks>
        </member>
        <member name="P:System.Globalization.CultureInfo.InvariantCulture">
            <summary>
            This instance provides methods, for example for casing and sorting,
            that are independent of the system and current user settings.  It
            should be used only by processes such as some system services that
            require such invariant results (eg. file systems).  In general,
            the results are not linguistically correct and do not match any
            culture info.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.Parent">
            <summary>
            Return the parent CultureInfo for the current instance.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.Name">
            <summary>
            Returns the full name of the CultureInfo. The name is in format like
            "en-US" This version does NOT include sort information in the name.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.SortName">
            <summary>
            This one has the sort information (ie: de-DE_phoneb)
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.DisplayName">
            <summary>
            Returns the full name of the CultureInfo in the localized language.
            For example, if the localized language of the runtime is Spanish and the CultureInfo is
            US English, "Ingles (Estados Unidos)" will be returned.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.NativeName">
            <summary>
            Returns the full name of the CultureInfo in the native language.
            For example, if the CultureInfo is US English, "English
            (United States)" will be returned.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.EnglishName">
            <summary>
            Returns the full name of the CultureInfo in English.
            For example, if the CultureInfo is US English, "English
            (United States)" will be returned.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.TwoLetterISOLanguageName">
            <summary>
            ie: en
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.ThreeLetterISOLanguageName">
            <summary>
            ie: eng
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.ThreeLetterWindowsLanguageName">
            <summary>
            Returns the 3 letter windows language name for the current instance.  eg: "ENU"
            The ISO names are much preferred
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.CompareInfo">
            <summary>
            Gets the CompareInfo for this culture.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.TextInfo">
            <summary>
            Gets the TextInfo for this culture.
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.ToString">
            <summary>
            Implements object.ToString(). Returns the name of the CultureInfo,
            eg. "de-DE_phoneb", "en-US", or "fj-FJ".
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.DateTimeFormat">
            <summary>
            Create a DateTimeFormatInfo, and fill in the properties according to
            the CultureID.
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.GetCalendarInstance(System.Globalization.CalendarId)">
            <summary>
            Map a Win32 CALID to an instance of supported calendar.
            </summary>
            <remarks>
            Shouldn't throw exception since the calType value is from our data
            table or from Win32 registry.
            If we are in trouble (like getting a weird value from Win32
            registry), just return the GregorianCalendar.
            </remarks>
        </member>
        <member name="M:System.Globalization.CultureInfo.GetCalendarInstanceRare(System.Globalization.CalendarId)">
            <summary>
            This function exists as a shortcut to prevent us from loading all of the non-gregorian
            calendars unless they're required.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.Calendar">
            <summary>
            Return/set the default calendar used by this culture.
            This value can be overridden by regional option if this is a current culture.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.OptionalCalendars">
            <summary>
            Return an array of the optional calendar for this culture.
            </summary>
        </member>
        <member name="P:System.Globalization.CultureInfo.HasInvariantCultureName">
            <summary>
            For resource lookup, we consider a culture the invariant culture by name equality.
            We perform this check frequently during resource lookup, so adding a property for
            improved readability.
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.GetCultureInfoHelper(System.Int32,System.String,System.String)">
            <summary>
            Helper function overloads of GetCachedReadOnlyCulture.  If lcid is 0, we use the name.
            If lcid is -1, use the altName and create one of those special SQL cultures.
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.GetCultureInfo(System.Int32)">
            <summary>
            Gets a cached copy of the specified culture from an internal
            hashtable (or creates it if not found). (LCID version)
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.GetCultureInfo(System.String)">
            <summary>
            Gets a cached copy of the specified culture from an internal
            hashtable (or creates it if not found). (Named version)
            </summary>
        </member>
        <member name="M:System.Globalization.CultureInfo.GetCultureInfo(System.String,System.String)">
            <summary>
            Gets a cached copy of the specified culture from an internal
            hashtable (or creates it if not found).
            </summary>
        </member>
        <member name="T:System.Globalization.ChineseLunisolarCalendar">
            <remarks>
            Calendar support range:
                Calendar               Minimum             Maximum
                ==========             ==========          ==========
                Gregorian              1901/02/19          2101/01/28
                ChineseLunisolar       1901/01/01          2100/12/29
            </remarks>
        </member>
        <member name="T:System.Globalization.CompareInfo">
            <summary>
            This class implements a set of methods for comparing strings.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.GetCompareInfo(System.Int32,System.Reflection.Assembly)">
            <summary>
            Get the CompareInfo constructed from the data table in the specified
            assembly for the specified culture.
            Warning: The assembly versioning mechanism is dead!
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.GetCompareInfo(System.String,System.Reflection.Assembly)">
            <summary>
            Get the CompareInfo constructed from the data table in the specified
            assembly for the specified culture.
            The purpose of this method is to provide version for CompareInfo tables.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.GetCompareInfo(System.Int32)">
            <summary>
            Get the CompareInfo for the specified culture.
            This method is provided for ease of integration with NLS-based software.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.GetCompareInfo(System.String)">
            <summary>
            Get the CompareInfo for the specified culture.
            </summary>
        </member>
        <member name="P:System.Globalization.CompareInfo.Name">
             <summary>
              Returns the name of the culture (well actually, of the sort).
              Very important for providing a non-LCID way of identifying
              what the sort is.
            
              Note that this name isn't dereferenced in case the CompareInfo is a different locale
              which is consistent with the behaviors of earlier versions.  (so if you ask for a sort
              and the locale's changed behavior, then you'll get changed behavior, which is like
              what happens for a version update)
             </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.Compare(System.String,System.String)">
            <summary>
            Compares the two strings with the given options.  Returns 0 if the
            two strings are equal, a number less than 0 if string1 is less
            than string2, and a number greater than 0 if string1 is greater
            than string2.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Compares the specified regions of the two strings with the given
            options.
            Returns 0 if the two strings are equal, a number less than 0 if
            string1 is less than string2, and a number greater than 0 if
            string1 is greater than string2.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.CompareOrdinalIgnoreCase(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            CompareOrdinalIgnoreCase compare two string ordinally with ignoring the case.
            it assumes the strings are Ascii string till we hit non Ascii character in strA or strB and then we continue the comparison by
            calling the OS.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)">
            <summary>
            Determines whether prefix is a prefix of string.  If prefix equals
            string.Empty, true is returned.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String,System.Globalization.CompareOptions)">
            <summary>
            Determines whether suffix is a suffix of string.  If suffix equals
            string.Empty, true is returned.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)">
            <summary>
            Returns the first index where value is found in string.  The
            search starts from startIndex and ends at endIndex.  Returns -1 if
            the specified value is not found.  If value equals string.Empty,
            startIndex is returned.  Throws IndexOutOfRange if startIndex or
            endIndex is less than zero or greater than the length of string.
            Throws ArgumentException if value is null.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions,System.Int32*)">
            <summary>
            The following IndexOf overload is mainly used by String.Replace. This overload assumes the parameters are already validated
            and the caller is passing a valid matchLengthPtr pointer.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)">
            <summary>
            Returns the last index where value is found in string.  The
            search starts from startIndex and ends at endIndex.  Returns -1 if
            the specified value is not found.  If value equals string.Empty,
            endIndex is returned.  Throws IndexOutOfRange if startIndex or
            endIndex is less than zero or greater than the length of string.
            Throws ArgumentException if value is null.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.GetSortKey(System.String,System.Globalization.CompareOptions)">
            <summary>
            Gets the SortKey for the given string with the given options.
            </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.GetHashCodeOfString(System.String,System.Globalization.CompareOptions)">
             <summary>
             This internal method allows a method that allows the equivalent of creating a Sortkey for a
             string from CompareInfo, and generate a hashcode value from it.  It is not very convenient
             to use this method as is and it creates an unnecessary Sortkey object that will be GC'ed.
            
             The hash code is guaranteed to be the same for string A and B where A.Equals(B) is true and both
             the CompareInfo and the CompareOptions are the same. If two different CompareInfo objects
             treat the string the same way, this implementation will treat them differently (the same way that
             Sortkey does at the moment).
            
             This method will never be made public itself, but public consumers of it could be created, e.g.:
            
                 string.GetHashCode(CultureInfo)
                 string.GetHashCode(CompareInfo)
                 string.GetHashCode(CultureInfo, CompareOptions)
                 string.GetHashCode(CompareInfo, CompareOptions)
                 etc.
            
             (the methods above that take a CultureInfo would use CultureInfo.CompareInfo)
             </summary>
        </member>
        <member name="M:System.Globalization.CompareInfo.IndexOfOrdinalIgnoreCaseHelper(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Globalization.CompareOptions,System.Int32*,System.Boolean)">
            <summary>
            Duplicate of IndexOfOrdinalHelper that also handles ignore case. Can't converge both methods
            as the JIT wouldn't be able to optimize the ignoreCase path away.
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Globalization.MonthNameStyles">
            <summary>
            Flags used to indicate different styles of month names.
            This is an internal flag used by internalGetMonthName().
            Use flag here in case that we need to provide a combination of these styles
            (such as month name of a leap year in genitive form.  Not likely for now,
            but would like to keep the option open).
            </summary>
        </member>
        <member name="T:System.Globalization.DateTimeFormatFlags">
             <summary>
             Flags used to indicate special rule used in parsing/formatting
             for a specific DateTimeFormatInfo instance.
             This is an internal flag.
            
             This flag is different from MonthNameStyles because this flag
             can be expanded to accommodate parsing behaviors like CJK month names
             or alternative month names, etc.
             </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetAbbreviatedDayOfWeekNames">
            <summary>
            Create an array of string which contains the abbreviated day names.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetSuperShortDayNames">
            <summary>
            Returns the string array of the one-letter day of week names.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetDayOfWeekNames">
            <summary>
            Create an array of string which contains the day names.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetAbbreviatedMonthNames">
            <summary>
            Create an array of string which contains the abbreviated month names.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetMonthNames">
            <summary>
            Create an array of string which contains the month names.
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.InvariantInfo">
            <summary>
            Returns a default DateTimeFormatInfo that will be universally
            supported and constant irrespective of the current culture.
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.CurrentInfo">
            <summary>
            Returns the current culture's DateTimeFormatInfo.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetEra(System.String)">
            <summary>
            Get the era value by parsing the name of the era.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetEraName(System.Int32)">
            <summary>
            Get the name of the era for the specified era value.
            Era names are 1 indexed
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetAbbreviatedEraName(System.Int32)">
            <remarks>
            Era names are 1 indexed
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.DateSeparator">
            <remarks>
            Note that cultureData derives this from the short date format (unless someone's set this previously)
            Note that this property is quite undesirable.
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.LongDatePattern">
            <summary>
            For our "patterns" arrays we have 2 variables, a string and a string[]
            The string[] contains the list of patterns, EXCEPT the default may not be included.
            The string contains the default pattern.
            When we initially construct our string[], we set the string to string[0]
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.LongTimePattern">
             <summary>
             For our "patterns" arrays we have 2 variables, a string and a string[]
            
             The string[] contains the list of patterns, EXCEPT the default may not be included.
             The string contains the default pattern.
             When we initially construct our string[], we set the string to string[0]
             </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.MonthDayPattern">
            <remarks>
            Just to be confusing there's only 1 month day pattern, not a whole list
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.ShortDatePattern">
             <summary>
             For our "patterns" arrays we have 2 variables, a string and a string[]
            
             The string[] contains the list of patterns, EXCEPT the default may not be included.
             The string contains the default pattern.
             When we initially construct our string[], we set the string to string[0]
             </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.ShortTimePattern">
             <summary>
             For our "patterns" arrays we have 2 variables, a string and a string[]
            
             The string[] contains the list of patterns, EXCEPT the default may not be included.
             The string contains the default pattern.
             When we initially construct our string[], we set the string to string[0]
             </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.GeneralShortTimePattern">
            <summary>
            Return the pattern for 'g' general format: shortDate + short time
            This is used by DateTimeFormat.cs to get the pattern for 'g'.
            We put this internal property here so that we can avoid doing the
            concatation every time somebody asks for the general format.
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.GeneralLongTimePattern">
            <summary>
            Return the pattern for 'g' general format: shortDate + Long time.
            We put this internal property here so that we can avoid doing the
            concatation every time somebody asks for the general format.
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.DateTimeOffsetPattern">
            Return the default pattern DateTimeOffset : shortDate + long time + time zone offset.
            This is used by DateTimeFormat.cs to get the pattern for short Date + long time +  time zone offset
            We put this internal property here so that we can avoid doing the
            concatation every time somebody uses this form.
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.TimeSeparator">
            <remarks>
            Note that cultureData derives this from the long time format (unless someone's set this previously)
            Note that this property is quite undesirable.
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.YearMonthPattern">
             <summary>
             For our "patterns" arrays we have 2 variables, a string and a string[]
            
             The string[] contains the list of patterns, EXCEPT the default may not be included.
             The string contains the default pattern.
             When we initially construct our string[], we set the string to string[0]
             </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.CheckNullValue(System.String[],System.Int32)">
            <summary>
            Check if a string array contains a null value, and throw ArgumentNullException with parameter name "value"
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.ShortestDayNames">
            <summary>
            Returns the string array of the one-letter day of week names.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetMonthName(System.Int32,System.Globalization.MonthNameStyles,System.Boolean)">
            <summary>
            Return the month name using the specified MonthNameStyles in either abbreviated form
            or full form.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetGenitiveMonthNames(System.Boolean)">
            <summary>
            Retrieve the array which contains the month names in genitive form.
            If this culture does not use the genitive form, the normal month name is returned.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.InternalGetLeapYearMonthNames">
            <summary>
            Retrieve the month names used in a leap year.
            If this culture does not have different month names in a leap year,
            the normal month name is returned.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetShortestDayName(System.DayOfWeek)">
            <summary>
            Returns the super short day of week names for the specified day of week.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetCombinedPatterns(System.String[],System.String[],System.String)">
            <summary>
            Get all possible combination of inputs
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetMergedPatterns(System.String[],System.String)">
             <summary>
             For our "patterns" arrays we have 2 variables, a string and a string[]
            
             The string[] contains the list of patterns, EXCEPT the default may not be included.
             The string contains the default pattern.
             When we initially construct our string[], we set the string to string[0]
            
             The resulting [] can get returned to the calling app, so clone it.
             </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.AllYearMonthPatterns">
            <summary>
            Default string isn't necessarily in our string array, so get the
            merged patterns of both
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.UnclonedYearMonthPatterns">
            <remarks>
            Clone this string array if you want to return it to user.
            Otherwise, you are returning a writable cache copy.
            This won't include default, call AllYearMonthPatterns
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.UnclonedShortDatePatterns">
            <remarks>
            Clone this string array if you want to return it to user.
            Otherwise, you are returning a writable cache copy.
            This won't include default, call AllShortDatePatterns
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.UnclonedLongDatePatterns">
            <remarks>
            Clone this string array if you want to return it to user.
            Otherwise, you are returning a writable cache copy.
            This won't include default, call AllLongDatePatterns
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.UnclonedShortTimePatterns">
            <remarks>
            Clone this string array if you want to return it to user.
            Otherwise, you are returning a writable cache copy.
            This won't include default, call AllShortTimePatterns
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.UnclonedLongTimePatterns">
            <remarks>
            Clone this string array if you want to return it to user.
            Otherwise, you are returning a writable cache copy.
            This won't include default, call AllLongTimePatterns
            </remarks>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.NativeCalendarName">
            <summary>
            Return the native name for the calendar in DTFI.Calendar.  The native name is referred to
            the culture used to create the DTFI.  E.g. in the following example, the native language is Japanese.
            DateTimeFormatInfo dtfi = new CultureInfo("ja-JP", false).DateTimeFormat.Calendar = new JapaneseCalendar();
            String nativeName = dtfi.NativeCalendarName; // Get the Japanese name for the Japanese calendar.
            DateTimeFormatInfo dtfi = new CultureInfo("ja-JP", false).DateTimeFormat.Calendar = new GregorianCalendar(GregorianCalendarTypes.Localized);
            String nativeName = dtfi.NativeCalendarName; // Get the Japanese name for the Gregorian calendar.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.SetAllDateTimePatterns(System.String[],System.Char)">
             <summary>
             Used by custom cultures and others to set the list of available formats. Note that none of them are
             explicitly used unless someone calls GetAllDateTimePatterns and subsequently uses one of the items
             from the list.
            
             Most of the format characters that can be used in GetAllDateTimePatterns are
             not really needed since they are one of the following:
            
              r/R/s/u     locale-independent constants -- cannot be changed!
              m/M/y/Y     fields with a single string in them -- that can be set through props directly
              f/F/g/G/U   derived fields based on combinations of various of the below formats
            
             NOTE: No special validation is done here beyond what is done when the actual respective fields
             are used (what would be the point of disallowing here what we allow in the appropriate property?)
            
             WARNING: If more validation is ever done in one place, it should be done in the other.
             </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.FormatFlags">
            <summary>
            Return the internal flag used in formatting and parsing.
            The flag can be used to indicate things like if genitive forms is used in
            this DTFi, or if leap year gets different month names.
            </summary>
        </member>
        <member name="P:System.Globalization.DateTimeFormatInfo.HasYearMonthAdjustment">
            <summary>
            Returns whether the YearMonthAdjustment function has any fix-up work to do for this culture/calendar.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.YearMonthAdjustment(System.Int32@,System.Int32@,System.Boolean)">
             <summary>
             This is a callback that the parser can make back into the DTFI to let it fiddle with special
             cases associated with that culture or calendar. Currently this only has special cases for
             the Hebrew calendar, but this could be extended to other cultures.
            
             The return value is whether the year and month are actually valid for this calendar.
             </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetJapaneseCalendarDTFI">
            <summary>
            Create a Japanese DTFI which uses JapaneseCalendar.  This is used to parse
            date string with Japanese era name correctly even when the supplied DTFI
            does not use Japanese calendar.
            The created instance is stored in global s_jajpDTFI.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.GetTaiwanCalendarDTFI">
            <summary>
            Create a Taiwan DTFI which uses TaiwanCalendar.  This is used to parse
            date string with era name correctly even when the supplied DTFI
            does not use Taiwan calendar.
            The created instance is stored in global s_zhtwDTFI.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.ClearTokenHashTable">
            <summary>
            DTFI properties should call this when the setter are called.
            </summary>
        </member>
        <member name="M:System.Globalization.DateTimeFormatInfo.TryParseHebrewNumber(System.__DTString@,System.Boolean@,System.Int32@)">
             <summary>
             Try to parse the current word to see if it is a Hebrew number.
             Tokens will be updated accordingly.
             This is called by the Lexer of DateTime.Parse().
            
             Unlike most of the functions in this class, the return value indicates
             whether or not it started to parse. The badFormat parameter indicates
             if parsing began, but the format was bad.
             </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetSexagenaryYear(System.DateTime)">
            <summary>
            Return the year number in the 60-year cycle.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetCelestialStem(System.Int32)">
            <summary>
            Return the celestial year from the 60-year cycle.
            The returned value is from 1 ~ 10.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetTerrestrialBranch(System.Int32)">
            <summary>
            Return the Terrestial Branch from the 60-year cycle.
            The returned value is from 1 ~ 12.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetDaysInMonth(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the month given by the year and
            month arguments.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.ToDateTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the date and time converted to a DateTime value.
            Throws an exception if the n-tuple is invalid.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GregorianToLunar(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Calculates lunar calendar info for the given gregorian year, month, date.
            The input date should be validated before calling this method.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.LunarToGregorian(System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Convert from Lunar to Gregorian
            </summary>
            <remarks>
            Highly inefficient, but it works based on the forward conversion
            </remarks>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.AddMonths(System.DateTime,System.Int32)">
            <summary>
            Returns the DateTime resulting from adding the given number of
            months to the specified DateTime. The result is computed by incrementing
            (or decrementing) the year and month parts of the specified DateTime by
            value months, and, if required, adjusting the day part of the
            resulting date downwards to the last day of the resulting month in the
            resulting year. The time-of-day part of the result is the same as the
            time-of-day part of the specified DateTime.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetDayOfYear(System.DateTime)">
            <summary>
            Returns the day-of-year part of the specified DateTime. The returned value
            is an integer between 1 and [354|355 |383|384].
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetDayOfMonth(System.DateTime)">
            <summary>
            Returns the day-of-month part of the specified DateTime. The returned
            value is an integer between 1 and 29 or 30.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetDaysInYear(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the year given by the year argument for the current era.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetMonth(System.DateTime)">
            <summary>
            Returns the month part of the specified DateTime.
            The returned value is an integer between 1 and 13.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetYear(System.DateTime)">
            <summary>
            Returns the year part of the specified DateTime.
            The returned value is an integer between 1 and MaxCalendarYear.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetDayOfWeek(System.DateTime)">
            <summary>
            Returns the day-of-week part of the specified DateTime. The returned value
            is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
            Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
            Thursday, 5 indicates Friday, and 6 indicates Saturday.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetMonthsInYear(System.Int32,System.Int32)">
            <summary>
            Returns the number of months in the specified year and era.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.IsLeapDay(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether a given day in the specified era is a leap day.
            This method returns true if the date is a leap day, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.IsLeapMonth(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether a given month in the specified era is a leap month.
            This method returns true if month is a leap month, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.GetLeapMonth(System.Int32,System.Int32)">
            <summary>
            Returns  the leap month in a calendar year of the specified era. This method returns 0
            if this year is not a leap year.
            </summary>
        </member>
        <member name="M:System.Globalization.EastAsianLunisolarCalendar.IsLeapYear(System.Int32,System.Int32)">
            <summary>
            Checks whether a given year in the specified era is a leap year.
            This method returns true if year is a leap year, or false if not.
            </summary>
        </member>
        <member name="T:System.Globalization.GregorianCalendar">
            <remarks>
            This calendar recognizes two era values:
            0 CurrentEra (AD)
            1 BeforeCurrentEra (BC)
            </remarks>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetDefaultInstance">
            <summary>
            Internal method to provide a default intance of GregorianCalendar.
            Used by NLS+ implementation
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetAbsoluteDate(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the absolute date for the given Gregorian date. The absolute date means
            the number of days from January 1st, 1 A.D.
            </summary>
            <remarks>
            This is an internal method used by DateToTicks() and the calculations of Hijri and Hebrew calendars.
            Number of Days in Prior Years (both common and leap years) +
            Number of Days in Prior Months of Current Year +
            Number of Days in Current Month
            </remarks>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.DateToTicks(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the tick count corresponding to the given year, month, and day.
            Will check the if the parameters are valid.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.AddMonths(System.DateTime,System.Int32)">
             <summary>
             Returns the DateTime resulting from adding the given number of
             months to the specified DateTime. The result is computed by incrementing
             (or decrementing) the year and month parts of the specified DateTime by
             value months, and, if required, adjusting the day part of the
             resulting date downwards to the last day of the resulting month in the
             resulting year. The time-of-day part of the result is the same as the
             time-of-day part of the specified DateTime.
            
             In more precise terms, considering the specified DateTime to be of the
             form y / m / d + t, where y is the
             year, m is the month, d is the day, and t is the
             time-of-day, the result is y1 / m1 / d1 + t,
             where y1 and m1 are computed by adding value months
             to y and m, and d1 is the largest value less than
             or equal to d that denotes a valid day in month m1 of year
             y1.
             </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.AddYears(System.DateTime,System.Int32)">
            <summary>
            Returns the DateTime resulting from adding the given number of
            years to the specified DateTime. The result is computed by incrementing
            (or decrementing) the year part of the specified DateTime by value
            years. If the month and day of the specified DateTime is 2/29, and if the
            resulting year is not a leap year, the month and day of the resulting
            DateTime becomes 2/28. Otherwise, the month, day, and time-of-day
            parts of the result are the same as those of the specified DateTime.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetDayOfMonth(System.DateTime)">
            <summary>
            Returns the day-of-month part of the specified DateTime. The returned
            value is an integer between 1 and 31.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetDayOfWeek(System.DateTime)">
            <summary>
            Returns the day-of-week part of the specified DateTime. The returned value
            is an integer between 0 and 6, where 0 indicates Sunday, 1 indicates
            Monday, 2 indicates Tuesday, 3 indicates Wednesday, 4 indicates
            Thursday, 5 indicates Friday, and 6 indicates Saturday.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetDayOfYear(System.DateTime)">
            <summary>
            Returns the day-of-year part of the specified DateTime. The returned value
            is an integer between 1 and 366.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetDaysInMonth(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the month given by the year and
            month arguments.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetDaysInYear(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the year given by the year argument for
            the current era.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetMonth(System.DateTime)">
            <summary>
            Returns the month part of the specified DateTime.
            The returned value is an integer between 1 and 12.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetMonthsInYear(System.Int32,System.Int32)">
            <summary>
            Returns the number of months in the specified year and era.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetYear(System.DateTime)">
            <summary>
            Returns the year part of the specified DateTime. The returned value is an
            integer between 1 and 9999.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.IsLeapDay(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether a given day in the specified era is a leap day. This method returns true if
            the date is a leap day, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.GetLeapMonth(System.Int32,System.Int32)">
            <summary>
            Returns the leap month in a calendar year of the specified era.
            This method returns 0 if this calendar does not have leap month, or
            this year is not a leap year.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.IsLeapMonth(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether a given month in the specified era is a leap month.
            This method returns true if month is a leap month, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.IsLeapYear(System.Int32,System.Int32)">
            <summary>
            Checks whether a given year in the specified era is a leap year. This method returns true if
            year is a leap year, or false if not.
            </summary>
        </member>
        <member name="M:System.Globalization.GregorianCalendar.ToDateTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the date and time converted to a DateTime value.
            Throws an exception if the n-tuple is invalid.
            </summary>
        </member>
        <member name="T:System.Globalization.HebrewCalendar">
             <remarks>
             Rules for the Hebrew calendar:
               - The Hebrew calendar is both a Lunar (months) and Solar (years)
                   calendar, but allows for a week of seven days.
               - Days begin at sunset.
               - Leap Years occur in the 3, 6, 8, 11, 14, 17, &amp; 19th years of a
                   19-year cycle.  Year = leap iff ((7y+1) mod 19 &lt; 7).
               - There are 12 months in a common year and 13 months in a leap year.
               - In a common year, the 6th month, Adar, has 29 days.  In a leap
                   year, the 6th month, Adar I, has 30 days and the leap month,
                   Adar II, has 29 days.
               - Common years have 353-355 days.  Leap years have 383-385 days.
               - The Hebrew new year (Rosh HaShanah) begins on the 1st of Tishri,
                   the 7th month in the list below.
                   - The new year may not begin on Sunday, Wednesday, or Friday.
                   - If the new year would fall on a Tuesday and the conjunction of
                       the following year were at midday or later, the new year is
                       delayed until Thursday.
                   - If the new year would fall on a Monday after a leap year, the
                       new year is delayed until Tuesday.
               - The length of the 8th and 9th months vary from year to year,
                   depending on the overall length of the year.
                   - The length of a year is determined by the dates of the new
                       years (Tishri 1) preceding and following the year in question.
                   - The 2th month is long (30 days) if the year has 355 or 385 days.
                   - The 3th month is short (29 days) if the year has 353 or 383 days.
               - The Hebrew months are:
                   1.  Tishri        (30 days)
                   2.  Heshvan       (29 or 30 days)
                   3.  Kislev        (29 or 30 days)
                   4.  Teveth        (29 days)
                   5.  Shevat        (30 days)
                   6.  Adar I        (30 days)
                   7.  Adar {II}     (29 days, this only exists if that year is a leap year)
                   8.  Nisan         (30 days)
                   9.  Iyyar         (29 days)
                   10. Sivan         (30 days)
                   11. Tammuz        (29 days)
                   12. Av            (30 days)
                   13. Elul          (29 days)
             Calendar support range:
                 Calendar    Minimum     Maximum
                 ==========  ==========  ==========
                 Gregorian   1583/01/01  2239/09/29
                 Hebrew      5343/04/07  5999/13/29
            
             Includes CHebrew implemetation;i.e All the code necessary for converting
             Gregorian to Hebrew Lunar from 1583 to 2239.
             </remarks>
        </member>
        <member name="M:System.Globalization.HebrewCalendar.CheckHebrewMonthValue(System.Int32,System.Int32,System.Int32)">
            <summary>
            Check if the Hebrew month value is valid.
            </summary>
            <remarks>
            Call CheckHebrewYearValue() before calling this to verify the year value is supported.
            </remarks>
        </member>
        <member name="M:System.Globalization.HebrewCalendar.CheckHebrewDayValue(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Check if the Hebrew day value is valid.
            </summary>
            <remarks>
            Call CheckHebrewYearValue()/CheckHebrewMonthValue() before calling this to verify the year/month values are valid.
            </remarks>
        </member>
        <member name="M:System.Globalization.HebrewCalendar.GetLunarMonthDay(System.Int32,System.Globalization.HebrewCalendar.DateBuffer)">
            <summary>
            Using the Hebrew table (HebrewTable) to get the Hebrew month/day value for Gregorian January 1st
            in a given Gregorian year.
            Greogrian January 1st falls usually in Tevet (4th month). Tevet has always 29 days.
            That's why, there no nead to specify the lunar month in the table.  There are exceptions, and these
            are coded by giving numbers above 29 and below 1.
            Actual decoding is takenig place in the switch statement below.
            </summary>
            <returns>
            The Hebrew year type. The value is from 1 to 6.
            normal years : 1 = 353 days   2 = 354 days   3 = 355 days.
            Leap years   : 4 = 383        5   384        6 = 385 days.
            </returns>
        </member>
        <member name="M:System.Globalization.HebrewCalendar.GetDatePart(System.Int64,System.Int32)">
            <summary>
            Returns a given date part of this DateTime. This method is used
            to compute the year, day-of-year, month, or day part.
            </summary>
        </member>
        <member name="M:System.Globalization.HebrewCalendar.GetDayDifference(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            (month1, day1) - (month2, day2)
            </summary>
        </member>
        <member name="M:System.Globalization.HebrewCalendar.HebrewToGregorian(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             Convert Hebrew date to Gregorian date.
              The algorithm is like this:
                 The hebrew year has an offset to the Gregorian year, so we can guess the Gregorian year for
                 the specified Hebrew year.  That is, GreogrianYear = HebrewYear - FirstHebrewYearOf1AD.
            
                 From the Gregorian year and HebrewTable, we can get the Hebrew month/day value
                 of the Gregorian date January 1st.  Let's call this month/day value [hebrewDateForJan1]
            
                 If the requested Hebrew month/day is less than [hebrewDateForJan1], we know the result
                 Gregorian date falls in previous year.  So we decrease the Gregorian year value, and
                 retrieve the Hebrew month/day value of the Gregorian date january 1st again.
            
                 Now, we get the answer of the Gregorian year.
            
                 The next step is to get the number of days between the requested Hebrew month/day
                 and [hebrewDateForJan1].  When we get that, we can create the DateTime by adding/subtracting
                 the ticks value of the number of days.
             </summary>
        </member>
        <member name="T:System.Globalization.HijriCalendar">
             <remarks>
             Rules for the Hijri calendar:
               - The Hijri calendar is a strictly Lunar calendar.
               - Days begin at sunset.
               - Islamic Year 1 (Muharram 1, 1 A.H.) is equivalent to absolute date
                   227015 (Friday, July 16, 622 C.E. - Julian).
               - Leap Years occur in the 2, 5, 7, 10, 13, 16, 18, 21, 24, 26, &amp; 29th
                   years of a 30-year cycle.  Year = leap iff ((11y+14) mod 30 &lt; 11).
               - There are 12 months which contain alternately 30 and 29 days.
               - The 12th month, Dhu al-Hijjah, contains 30 days instead of 29 days
                   in a leap year.
               - Common years have 354 days.  Leap years have 355 days.
               - There are 10,631 days in a 30-year cycle.
               - The Islamic months are:
                   1.  Muharram   (30 days)     7.  Rajab          (30 days)
                   2.  Safar      (29 days)     8.  Sha'ban        (29 days)
                   3.  Rabi I     (30 days)     9.  Ramadan        (30 days)
                   4.  Rabi II    (29 days)     10. Shawwal        (29 days)
                   5.  Jumada I   (30 days)     11. Dhu al-Qada    (30 days)
                   6.  Jumada II  (29 days)     12. Dhu al-Hijjah  (29 days) {30}
            
             NOTENOTE
                 The calculation of the HijriCalendar is based on the absolute date.  And the
                 absolute date means the number of days from January 1st, 1 A.D.
                 Therefore, we do not support the days before the January 1st, 1 A.D.
            
             Calendar support range:
                 Calendar    Minimum     Maximum
                 ==========  ==========  ==========
                 Gregorian   0622/07/18   9999/12/31
                 Hijri       0001/01/01   9666/04/03
             </remarks>
        </member>
        <member name="M:System.Globalization.HijriCalendar.GetDatePart(System.Int64,System.Int32)">
            <summary>
            First, we get the absolute date (the number of days from January 1st, 1 A.C) for the given ticks.
            Use the formula (((AbsoluteDate - 227013) * 30) / 10631) + 1, we can a rough value for the Hijri year.
            In order to get the exact Hijri year, we compare the exact absolute date for HijriYear and (HijriYear + 1).
            From here, we can get the correct Hijri year.
            </summary>
        </member>
        <member name="M:System.Globalization.IdnMapping.CheckInvalidIdnCharacters(System.Char*,System.Int32,System.UInt32,System.String)">
             <summary>
             ICU doesn't check for invalid characters unless the STD3 rules option
             is enabled.
            
             To match Windows behavior, we walk the string ourselves looking for these
             bad characters so we can continue to throw ArgumentException in these cases.
             </summary>
        </member>
        <member name="T:System.Globalization.JapaneseCalendar">
             <summary>
             JapaneseCalendar is based on Gregorian calendar.  The month and day values are the same as
             Gregorian calendar.  However, the year value is an offset to the Gregorian
             year based on the era.
            
             This system is adopted by Emperor Meiji in 1868. The year value is counted based on the reign of an emperor,
             and the era begins on the day an emperor ascends the throne and continues until his death.
             The era changes at 12:00AM.
            
             For example, the current era is Reiwa.  It started on 2019/5/1 A.D.  Therefore, Gregorian year 2019 is also Reiwa 1st.
             2019/5/1 A.D. is also Reiwa 1st 5/1.
            
             Any date in the year during which era is changed can be reckoned in either era.  For example,
             2019/1/1 can be 1/1 Reiwa 1st year or 1/1 Heisei 31st year.
            
             Note:
              The DateTime can be represented by the JapaneseCalendar are limited to two factors:
                  1. The min value and max value of DateTime class.
                  2. The available era information.
             </summary>
             <remarks>
             Calendar support range:
                 Calendar    Minimum     Maximum
                 ==========  ==========  ==========
                 Gregorian   1868/09/08  9999/12/31
                 Japanese    Meiji 01/01 Reiwa 7981/12/31
             </remarks>
        </member>
        <member name="M:System.Globalization.JapaneseCalendar.ToFourDigitYear(System.Int32)">
            <summary>
            For Japanese calendar, four digit year is not used. Few emperors will live for more than one hundred years.
            Therefore, for any two digit number, we just return the original number.
            </summary>
        </member>
        <member name="M:System.Globalization.JapaneseCalendar.EraNames">
            <summary>
            Return the various era strings
            Note: The arrays are backwards of the eras
            </summary>
        </member>
        <member name="T:System.Globalization.JapaneseLunisolarCalendar">
            <remarks>
            Calendar support range:
                Calendar               Minimum             Maximum
                ==========             ==========          ==========
                Gregorian              1960/01/28          2050/01/22
                JapaneseLunisolar      1960/01/01          2049/12/29
            </remarks>
        </member>
        <member name="M:System.Globalization.JapaneseLunisolarCalendar.TrimEras(System.Globalization.EraInfo[])">
            <summary>
            Trim off the eras that are before our date range
            </summary>
        </member>
        <member name="T:System.Globalization.JulianCalendar">
            <summary>
            This class implements the Julian calendar. In 48 B.C. Julius Caesar
            ordered a calendar reform, and this calendar is called Julian calendar.
            It consisted of a solar year of twelve months and of 365 days with an
            extra day every fourth year.
            </summary>
            <remarks>
            Calendar support range:
                Calendar    Minimum     Maximum
                ==========  ==========  ==========
                Gregorian   0001/01/01   9999/12/31
                Julia       0001/01/03   9999/10/19
            </remarks>
        </member>
        <member name="M:System.Globalization.JulianCalendar.CheckDayRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Check for if the day value is valid.
            </summary>
            <remarks>
            Before calling this method, call CheckYearEraRange()/CheckMonthRange() to make
            sure year/month values are correct.
            </remarks>
        </member>
        <member name="M:System.Globalization.JulianCalendar.GetDatePart(System.Int64,System.Int32)">
            <summary>
            Returns a given date part of this DateTime. This method is used
            to compute the year, day-of-year, month, or day part.
            </summary>
        </member>
        <member name="M:System.Globalization.JulianCalendar.DateToTicks(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the tick count corresponding to the given year, month, and day.
            </summary>
        </member>
        <member name="T:System.Globalization.KoreanCalendar">
             <summary>
             Korean calendar is based on the Gregorian calendar.  And the year is an offset to Gregorian calendar.
             That is,
                  Korean year = Gregorian year + 2333.  So 2000/01/01 A.D. is Korean 4333/01/01
            
             0001/1/1 A.D. is Korean year 2334.
             </summary>
             <remarks>
             Calendar support range:
                 Calendar    Minimum     Maximum
                 ==========  ==========  ==========
                 Gregorian   0001/01/01   9999/12/31
                 Korean      2334/01/01  12332/12/31
             </remarks>
        </member>
        <member name="T:System.Globalization.KoreanLunisolarCalendar">
            <remarks>
            Calendar support range:
                Calendar           Minimum     Maximum
                ==========         ==========  ==========
                Gregorian          918/02/19   2051/02/10
                KoreanLunisolar    918/01/01   2050/13/29
            </remarks>
        </member>
        <member name="T:System.Globalization.NumberFormatInfo">
             <remarks>
             Property             Default Description
             PositiveSign           '+'   Character used to indicate positive values.
             NegativeSign           '-'   Character used to indicate negative values.
             NumberDecimalSeparator '.'   The character used as the decimal separator.
             NumberGroupSeparator   ','   The character used to separate groups of
                                          digits to the left of the decimal point.
             NumberDecimalDigits    2     The default number of decimal places.
             NumberGroupSizes       3     The number of digits in each group to the
                                          left of the decimal point.
             NaNSymbol             "NaN"  The string used to represent NaN values.
             PositiveInfinitySymbol"Infinity" The string used to represent positive
                                          infinities.
             NegativeInfinitySymbol"-Infinity" The string used to represent negative
                                          infinities.
            
             Property                  Default  Description
             CurrencyDecimalSeparator  '.'      The character used as the decimal
                                                separator.
             CurrencyGroupSeparator    ','      The character used to separate groups
                                                of digits to the left of the decimal
                                                point.
             CurrencyDecimalDigits     2        The default number of decimal places.
             CurrencyGroupSizes        3        The number of digits in each group to
                                                the left of the decimal point.
             CurrencyPositivePattern   0        The format of positive values.
             CurrencyNegativePattern   0        The format of negative values.
             CurrencySymbol            "$"      String used as local monetary symbol.
             </remarks>
        </member>
        <member name="P:System.Globalization.NumberFormatInfo.InvariantInfo">
            <summary>
            Returns a default NumberFormatInfo that will be universally
            supported and constant irrespective of the current culture.
            Used by FromString methods.
            </summary>
        </member>
        <member name="M:System.Globalization.NumberFormatInfo.CheckGroupSize(System.String,System.Int32[])">
            <summary>
            Check the values of the groupSize array.
            Every element in the groupSize array should be between 1 and 9
            except the last element could be zero.
            </summary>
        </member>
        <member name="P:System.Globalization.NumberFormatInfo.CurrentInfo">
            <summary>
            Returns the current culture's NumberFormatInfo. Used by Parse methods.
            </summary>
        </member>
        <member name="T:System.Globalization.NumberStyles">
            <summary>
            Contains valid formats for Numbers recognized by the Number
            class' parsing code.
            </summary>
        </member>
        <member name="F:System.Globalization.NumberStyles.AllowLeadingWhite">
            <summary>
            Bit flag indicating that leading whitespace is allowed. Character values
            0x0009, 0x000A, 0x000B, 0x000C, 0x000D, and 0x0020 are considered to be
            whitespace.
            </summary>
        </member>
        <member name="F:System.Globalization.NumberStyles.AllowTrailingWhite">
            <summary>
            Bitflag indicating trailing whitespace is allowed.
            </summary>
        </member>
        <member name="F:System.Globalization.NumberStyles.AllowLeadingSign">
            <summary>
            Can the number start with a sign char specified by
            NumberFormatInfo.PositiveSign and NumberFormatInfo.NegativeSign
            </summary>
        </member>
        <member name="F:System.Globalization.NumberStyles.AllowTrailingSign">
            <summary>
            Allow the number to end with a sign char
            </summary>
        </member>
        <member name="F:System.Globalization.NumberStyles.AllowParentheses">
            <summary>
            Allow the number to be enclosed in parens
            </summary>
        </member>
        <member name="T:System.Globalization.PersianCalendar">
            <summary>
            Modern Persian calendar is a solar observation based calendar. Each new year begins on the day when the vernal equinox occurs before noon.
            The epoch is the date of the vernal equinox prior to the epoch of the Islamic calendar (March 19, 622 Julian or March 22, 622 Gregorian)
            There is no Persian year 0. Ordinary years have 365 days. Leap years have 366 days with the last month (Esfand) gaining the extra day.
            </summary>
            <remarks>
             Calendar support range:
                 Calendar    Minimum     Maximum
                 ==========  ==========  ==========
                 Gregorian   0622/03/22   9999/12/31
                 Persian     0001/01/01   9378/10/13
            </remarks>
        </member>
        <member name="T:System.Globalization.RegionInfo">
            <summary>
            This class represents settings specified by de jure or de facto
            standards for a particular country/region. In contrast to
            CultureInfo, the RegionInfo does not represent preferences of the
            user and does not depend on the user's language or culture.
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.CurrentRegion">
            <summary>
            This instance provides methods based on the current user settings.
            These settings are volatile and may change over the lifetime of the
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.Name">
            <summary>
            Returns the name of the region (ie: en-US)
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.EnglishName">
            <summary>
            Returns the name of the region in English. (ie: United States)
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.DisplayName">
            <summary>
            Returns the display name (localized) of the region. (ie: United States
            if the current UI language is en-US)
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.NativeName">
            <summary>
             Returns the native name of the region. (ie: Deutschland)
             WARNING: You need a full locale name for this to make sense.
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.TwoLetterISORegionName">
            <summary>
            Returns the two letter ISO region name (ie: US)
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.ThreeLetterISORegionName">
            <summary>
            Returns the three letter ISO region name (ie: USA)
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.ThreeLetterWindowsRegionName">
            <summary>
            Returns the three letter windows region name (ie: USA)
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.IsMetric">
            <summary>
            Returns true if this region uses the metric measurement system
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.CurrencyEnglishName">
            <summary>
            English name for this region's currency, ie: Swiss Franc
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.CurrencyNativeName">
            <summary>
            Native name for this region's currency, ie: Schweizer Franken
            WARNING: You need a full locale name for this to make sense.
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.CurrencySymbol">
            <summary>
            Currency Symbol for this locale, ie: Fr. or $
            </summary>
        </member>
        <member name="P:System.Globalization.RegionInfo.ISOCurrencySymbol">
            <summary>
            ISO Currency Symbol for this locale, ie: CHF
            </summary>
        </member>
        <member name="M:System.Globalization.RegionInfo.Equals(System.Object)">
            <summary>
            Implements Object.Equals().  Returns a boolean indicating whether
            or not object refers to the same RegionInfo as the current instance.
            RegionInfos are considered equal if and only if they have the same name
            (ie: en-US)
            </summary>
        </member>
        <member name="T:System.Globalization.SortKey">
            <summary>
            This class implements a set of methods for retrieving
            </summary>
        </member>
        <member name="M:System.Globalization.SortKey.#ctor(System.String,System.String,System.Globalization.CompareOptions,System.Byte[])">
            <summary>
            The following constructor is designed to be called from CompareInfo to get the 
            the sort key of specific string for synthetic culture
            </summary>
        </member>
        <member name="P:System.Globalization.SortKey.OriginalString">
            <summary>
            Returns the original string used to create the current instance
            of SortKey.
            </summary>
        </member>
        <member name="P:System.Globalization.SortKey.KeyData">
            <summary>
            Returns a byte array representing the current instance of the
            sort key.
            </summary>
        </member>
        <member name="M:System.Globalization.SortKey.Compare(System.Globalization.SortKey,System.Globalization.SortKey)">
            <summary>
            Compares the two sort keys.  Returns 0 if the two sort keys are
            equal, a number less than 0 if sortkey1 is less than sortkey2,
            and a number greater than 0 if sortkey1 is greater than sortkey2.
            </summary>
        </member>
        <member name="T:System.Globalization.StringInfo">
            <summary>
            This class defines behaviors specific to a writing system.
            A writing system is the collection of scripts and orthographic rules
            required to represent a language as text.
            </summary>
        </member>
        <member name="P:System.Globalization.StringInfo.Indexes">
            <summary>
            Our zero-based array of index values into the string. Initialize if
            our private array is not yet, in fact, initialized.
            </summary>
        </member>
        <member name="M:System.Globalization.StringInfo.GetCurrentTextElementLen(System.String,System.Int32,System.Int32,System.Globalization.UnicodeCategory@,System.Int32@)">
             <summary>
             Get the code point count of the current text element.
            
             A combining class is defined as:
                  A character/surrogate that has the following Unicode category:
                  * NonSpacingMark (e.g. U+0300 COMBINING GRAVE ACCENT)
                  * SpacingCombiningMark (e.g. U+ 0903 DEVANGARI SIGN VISARGA)
                  * EnclosingMark (e.g. U+20DD COMBINING ENCLOSING CIRCLE)
            
             In the context of GetNextTextElement() and ParseCombiningCharacters(), a text element is defined as:
              1. If a character/surrogate is in the following category, it is a text element.
                 It can NOT further combine with characters in the combinging class to form a text element.
                  * one of the Unicode category in the combinging class
                  * UnicodeCategory.Format
                  * UnicodeCateogry.Control
                  * UnicodeCategory.OtherNotAssigned
              2. Otherwise, the character/surrogate can be combined with characters in the combinging class to form a text element.
             </summary>
             <returns>The length of the current text element</returns>
        </member>
        <member name="M:System.Globalization.StringInfo.GetNextTextElement(System.String,System.Int32)">
            <summary>
            Returns the str containing the next text element in str starting at
            index index. If index is not supplied, then it will start at the beginning
            of str. It recognizes a base character plus one or more combining
            characters or a properly formed surrogate pair as a text element.
            See also the ParseCombiningCharacters() and the ParseSurrogates() methods.
            </summary>
        </member>
        <member name="M:System.Globalization.StringInfo.ParseCombiningCharacters(System.String)">
            <summary>
            Returns the indices of each base character or properly formed surrogate
            pair  within the str. It recognizes a base character plus one or more
            combining characters or a properly formed surrogate pair as a text
            element and returns the index of the base character or high surrogate.
            Each index is the beginning of a text element within a str. The length
            of each element is easily computed as the difference between successive
            indices. The length of the array will always be less than or equal to
            the length of the str. For example, given the str
            \u4f00\u302a\ud800\udc00\u4f01, this method would return the indices:
            0, 2, 4.
            </summary>
        </member>
        <member name="T:System.Globalization.TaiwanCalendar">
            <summary>
            Taiwan calendar is based on the Gregorian calendar.  And the year is an offset to Gregorian calendar.
            That is,
                 Taiwan year = Gregorian year - 1911.  So 1912/01/01 A.D. is Taiwan 1/01/01
            </summary>
            <remarks>
             Calendar support range:
                 Calendar    Minimum     Maximum
                 ==========  ==========  ==========
                 Gregorian   1912/01/01  9999/12/31
                 Taiwan      01/01/01    8088/12/31
            </remarks>
        </member>
        <member name="M:System.Globalization.TaiwanCalendar.ToFourDigitYear(System.Int32)">
            <summary>
            For Taiwan calendar, four digit year is not used.
            Therefore, for any two digit number, we just return the original number.
            </summary>
        </member>
        <member name="T:System.Globalization.TaiwanLunisolarCalendar">
            <remarks>
            Calendar support range:
                Calendar            Minimum     Maximum
                ==========          ==========  ==========
                Gregorian           1912/02/18  2051/02/10
                TaiwanLunisolar     1912/01/01  2050/13/29
            </remarks>
        </member>
        <member name="T:System.Globalization.TextInfo">
            <summary>
            This Class defines behaviors specific to a writing system.
            A writing system is the collection of scripts and orthographic rules
            required to represent a language as text.
            </summary>
        </member>
        <member name="M:System.Globalization.TextInfo.ReadOnly(System.Globalization.TextInfo)">
            <summary>
            Create a cloned readonly instance or return the input one if it is
            readonly.
            </summary>
        </member>
        <member name="P:System.Globalization.TextInfo.ListSeparator">
            <summary>
            Returns the string used to separate items in a list.
            </summary>
        </member>
        <member name="M:System.Globalization.TextInfo.ToLower(System.Char)">
            <summary>
            Converts the character or string to lower case.  Certain locales
            have different casing semantics from the file systems in Win32.
            </summary>
        </member>
        <member name="M:System.Globalization.TextInfo.ToUpper(System.Char)">
            <summary>
            Converts the character or string to upper case.  Certain locales
            have different casing semantics from the file systems in Win32.
            </summary>
        </member>
        <member name="P:System.Globalization.TextInfo.IsRightToLeft">
            <summary>
            Returns true if the dominant direction of text and UI such as the
            relative position of buttons and scroll bars
            </summary>
        </member>
        <member name="M:System.Globalization.TextInfo.ToTitleCase(System.String)">
             <summary>
             Titlecasing refers to a casing practice wherein the first letter of a word is an uppercase letter
             and the rest of the letters are lowercase.  The choice of which words to titlecase in headings
             and titles is dependent on language and local conventions.  For example, "The Merry Wives of Windor"
             is the appropriate titlecasing of that play's name in English, with the word "of" not titlecased.
             In German, however, the title is "Die lustigen Weiber von Windsor," and both "lustigen" and "von"
             are not titlecased.  In French even fewer words are titlecased: "Les joyeuses commeres de Windsor."
            
             Moreover, the determination of what actually constitutes a word is language dependent, and this can
             influence which letter or letters of a "word" are uppercased when titlecasing strings.  For example
             "l'arbre" is considered two words in French, whereas "can't" is considered one word in English.
             </summary>
        </member>
        <member name="T:System.Globalization.ThaiBuddhistCalendar">
            <summary>
            ThaiBuddhistCalendar is based on Gregorian calendar.
            Its year value has an offset to the Gregorain calendar.
            </summary>
            <remarks>
            Calendar support range:
                Calendar    Minimum     Maximum
                ==========  ==========  ==========
                Gregorian   0001/01/01   9999/12/31
                Thai        0544/01/01  10542/12/31
            </remarks>
        </member>
        <member name="M:System.Globalization.TimeSpanFormat.Format(System.TimeSpan,System.String,System.IFormatProvider)">
            <summary>Main method called from TimeSpan.ToString.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanFormat.TryFormat(System.TimeSpan,System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>Main method called from TimeSpan.TryFormat.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanFormat.FormatCustomized(System.TimeSpan,System.ReadOnlySpan{System.Char},System.Globalization.DateTimeFormatInfo,System.Text.StringBuilder)">
            <summary>Format the TimeSpan instance using the specified format.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanTokenizer.GetNextToken">
            <summary>Returns the next token in the input string</summary>
            <remarks>Used by the parsing routines that operate on standard-formats.</remarks>
        </member>
        <member name="T:System.Globalization.TimeSpanParse.TimeSpanRawInfo">
            <summary>Stores intermediary parsing state for the standard formats.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanRawInfo.FullMatch(System.Globalization.TimeSpanFormat.FormatLiterals)">
            <summary>DHMSF (all values matched)</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanRawInfo.FullDMatch(System.Globalization.TimeSpanFormat.FormatLiterals)">
            <summary>D (no hours, minutes, seconds, or fractions)</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanRawInfo.FullHMMatch(System.Globalization.TimeSpanFormat.FormatLiterals)">
            <summary>HM (no days, seconds, or fractions)</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanRawInfo.FullDHMMatch(System.Globalization.TimeSpanFormat.FormatLiterals)">
            <summary>DHM (no seconds or fraction)</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanRawInfo.FullHMSMatch(System.Globalization.TimeSpanFormat.FormatLiterals)">
            <summary>HMS (no days or fraction)</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanRawInfo.FullDHMSMatch(System.Globalization.TimeSpanFormat.FormatLiterals)">
            <summary>DHMS (no fraction)</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TimeSpanRawInfo.FullHMSFMatch(System.Globalization.TimeSpanFormat.FormatLiterals)">
            <summary>HMSF (no days)</summary>
        </member>
        <member name="T:System.Globalization.TimeSpanParse.TimeSpanResult">
            <summary>Store the result of the parsing.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TryParseTimeSpan(System.ReadOnlySpan{System.Char},System.Globalization.TimeSpanParse.TimeSpanStandardStyles,System.IFormatProvider,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Common private Parse method called by both Parse and TryParse.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.ProcessTerminalState(System.Globalization.TimeSpanParse.TimeSpanRawInfo@,System.Globalization.TimeSpanParse.TimeSpanStandardStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>
            Validate the terminal state of a standard format parse.
            Sets result.parsedTimeSpan on success.
            Calculates the resultant TimeSpan from the TimeSpanRawInfo.
            </summary>
            <remarks>
            try => +InvariantPattern, -InvariantPattern, +LocalizedPattern, -LocalizedPattern
            1) Verify Start matches
            2) Verify End matches
            3) 1 number  => d
               2 numbers => h:m
               3 numbers => h:m:s | d.h:m | h:m:.f
               4 numbers => h:m:s.f | d.h:m:s | d.h:m:.f
               5 numbers => d.h:m:s.f
            </remarks>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.ProcessTerminal_DHMSF(System.Globalization.TimeSpanParse.TimeSpanRawInfo@,System.Globalization.TimeSpanParse.TimeSpanStandardStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Validate the 5-number "Days.Hours:Minutes:Seconds.Fraction" terminal case.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.ProcessTerminal_HMS_F_D(System.Globalization.TimeSpanParse.TimeSpanRawInfo@,System.Globalization.TimeSpanParse.TimeSpanStandardStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>
            Validate the ambiguous 4-number "Hours:Minutes:Seconds.Fraction", "Days.Hours:Minutes:Seconds",
            or "Days.Hours:Minutes:.Fraction" terminal case.
            </summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.ProcessTerminal_HM_S_D(System.Globalization.TimeSpanParse.TimeSpanRawInfo@,System.Globalization.TimeSpanParse.TimeSpanStandardStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Validate the ambiguous 3-number "Hours:Minutes:Seconds", "Days.Hours:Minutes", or "Hours:Minutes:.Fraction" terminal case.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.ProcessTerminal_HM(System.Globalization.TimeSpanParse.TimeSpanRawInfo@,System.Globalization.TimeSpanParse.TimeSpanStandardStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Validate the 2-number "Hours:Minutes" terminal case.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.ProcessTerminal_D(System.Globalization.TimeSpanParse.TimeSpanRawInfo@,System.Globalization.TimeSpanParse.TimeSpanStandardStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Validate the 1-number "Days" terminal case.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TryParseExactTimeSpan(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.TimeSpanStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Common private ParseExact method called by both ParseExact and TryParseExact.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TryParseByFormat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Globalization.TimeSpanStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Parse the TimeSpan instance using the specified format.  Used by TryParseExactTimeSpan.</summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TryParseTimeSpanConstant(System.ReadOnlySpan{System.Char},System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>
            Parses the "c" (constant) format.  This code is 100% identical to the non-globalized v1.0-v3.5 TimeSpan.Parse() routine
            and exists for performance/appcompat with legacy callers who cannot move onto the globalized Parse overloads.
            </summary>
        </member>
        <member name="M:System.Globalization.TimeSpanParse.TryParseExactMultipleTimeSpan(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.TimeSpanStyles,System.Globalization.TimeSpanParse.TimeSpanResult@)">
            <summary>Common private ParseExactMultiple method called by both ParseExactMultiple and TryParseExactMultiple.</summary>
        </member>
        <member name="T:System.Globalization.UmAlQuraCalendar">
            <remarks>
            Calendar support range:
                Calendar    Minimum     Maximum
                ==========  ==========  ==========
                Gregorian   1900/04/30   2077/05/13
                UmAlQura    1318/01/01   1500/12/30
            </remarks>
        </member>
        <member name="M:System.Globalization.UmAlQuraCalendar.GetDatePart(System.DateTime,System.Int32)">
            <summary>
            First, we get the absolute date (the number of days from January 1st, 1 A.C) for the given ticks.
            Use the formula (((AbsoluteDate - 226894) * 33) / (33 * 365 + 8)) + 1, we can a rough value for the UmAlQura year.
            In order to get the exact UmAlQura year, we compare the exact absolute date for UmAlQuraYear and (UmAlQuraYear + 1).
            From here, we can get the correct UmAlQura year.
            </summary>
        </member>
        <member name="M:System.Globalization.Normalization.HasInvalidUnicodeSequence(System.String)">
             <summary>
             ICU does not signal an error during normalization if the input string has invalid unicode,
             unlike Windows (which uses the ERROR_NO_UNICODE_TRANSLATION error value to signal an error).
            
             We walk the string ourselves looking for these bad sequences so we can continue to throw
             ArgumentException in these cases.
             </summary>
        </member>
        <member name="T:System.IO.Stream.SynchronousAsyncResult">
            <summary>Used as the IAsyncResult object when using asynchronous IO methods on the base Stream class.</summary>
        </member>
        <member name="M:System.IO.BinaryReader.Close">
            <remarks>
            Override Dispose(bool) instead of Close(). This API exists for compatibility purposes.
            </remarks>
        </member>
        <member name="T:System.IO.Error">
            <summary>
                Provides centralized methods for creating exceptions for System.IO.FileSystem.
            </summary>
        </member>
        <member name="T:System.IO.FileStream">
            <summary>Provides an implementation of a file stream for Unix files.</summary>
        </member>
        <member name="F:System.IO.FileStream._access">
            <summary>Whether the file is opened for reading, writing, or both.</summary>
        </member>
        <member name="F:System.IO.FileStream._path">
            <summary>The path to the opened file.</summary>
        </member>
        <member name="F:System.IO.FileStream._readPos">
            <summary>The next available byte to be read from the _buffer.</summary>
        </member>
        <member name="F:System.IO.FileStream._readLength">
            <summary>The number of valid bytes in _buffer.</summary>
        </member>
        <member name="F:System.IO.FileStream._writePos">
            <summary>The next location in which a write should occur to the buffer.</summary>
        </member>
        <member name="F:System.IO.FileStream._useAsyncIO">
            <summary>
            Whether asynchronous read/write/flush operations should be performed using async I/O.
            On Windows FileOptions.Asynchronous controls how the file handle is configured, 
            and then as a result how operations are issued against that file handle.  On Unix, 
            there isn't any distinction around how file descriptors are created for async vs 
            sync, but we still differentiate how the operations are issued in order to provide
            similar behavioral semantics and performance characteristics as on Windows.  On
            Windows, if non-async, async read/write requests just delegate to the base stream,
            and no attempt is made to synchronize between sync and async operations on the stream;
            if async, then async read/write requests are implemented specially, and sync read/write
            requests are coordinated with async ones by implementing the sync ones over the async
            ones.  On Unix, we do something similar.  If non-async, async read/write requests just
            delegate to the base stream, and no attempt is made to synchronize.  If async, we use
            a semaphore to coordinate both sync and async operations.
            </summary>
        </member>
        <member name="F:System.IO.FileStream._lastSynchronouslyCompletedTask">
            <summary>cached task for read ops that complete synchronously</summary>
        </member>
        <member name="F:System.IO.FileStream._filePosition">
            <summary>
            Currently cached position in the stream.  This should always mirror the underlying file's actual position,
            and should only ever be out of sync if another stream with access to this same file manipulates it, at which
            point we attempt to error out.
            </summary>
        </member>
        <member name="F:System.IO.FileStream._exposedHandle">
            <summary>Whether the file stream's handle has been exposed.</summary>
        </member>
        <member name="F:System.IO.FileStream.s_cachedSerializationSwitch">
            <summary>Caches whether Serialization Guard has been disabled for file writes</summary>
        </member>
        <member name="M:System.IO.FileStream.Flush">
            <summary>
            Clears buffers for this stream and causes any buffered data to be written to the file.
            </summary>
        </member>
        <member name="M:System.IO.FileStream.Flush(System.Boolean)">
            <summary>
            Clears buffers for this stream, and if <param name="flushToDisk"/> is true, 
            causes any buffered data to be written to the file.
            </summary>
        </member>
        <member name="P:System.IO.FileStream.CanRead">
            <summary>Gets a value indicating whether the current stream supports reading.</summary>
        </member>
        <member name="P:System.IO.FileStream.CanWrite">
            <summary>Gets a value indicating whether the current stream supports writing.</summary>
        </member>
        <member name="M:System.IO.FileStream.ValidateReadWriteArgs(System.Byte[],System.Int32,System.Int32)">
            <summary>Validates arguments to Read and Write and throws resulting exceptions.</summary>
            <param name="array">The buffer to read from or write to.</param>
            <param name="offset">The zero-based offset into the array.</param>
            <param name="count">The maximum number of bytes to read or write.</param>
        </member>
        <member name="M:System.IO.FileStream.SetLength(System.Int64)">
            <summary>Sets the length of this stream to the given value.</summary>
            <param name="value">The new length of the stream.</param>
        </member>
        <member name="P:System.IO.FileStream.Name">
            <summary>Gets the path that was passed to the constructor.</summary>
        </member>
        <member name="P:System.IO.FileStream.IsAsync">
            <summary>Gets a value indicating whether the stream was opened for I/O to be performed synchronously or asynchronously.</summary>
        </member>
        <member name="P:System.IO.FileStream.Length">
            <summary>Gets the length of the stream in bytes.</summary>
        </member>
        <member name="M:System.IO.FileStream.VerifyOSHandlePosition">
            <summary>
            Verify that the actual position of the OS's handle equals what we expect it to.
            This will fail if someone else moved the UnixFileStream's handle or if
            our position updating code is incorrect.
            </summary>
        </member>
        <member name="M:System.IO.FileStream.AssertBufferInvariants">
            <summary>Verifies that state relating to the read/write buffer is consistent.</summary>
        </member>
        <member name="M:System.IO.FileStream.PrepareForReading">
            <summary>Validates that we're ready to read from the stream.</summary>
        </member>
        <member name="P:System.IO.FileStream.Position">
            <summary>Gets or sets the position within the current stream</summary>
        </member>
        <member name="M:System.IO.FileStream.GetBuffer">
            <summary>
            Gets the array used for buffering reading and writing.  
            If the array hasn't been allocated, this will lazily allocate it.
            </summary>
            <returns>The buffer.</returns>
        </member>
        <member name="M:System.IO.FileStream.FlushInternalBuffer">
            <summary>
            Flushes the internal read/write buffer for this stream.  If write data has been buffered,
            that data is written out to the underlying file.  Or if data has been buffered for 
            reading from the stream, the data is dumped and our position in the underlying file 
            is rewound as necessary.  This does not flush the OS buffer.
            </summary>
        </member>
        <member name="M:System.IO.FileStream.FlushReadBuffer">
            <summary>Dumps any read data in the buffer and rewinds our position in the stream, accordingly, as necessary.</summary>
        </member>
        <member name="M:System.IO.FileStream.ReadByte">
            <summary>
            Reads a byte from the file stream.  Returns the byte cast to an int
            or -1 if reading from the end of the stream.
            </summary>
        </member>
        <member name="M:System.IO.FileStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and advances the position
            within the stream by one byte.
            </summary>
            <param name="value">The byte to write to the stream.</param>
        </member>
        <member name="M:System.IO.FileStream.PrepareForWriting">
            <summary>
            Validates that we're ready to write to the stream,
            including flushing a read buffer if necessary.
            </summary>
        </member>
        <member name="M:System.IO.FileStream.LockInternal(System.Int64,System.Int64)">
            <summary>Prevents other processes from reading from or writing to the FileStream.</summary>
            <param name="position">The beginning of the range to lock.</param>
            <param name="length">The range to be locked.</param>
        </member>
        <member name="M:System.IO.FileStream.UnlockInternal(System.Int64,System.Int64)">
            <summary>Allows access by other processes to all or part of a file that was previously locked.</summary>
            <param name="position">The beginning of the range to unlock.</param>
            <param name="length">The range to be unlocked.</param>
        </member>
        <member name="F:System.IO.FileStream._mode">
            <summary>File mode.</summary>
        </member>
        <member name="F:System.IO.FileStream._options">
            <summary>Advanced options requested when opening the file.</summary>
        </member>
        <member name="F:System.IO.FileStream._appendStart">
            <summary>If the file was opened with FileMode.Append, the length of the file when opened; otherwise, -1.</summary>
        </member>
        <member name="F:System.IO.FileStream._asyncState">
            <summary>
            Extra state used by the file stream when _useAsyncIO is true.  This includes
            the semaphore used to serialize all operation, the buffer/offset/count provided by the
            caller for ReadAsync/WriteAsync operations, and the last successful task returned
            synchronously from ReadAsync which can be reused if the count matches the next request.
            Only initialized when <see cref="F:System.IO.FileStream._useAsyncIO"/> is true.
            </summary>
        </member>
        <member name="F:System.IO.FileStream._canSeek">
            <summary>Lazily-initialized value for whether the file supports seeking.</summary>
        </member>
        <member name="M:System.IO.FileStream.Init(System.IO.FileMode,System.IO.FileShare,System.String)">
            <summary>Initializes a stream for reading or writing a Unix file.</summary>
            <param name="mode">How the file should be opened.</param>
            <param name="share">What other access to the file should be allowed.  This is currently ignored.</param>
        </member>
        <member name="M:System.IO.FileStream.InitFromHandle(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Boolean)">
            <summary>Initializes a stream from an already open file handle (file descriptor).</summary>
        </member>
        <member name="M:System.IO.FileStream.PreOpenConfigurationFromOptions(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.FileOptions)">
            <summary>Translates the FileMode, FileAccess, and FileOptions values into flags to be passed when opening the file.</summary>
            <param name="mode">The FileMode provided to the stream's constructor.</param>
            <param name="access">The FileAccess provided to the stream's constructor</param>
            <param name="share">The FileShare provided to the stream's constructor</param>
            <param name="options">The FileOptions provided to the stream's constructor</param>
            <returns>The flags value to be passed to the open system call.</returns>
        </member>
        <member name="P:System.IO.FileStream.CanSeek">
            <summary>Gets a value indicating whether the current stream supports seeking.</summary>
        </member>
        <member name="M:System.IO.FileStream.CanSeekCore(Microsoft.Win32.SafeHandles.SafeFileHandle)">
            <summary>Gets a value indicating whether the current stream supports seeking.</summary>
            <remarks>
            Separated out of CanSeek to enable making non-virtual call to this logic.
            We also pass in the file handle to allow the constructor to use this before it stashes the handle.
            </remarks>
        </member>
        <member name="M:System.IO.FileStream.Dispose(System.Boolean)">
            <summary>Releases the unmanaged resources used by the stream.</summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:System.IO.FileStream.FlushOSBuffer">
            <summary>Flushes the OS buffer.  This does not flush the internal read/write buffer.</summary>
        </member>
        <member name="M:System.IO.FileStream.FlushWriteBuffer">
            <summary>Writes any data in the write buffer to the underlying stream and resets the buffer.</summary>
        </member>
        <member name="M:System.IO.FileStream.FlushAsyncInternal(System.Threading.CancellationToken)">
            <summary>Asynchronously clears all buffers for this stream, causing any buffered data to be written to the underlying device.</summary>
            <param name="cancellationToken">The token to monitor for cancellation requests.</param>
            <returns>A task that represents the asynchronous flush operation.</returns>
        </member>
        <member name="M:System.IO.FileStream.SetLengthInternal(System.Int64)">
            <summary>Sets the length of this stream to the given value.</summary>
            <param name="value">The new length of the stream.</param>
        </member>
        <member name="M:System.IO.FileStream.ReadSpan(System.Span{System.Byte})">
            <summary>Reads a block of bytes from the stream and writes the data in a given buffer.</summary>
        </member>
        <member name="M:System.IO.FileStream.ReadNative(System.Span{System.Byte})">
            <summary>Unbuffered, reads a block of bytes from the file handle into the given buffer.</summary>
            <param name="buffer">The buffer into which data from the file is read.</param>
            <returns>
            The total number of bytes read into the buffer. This might be less than the number of bytes requested 
            if that number of bytes are not currently available, or zero if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:System.IO.FileStream.ReadAsyncInternal(System.Memory{System.Byte},System.Threading.CancellationToken,System.Int32@)">
            <summary>
            Asynchronously reads a sequence of bytes from the current stream and advances
            the position within the stream by the number of bytes read.
            </summary>
            <param name="destination">The buffer to write the data into.</param>
            <param name="cancellationToken">The token to monitor for cancellation requests.</param>
            <param name="synchronousResult">If the operation completes synchronously, the number of bytes read.</param>
            <returns>A task that represents the asynchronous read operation.</returns>
        </member>
        <member name="M:System.IO.FileStream.FillReadBufferForReadByte">
            <summary>Reads from the file handle into the buffer, overwriting anything in it.</summary>
        </member>
        <member name="M:System.IO.FileStream.WriteSpan(System.ReadOnlySpan{System.Byte})">
            <summary>Writes a block of bytes to the file stream.</summary>
            <param name="source">The buffer containing data to write to the stream.</param>
        </member>
        <member name="M:System.IO.FileStream.WriteNative(System.ReadOnlySpan{System.Byte})">
            <summary>Unbuffered, writes a block of bytes to the file stream.</summary>
            <param name="source">The buffer containing data to write to the stream.</param>
        </member>
        <member name="M:System.IO.FileStream.WriteAsyncInternal(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Asynchronously writes a sequence of bytes to the current stream, advances
            the current position within this stream by the number of bytes written, and
            monitors cancellation requests.
            </summary>
            <param name="source">The buffer to write data from.</param>
            <param name="cancellationToken">The token to monitor for cancellation requests.</param>
            <returns>A task that represents the asynchronous write operation.</returns>
        </member>
        <member name="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Sets the current position of this stream to the given value.</summary>
            <param name="offset">The point relative to origin from which to begin seeking. </param>
            <param name="origin">
            Specifies the beginning, the end, or the current position as a reference 
            point for offset, using a value of type SeekOrigin.
            </param>
            <returns>The new position in the stream.</returns>
        </member>
        <member name="M:System.IO.FileStream.SeekCore(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Int64,System.IO.SeekOrigin)">
            <summary>Sets the current position of this stream to the given value.</summary>
            <param name="offset">The point relative to origin from which to begin seeking. </param>
            <param name="origin">
            Specifies the beginning, the end, or the current position as a reference 
            point for offset, using a value of type SeekOrigin.
            </param>
            <returns>The new position in the stream.</returns>
        </member>
        <member name="T:System.IO.FileStream.AsyncState">
            <summary>State used when the stream is in async mode.</summary>
        </member>
        <member name="M:System.IO.FileStream.AsyncState.#ctor">
            <summary>Initialize the AsyncState.</summary>
        </member>
        <member name="M:System.IO.Path.GetDirectoryName(System.String)">
            <summary>
            Returns the directory portion of a file path. This method effectively
            removes the last segment of the given file path, i.e. it returns a
            string consisting of all characters up to but not including the last
            backslash ("\") in the file path. The returned value is null if the
            specified path is null, empty, or a root (such as "\", "C:", or
            "\\server\share").
            </summary>
            <remarks>
            Directory separators are normalized in the returned string.
            </remarks>
        </member>
        <member name="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the directory portion of a file path. The returned value is empty
            if the specified path is null, empty, or a root (such as "\", "C:", or
            "\\server\share").
            </summary>
            <remarks>
            Unlike the string overload, this method will not normalize directory separators.
            </remarks>
        </member>
        <member name="M:System.IO.Path.GetExtension(System.String)">
            <summary>
            Returns the extension of the given path. The returned value includes the period (".") character of the
            extension except when you have a terminal period when you get string.Empty, such as ".exe" or ".cpp".
            The returned value is null if the given path is null or empty if the given path does not include an
            extension.
            </summary>
        </member>
        <member name="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the extension of the given path.
            </summary>
            <remarks> 
            The returned value is an empty ReadOnlySpan if the given path does not include an extension.
            </remarks>
        </member>
        <member name="M:System.IO.Path.GetFileName(System.String)">
            <summary>
            Returns the name and extension parts of the given path. The resulting string contains
            the characters of path that follow the last separator in path. The resulting string is
            null if path is null.
            </summary>
        </member>
        <member name="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})">
            <summary>
            The returned ReadOnlySpan contains the characters of the path that follows the last separator in path.
            </summary>
        </member>
        <member name="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the characters between the last separator and last (.) in the path.
            </summary>
        </member>
        <member name="M:System.IO.Path.GetRandomFileName">
            <summary>
            Returns a cryptographically strong random 8.3 string that can be
            used as either a folder name or a file name.
            </summary>
        </member>
        <member name="M:System.IO.Path.IsPathFullyQualified(System.String)">
            <summary>
            Returns true if the path is fixed to a specific drive or UNC path. This method does no
            validation of the path (URIs will be returned as relative as a result).
            Returns false if the path specified is relative to the current drive or working directory.
            </summary>
            <remarks>
            Handles paths that use the alternate directory separator.  It is a frequent mistake to
            assume that rooted paths <see cref="M:System.IO.Path.IsPathRooted(System.String)"/> are not relative.  This isn't the case.
            "C:a" is drive relative- meaning that it will be resolved against the current directory
            for C: (rooted, but relative). "C:\a" is rooted and not relative (the current directory
            will not be used to modify the path).
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="path"/> is null.
            </exception>
        </member>
        <member name="M:System.IO.Path.HasExtension(System.String)">
            <summary>
            Tests if a path's file name includes a file extension. A trailing period
            is not considered an extension.
            </summary>
        </member>
        <member name="M:System.IO.Path.GetRelativePath(System.String,System.String)">
            <summary>
            Create a relative path from one path to another. Paths will be resolved before calculating the difference.
            Default path comparison for the active platform will be used (OrdinalIgnoreCase for Windows or Mac, Ordinal for Unix).
            </summary>
            <param name="relativeTo">The source path the output should be relative to. This path is always considered to be a directory.</param>
            <param name="path">The destination path.</param>
            <returns>The relative path or <paramref name="path"/> if the paths don't share the same root.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="relativeTo"/> or <paramref name="path"/> is <c>null</c> or an empty string.</exception>
        </member>
        <member name="P:System.IO.Path.StringComparison">
            <summary>Returns a comparison that can be used to compare file and directory names for equality.</summary>
        </member>
        <member name="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)">
            <summary>
            Trims one trailing directory separator beyond the root of the path.
            </summary>
        </member>
        <member name="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Trims one trailing directory separator beyond the root of the path.
            </summary>
        </member>
        <member name="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path ends in a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.Path.EndsInDirectorySeparator(System.String)">
            <summary>
            Returns true if the path ends in a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.Path.GetPathRoot(System.String)">
            <summary>
            Returns the path root or null if path is empty or null.
            </summary>
        </member>
        <member name="P:System.IO.Path.IsCaseSensitive">
            <summary>Gets whether the system is case-sensitive.</summary>
        </member>
        <member name="T:System.IO.PathInternal">
            <summary>Contains internal path helpers that are shared between many projects.</summary>
            <summary>Contains internal path helpers that are shared between many projects.</summary>
        </member>
        <member name="M:System.IO.PathInternal.StartsWithDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path starts in a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.GetCommonPathLength(System.String,System.String,System.Boolean)">
            <summary>
            Get the common path length from the start of the string.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.EqualStartingCharacterCount(System.String,System.String,System.Boolean)">
            <summary>
            Gets the count of common characters from the left optionally ignoring case
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.AreRootsEqual(System.String,System.String,System.StringComparison)">
            <summary>
            Returns true if the two paths have the same root
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.RemoveRelativeSegments(System.String,System.Int32)">
            <summary>
            Try to remove relative segments from the given path (without combining with a root).
            </summary>
            <param name="path">Input path</param>
            <param name="rootLength">The length of the root of the given path</param>
        </member>
        <member name="M:System.IO.PathInternal.RemoveRelativeSegments(System.ReadOnlySpan{System.Char},System.Int32,System.Text.ValueStringBuilder@)">
            <summary>
            Try to remove relative segments from the given path (without combining with a root).
            </summary>
            <param name="path">Input path</param>
            <param name="rootLength">The length of the root of the given path</param>
            <param name="sb">String builder that will store the result</param>
            <returns>"true" if the path was modified</returns>
        </member>
        <member name="M:System.IO.PathInternal.NormalizeDirectorySeparators(System.String)">
            <summary>
            Normalize separators in the given path. Compresses forward slash runs.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.IsEffectivelyEmpty(System.String)">
            <summary>
            Returns true if the path is effectively empty for the current OS.
            For unix, this is empty or null. For Windows, this is empty, null, or 
            just spaces ((char)32).
            </summary>
        </member>
        <member name="T:System.IO.StreamHelpers">
            <summary>Provides methods to help in the implementation of Stream-derived types.</summary>
        </member>
        <member name="M:System.IO.StreamHelpers.ValidateCopyToArgs(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>Validate the arguments to CopyTo, as would Stream.CopyTo.</summary>
        </member>
        <member name="F:System.IO.StreamReader._disposed">
            <summary>True if the writer has been disposed; otherwise, false.</summary>
        </member>
        <member name="F:System.IO.TextWriter.CoreNewLine">
            <summary>
            This is the 'NewLine' property expressed as a char[].
            It is exposed to subclasses as a protected field for read-only
            purposes.  You should only modify it by using the 'NewLine' property.
            In particular you should never modify the elements of the array
            as they are shared among many instances of TextWriter.
            </summary>
        </member>
        <member name="P:System.IO.TextWriter.NewLine">
            <summary>
            Returns the line terminator string used by this TextWriter. The default line
            terminator string is Environment.NewLine, which is platform specific.
            On Windows this is a carriage return followed by a line feed ("\r\n").
            On OSX and Linux this is a line feed ("\n").
            </summary>
            <remarks>
            The line terminator string is written to the text stream whenever one of the
            WriteLine methods are called. In order for text written by
            the TextWriter to be readable by a TextReader, only one of the following line
            terminator strings should be used: "\r", "\n", or "\r\n".
            </remarks>
        </member>
        <member name="M:System.IO.TextWriter.Write(System.Text.StringBuilder)">
            <summary>
            Equivalent to Write(stringBuilder.ToString()) however it uses the
            StringBuilder.GetChunks() method to avoid creating the intermediate string
            </summary>
            <param name="value">The string (as a StringBuilder) to write to the stream</param>
        </member>
        <member name="M:System.IO.TextWriter.WriteLine(System.Text.StringBuilder)">
            <summary>
            Equivalent to WriteLine(stringBuilder.ToString()) however it uses the
            StringBuilder.GetChunks() method to avoid creating the intermediate string
            </summary>
        </member>
        <member name="M:System.IO.TextWriter.WriteAsync(System.Text.StringBuilder,System.Threading.CancellationToken)">
            <summary>
            Equivalent to WriteAsync(stringBuilder.ToString()) however it uses the
            StringBuilder.GetChunks() method to avoid creating the intermediate string
            </summary>
            <param name="value">The string (as a StringBuilder) to write to the stream</param>
        </member>
        <member name="M:System.IO.TextWriter.WriteLineAsync(System.Text.StringBuilder,System.Threading.CancellationToken)">
            <summary>
            Equivalent to WriteLineAsync(stringBuilder.ToString()) however it uses the
            StringBuilder.GetChunks() method to avoid creating the intermediate string
            </summary>
            <param name="value">The string (as a StringBuilder) to write to the stream</param>
        </member>
        <member name="T:System.IO.UnmanagedMemoryAccessor">
            Perf notes: ReadXXX, WriteXXX (for basic types) acquire and release the 
            SafeBuffer pointer rather than relying on generic Read(T) from SafeBuffer because
            this gives better throughput; benchmarks showed about 12-15% better.
        </member>
        <member name="T:System.IO.UnmanagedMemoryStream">
            <summary>
            Stream over a memory pointer or over a SafeBuffer
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.#ctor">
            <summary>
            Creates a closed stream.
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)">
            <summary>
            Creates a stream over a SafeBuffer.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
            <summary>
            Creates a stream over a SafeBuffer.
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
            <summary>
            Subclasses must call this method (or the other overload) to properly initialize all instance fields.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="access"></param>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
            <summary>
            Creates a stream over a byte*.
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
            <summary>
            Creates a stream over a byte*.
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
            <summary>
            Subclasses must call this method (or the other overload) to properly initialize all instance fields.
            </summary>
        </member>
        <member name="P:System.IO.UnmanagedMemoryStream.CanRead">
            <summary>
            Returns true if the stream can be read; otherwise returns false.
            </summary>
        </member>
        <member name="P:System.IO.UnmanagedMemoryStream.CanSeek">
            <summary>
            Returns true if the stream can seek; otherwise returns false.
            </summary>
        </member>
        <member name="P:System.IO.UnmanagedMemoryStream.CanWrite">
            <summary>
            Returns true if the stream can be written to; otherwise returns false.
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
            <summary>
            Closes the stream. The stream's memory needs to be dealt with separately.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.Flush">
            <summary>
            Since it's a memory stream, this method does nothing.
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)">
            <summary>
            Since it's a memory stream, this method does nothing specific.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="P:System.IO.UnmanagedMemoryStream.Length">
            <summary>
            Number of bytes in the stream.
            </summary>
        </member>
        <member name="P:System.IO.UnmanagedMemoryStream.Capacity">
            <summary>
            Number of bytes that can be written to the stream.
            </summary>
        </member>
        <member name="P:System.IO.UnmanagedMemoryStream.Position">
            <summary>
            ReadByte will read byte at the Position in the stream
            </summary>
        </member>
        <member name="P:System.IO.UnmanagedMemoryStream.PositionPointer">
            <summary>
            Pointer to memory at the current Position in the stream. 
            </summary>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from stream and puts them into the buffer
            </summary>
            <param name="buffer">Buffer to read the bytes to.</param>
            <param name="offset">Starting index in the buffer.</param>
            <param name="count">Maximum number of bytes to read.</param>
            <returns>Number of bytes actually read.</returns>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads bytes from stream and puts them into the buffer
            </summary>
            <param name="buffer">Buffer to read the bytes to.</param>
            <param name="offset">Starting index in the buffer.</param>
            <param name="count">Maximum number of bytes to read.</param>       
            <param name="cancellationToken">Token that can be used to cancel this operation.</param>
            <returns>Task that can be used to access the number of bytes actually read.</returns>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Reads bytes from stream and puts them into the buffer
            </summary>
            <param name="buffer">Buffer to read the bytes to.</param>
            <param name="cancellationToken">Token that can be used to cancel this operation.</param>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.ReadByte">
            <summary>
            Returns the byte at the stream current Position and advances the Position.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Advanced the Position to specific location in the stream.
            </summary>
            <param name="offset">Offset from the loc parameter.</param>
            <param name="loc">Origin for the offset parameter.</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the Length of the stream.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes buffer into the stream
            </summary>
            <param name="buffer">Buffer that will be written.</param>
            <param name="offset">Starting index in the buffer.</param>
            <param name="count">Number of bytes to write.</param>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Writes buffer into the stream. The operation completes synchronously.
            </summary>
            <param name="buffer">Buffer that will be written.</param>
            <param name="offset">Starting index in the buffer.</param>
            <param name="count">Number of bytes to write.</param>
            <param name="cancellationToken">Token that can be used to cancel the operation.</param>
            <returns>Task that can be awaited </returns>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Writes buffer into the stream. The operation completes synchronously.
            </summary>
            <param name="buffer">Buffer that will be written.</param>
            <param name="cancellationToken">Token that can be used to cancel the operation.</param>
        </member>
        <member name="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the stream and advances the current Position.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:System.IO.Win32Marshal">
            <summary>
            Provides static methods for converting from Win32 errors codes to exceptions, HRESULTS and error messages.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.GetExceptionForLastWin32Error(System.String)">
            <summary>
            Converts, resetting it, the last Win32 error into a corresponding <see cref="T:System.Exception"/> object, optionally
            including the specified path in the error message.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.GetExceptionForWin32Error(System.Int32,System.String)">
            <summary>
            Converts the specified Win32 error into a corresponding <see cref="T:System.Exception"/> object, optionally
            including the specified path in the error message.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.MakeHRFromErrorCode(System.Int32)">
            <summary>
            If not already an HRESULT, returns an HRESULT for the specified Win32 error code.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.TryMakeWin32ErrorCodeFromHR(System.Int32)">
            <summary>
            Returns a Win32 error code for the specified HRESULT if it came from FACILITY_WIN32
            If not, returns the HRESULT unchanged
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.GetMessage(System.Int32)">
            <summary>
            Returns a string message for the specified Win32 error code.
            </summary>
        </member>
        <member name="T:System.IO.DriveInfoInternal">
            <summary>Contains internal volume helpers that are shared between many projects.</summary>
        </member>
        <member name="M:System.IO.PersistedFiles.GetUserFeatureDirectory(System.String)">
            <summary>
            Get the location of where to persist information for a particular aspect of the framework,
            such as "cryptography".
            </summary>
            <param name="featureName">The directory name for the feature</param>
            <returns>A path within the user's home directory for persisting data for the feature</returns>
        </member>
        <member name="M:System.IO.PersistedFiles.GetUserFeatureDirectory(System.String,System.String)">
            <summary>
            Get the location of where to persist information for a particular aspect of a feature of
            the framework, such as "x509stores" within "cryptography".
            </summary>
            <param name="featureName">The directory name for the feature</param>
            <param name="subFeatureName">The directory name for the sub-feature</param>
            <returns>A path within the user's home directory for persisting data for the sub-feature</returns>
        </member>
        <member name="M:System.IO.PersistedFiles.GetUserFeatureDirectory(System.String[])">
            <summary>
            Get the location of where to persist information for a particular aspect of the framework,
            with a lot of hierarchy, such as ["cryptography", "x509stores", "my"]
            </summary>
            <param name="featurePathParts">A non-empty set of directories to use for the storage hierarchy</param>
            <returns>A path within the user's home directory for persisting data for the feature</returns>
        </member>
        <member name="M:System.IO.PersistedFiles.GetHomeDirectory">
            <summary>Gets the current user's home directory.</summary>
            <returns>The path to the home directory, or null if it could not be determined.</returns>
        </member>
        <member name="M:System.IO.PersistedFiles.TryGetHomeDirectoryFromPasswd(System.Byte*,System.Int32,System.String@)">
            <summary>Wrapper for getpwuid_r.</summary>
            <param name="buf">The scratch buffer to pass into getpwuid_r.</param>
            <param name="bufLen">The length of <paramref name="buf"/>.</param>
            <param name="path">The resulting path; null if the user didn't have an entry.</param>
            <returns>true if the call was successful (path may still be null); false is a larger buffer is needed.</returns>
        </member>
        <member name="M:System.Reflection.AssemblyName.ReferenceMatchesDefinition(System.Reflection.AssemblyName,System.Reflection.AssemblyName)">
            <summary>
            Compares the simple names disregarding Version, Culture and PKT. While this clearly does not
            match the intent of this api, this api has been broken this way since its debut and we cannot
            change its behavior now.
            </summary>
        </member>
        <member name="F:System.Reflection.CustomAttributeType.m_enumName">
            The most complicated type is an enum[] in which case...
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
            <summary>
            If an AssemblyName has a public key specified, the assembly is assumed
            to have a strong name and a hash will be computed when the assembly
            is saved.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String)">
            <summary>
            Defines a named dynamic module. It is an error to define multiple 
            modules within an Assembly with the same name. This dynamic module is
            a transient module.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.GetManifestResourceNames">
            <returns>The names of all the resources.</returns>
        </member>
        <member name="P:System.Reflection.Emit.AssemblyBuilder.EntryPoint">
            <sumary>
            Override the EntryPoint method on Assembly.
            This doesn't need to be synchronized because it is simple enough.
            </sumary>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.GetExportedTypes">
            <sumary>
            Get an array of all the public types defined in this assembly.
            </sumary>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)">
            <sumary> 
            Useful for binding to a very specific version of a satellite assembly
            </sumary>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule(System.String)">
            <param name="name">The name of module for the look up.</param>
            <returns>Dynamic module with the specified name.</returns>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.GetDynamicModuleNoLock(System.String)">
            <param name="name">The name of module for the look up.</param>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
            <summary>
            Use this function if client decides to form the custom attribute blob themselves.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
            <summary>
            Use this function if client wishes to build CustomAttribute using CustomAttributeBuilder.
            </summary>
        </member>
        <member name="T:System.Reflection.Emit.AssemblyBuilderData">
            <summary>
            This is a package private class. This class hold all of the managed
            data member for AssemblyBuilder. Note that what ever data members added to
            this class cannot be accessed from the EE.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.AssemblyBuilderData.CheckTypeNameConflict(System.String,System.Reflection.Emit.TypeBuilder)">
            <summary>
            Helper to ensure the type name is unique underneath assemblyBuilder.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.CustomAttributeBuilder.CreateCustomAttribute(System.Reflection.Emit.ModuleBuilder,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Call this function with toDisk=1, after on disk module has been snapped.
            </summary>
        </member>
        <member name="P:System.Reflection.Emit.EnumBuilder.GUID">
            <summary>
            abstract methods defined in the base class
            </summary>
        </member>
        <member name="T:System.Reflection.Emit.ScopeAction">
            <summary>
            Scope Tree is a class that track the scope structure within a method body
            It keeps track two parallel array. m_ScopeAction keeps track the action. It can be
            OpenScope or CloseScope. m_iOffset records the offset where the action
            takes place.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.ScopeTree.GetCurrentActiveScopeIndex">
            <summary>
            Find the current active lexical scope. For example, if we have
            "Open Open Open Close",
            we will return 1 as the second BeginScope is currently active.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.ScopeTree.EnsureCapacity">
            <summary>
            Helper to ensure arrays are large enough
            </summary>
        </member>
        <member name="T:System.Reflection.Emit.LineNumberInfo">
            <summary>
            This class tracks the line number info
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.LineNumberInfo.EnsureCapacity">
            <summary>
            Helper to ensure arrays are large enough
            </summary>
        </member>
        <member name="T:System.Reflection.Emit.REDocument">
            <summary>
            This class tracks the line number info
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.REDocument.EnsureCapacity">
            <summary>
            Helper to ensure arrays are large enough
            </summary>
        </member>
        <member name="T:System.Reflection.Emit.ExceptionHandler">
            <summary>
            Describes exception handler in a method body.
            </summary>
        </member>
        <member name="M:System.Reflection.Emit.PropertyBuilder.SetConstant(System.Object)">
            <summary>
            Set the default value of the Property
            </summary>
        </member>
        <member name="T:System.Reflection.Emit.FieldToken">
            <summary>
            The FieldToken class is an opaque representation of the Token returned
            by the Metadata to represent the field.  FieldTokens are generated by
            Module.GetFieldToken().  There are no meaningful accessors on this class,
            but it can be passed to ILGenerator which understands it's internals.
            </summary>
        </member>
        <member name="T:System.Reflection.Emit.OpCodes">
            <summary>
               <para>
                  The IL instruction opcodes supported by the
                  runtime. The IL Instruction Specification describes each
                  Opcode.
               </para>
            </summary>
            <seealso topic='IL Instruction Set Specification'/>
        </member>
        <member name="T:System.Reflection.Emit.ParameterToken">
            <summary>
            The ParameterToken class is an opaque representation of the Token returned
            by the Metadata to represent the parameter.
            </summary>
        </member>
        <member name="M:System.Reflection.SignatureTypeExtensions.MatchesParameterTypeExactly(System.Type,System.Reflection.ParameterInfo)">
            <summary>
            This is semantically identical to 
            
                 parameter.ParameterType == pattern.TryResolveAgainstGenericMethod(parameter.Member)
                 
            but without the allocation overhead of TryResolve.
            </summary>
        </member>
        <member name="M:System.Reflection.SignatureTypeExtensions.MatchesExactly(System.Reflection.SignatureType,System.Type)">
            <summary>
            This is semantically identical to 
            
                 actual == pattern.TryResolveAgainstGenericMethod(parameterMember)
                 
            but without the allocation overhead of TryResolve.
            </summary>
        </member>
        <member name="M:System.Reflection.SignatureTypeExtensions.TryResolveAgainstGenericMethod(System.Reflection.SignatureType,System.Reflection.MethodInfo)">
            <summary>
            Translates a SignatureType into its equivalent resolved Type by recursively substituting all generic parameter references
            with its corresponding generic parameter definition. This is slow so MatchesExactly or MatchesParameterTypeExactly should be
            substituted instead whenever possible. This is only used by the DefaultBinder when its fast-path checks have been exhausted and
            it needs to call non-trivial methods like IsAssignableFrom which SignatureTypes will never support.
            
            Because this method is used to eliminate method candidates in a GetMethod() lookup, it is entirely possible that the Type
            might not be creatable due to conflicting generic constraints. Since this merely implies that this candidate is not
            the method we're looking for, we return null rather than let the TypeLoadException bubble up. The DefaultBinder will catch
            the null and continue its search for a better candidate.
            </summary>
        </member>
        <member name="M:System.RuntimeType.CreateInstanceDefaultCtorSlow(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            The slow path of CreateInstanceDefaultCtor
            </summary>
        </member>
        <member name="M:System.RuntimeType.CreateInstanceDefaultCtor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Helper to invoke the default (parameterless) constructor.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.LAHashDependentHashTracker">
            <summary>
            Managed structure used by CrossLoaderAllocatorHeap to isolate per LoaderAllocator
            data. 
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.LAHashKeyToTrackers">
            <summary>
            Managed structure used by CrossLoaderAllocatorHeap to hold a set of references
            to LAHashDependentHashTracker's
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.GCHeapHash">
            <summary>
            Managed structure used by GCHeapHash in CLR to provide a hashtable manipulated
            by C++ runtime code which manages its memory in the GC heap.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ICastableHelpers">
            <summary>
            Helpers that allows VM to call into ICastable methods without having to deal with RuntimeTypeHandle.
            RuntimeTypeHandle is a struct and is always passed in stack in x86, which our VM call helpers don't
            particularly like.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.RuntimeFeature.PortablePdb">
            <summary>
            Name of the Portable PDB feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.RuntimeFeature.DefaultImplementationsOfInterfaces">
            <summary>
            Indicates that this version of runtime supports default interface method implementations.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeFeature.IsSupported(System.String)">
            <summary>
            Checks whether a certain feature is supported by the Runtime.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1">
            <returns>true if given type is reference type or value type that contains references</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.IsBitwiseEquatable``1">
            <returns>true if given type is bitwise equatable (memcmp can be used for equality checking)</returns>
            <remarks>
            Only use the result of this for Equals() comparison, not for CompareTo() comparison.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray``1(``0[],System.Range)">
            <summary>
            Slices the specified array using the specified range.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder">
            <summary>Represents a builder for asynchronous iterators.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder.Create">
            <summary>Creates an instance of the <see cref="T:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder"/> struct.</summary>
            <returns>The initialized instance.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder.MoveNext``1(``0@)">
            <summary>Invokes <see cref="M:System.Runtime.CompilerServices.IAsyncStateMachine.MoveNext"/> on the state machine while guarding the <see cref="T:System.Threading.ExecutionContext"/>.</summary>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder.AwaitOnCompleted``2(``0@,``1@)">
            <summary>Schedules the state machine to proceed to the next action when the specified awaiter completes.</summary>
            <typeparam name="TAwaiter">The type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>Schedules the state machine to proceed to the next action when the specified awaiter completes.</summary>
            <typeparam name="TAwaiter">The type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder.Complete">
            <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncIteratorMethodBuilder.ObjectIdForDebugger">
            <summary>Gets an object that may be used to uniquely identify this builder to the debugger.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute">
            <summary>Indicates whether a method is an asynchronous iterator.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute.#ctor(System.Type)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute"/> class.</summary>
            <param name="stateMachineType">The type object for the underlying state machine type that's used to implement a state machine method.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncVoidMethodBuilder">
            <summary>
            Provides a builder for asynchronous methods that return void.
            This type is intended for compiler use only.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncVoidMethodBuilder._synchronizationContext">
            <summary>The synchronization context associated with this operation.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncVoidMethodBuilder._builder">
            <summary>The builder this void builder wraps.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.Create">
            <summary>Initializes a new <see cref="T:System.Runtime.CompilerServices.AsyncVoidMethodBuilder"/>.</summary>
            <returns>The initialized <see cref="T:System.Runtime.CompilerServices.AsyncVoidMethodBuilder"/>.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.Start``1(``0@)">
            <summary>Initiates the builder's execution with the associated state machine.</summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="stateMachine"/> argument was null (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Associates the builder with the state machine it represents.</summary>
            <param name="stateMachine">The heap-allocated state machine object.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="stateMachine"/> argument was null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The builder is incorrectly initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.AwaitOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.SetResult">
            <summary>Completes the method builder successfully.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.SetException(System.Exception)">
            <summary>Faults the method builder with an exception.</summary>
            <param name="exception">The exception that is the cause of this fault.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="exception"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The builder is not initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.NotifySynchronizationContextOfCompletion">
            <summary>Notifies the current synchronization context that the operation completed.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.Task">
            <summary>Lazily instantiate the Task in a non-thread-safe manner.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncVoidMethodBuilder.ObjectIdForDebugger">
            <summary>
            Gets an object that may be used to uniquely identify this builder to the debugger.
            </summary>
            <remarks>
            This property lazily instantiates the ID in a non-thread-safe manner.  
            It must only be used by the debugger and AsyncCausalityTracer in a single-threaded manner.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder">
            <summary>
            Provides a builder for asynchronous methods that return <see cref="T:System.Threading.Tasks.Task"/>.
            This type is intended for compiler use only.
            </summary>
            <remarks>
            AsyncTaskMethodBuilder is a value type, and thus it is copied by value.
            Prior to being copied, one of its Task, SetResult, or SetException members must be accessed,
            or else the copies may end up building distinct Task instances.
            </remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.s_cachedCompleted">
            <summary>A cached VoidTaskResult task used for builders that complete synchronously.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.m_builder">
            <summary>The generic builder object to which this non-generic instance delegates.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Create">
            <summary>Initializes a new <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/>.</summary>
            <returns>The initialized <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/>.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Start``1(``0@)">
            <summary>Initiates the builder's execution with the associated state machine.</summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Associates the builder with the state machine it represents.</summary>
            <param name="stateMachine">The heap-allocated state machine object.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="stateMachine"/> argument was null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The builder is incorrectly initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.AwaitOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.Task">
            <summary>Gets the <see cref="T:System.Threading.Tasks.Task"/> for this builder.</summary>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the builder's asynchronous operation.</returns>
            <exception cref="T:System.InvalidOperationException">The builder is not initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetResult">
            <summary>
            Completes the <see cref="T:System.Threading.Tasks.Task"/> in the 
            <see cref="T:System.Threading.Tasks.TaskStatus">RanToCompletion</see> state.
            </summary>
            <exception cref="T:System.InvalidOperationException">The builder is not initialized.</exception>
            <exception cref="T:System.InvalidOperationException">The task has already completed.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetException(System.Exception)">
            <summary>
            Completes the <see cref="T:System.Threading.Tasks.Task"/> in the 
            <see cref="T:System.Threading.Tasks.TaskStatus">Faulted</see> state with the specified exception.
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> to use to fault the task.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="exception"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The builder is not initialized.</exception>
            <exception cref="T:System.InvalidOperationException">The task has already completed.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.SetNotificationForWaitCompletion(System.Boolean)">
            <summary>
            Called by the debugger to request notification when the first wait operation
            (await, Wait, Result, etc.) on this builder's task completes.
            </summary>
            <param name="enabled">
            true to enable notification; false to disable a previously set notification.
            </param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncTaskMethodBuilder.ObjectIdForDebugger">
            <summary>
            Gets an object that may be used to uniquely identify this builder to the debugger.
            </summary>
            <remarks>
            This property lazily instantiates the ID in a non-thread-safe manner.  
            It must only be used by the debugger and tracing purposes, and only in a single-threaded manner
            when no other threads are in the middle of accessing this property or this.Task.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1">
            <summary>
            Provides a builder for asynchronous methods that return <see cref="T:System.Threading.Tasks.Task`1"/>.
            This type is intended for compiler use only.
            </summary>
            <remarks>
            AsyncTaskMethodBuilder{TResult} is a value type, and thus it is copied by value.
            Prior to being copied, one of its Task, SetResult, or SetException members must be accessed,
            or else the copies may end up building distinct Task instances.
            </remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.s_defaultResultTask">
            <summary>A cached task for default(TResult).</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.m_task">
            <summary>The lazily-initialized built task.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Create">
            <summary>Initializes a new <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/>.</summary>
            <returns>The initialized <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/>.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Start``1(``0@)">
            <summary>Initiates the builder's execution with the associated state machine.</summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Associates the builder with the state machine it represents.</summary>
            <param name="stateMachine">The heap-allocated state machine object.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="stateMachine"/> argument was null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The builder is incorrectly initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AwaitOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.GetStateMachineBox``1(``0@)">
            <summary>Gets the "boxed" state machine object.</summary>
            <typeparam name="TStateMachine">Specifies the type of the async state machine.</typeparam>
            <param name="stateMachine">The state machine.</param>
            <returns>The "boxed" state machine.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.DebugFinalizableAsyncStateMachineBox`1">
            <summary>
            Provides an async state machine box with a finalizer that will fire an EventSource
            event about the state machine if it's being finalized without having been completed.
            </summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1">
            <summary>A strongly-typed box for Task-based async state machines.</summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.s_callback">
            <summary>Delegate used to invoke on an ExecutionContext when passed an instance of this box type.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1._moveNextAction">
            <summary>A delegate to the <see cref="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext"/> method.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.StateMachine">
            <summary>The state machine itself.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.Context">
            <summary>Captured ExecutionContext with which to invoke <see cref="P:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNextAction"/>; may be null.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNextAction">
            <summary>A delegate to the <see cref="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext"/> method.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.MoveNext">
            <summary>Calls MoveNext on <see cref="F:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.StateMachine"/></summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1.System#Runtime#CompilerServices#IAsyncStateMachineBox#GetStateMachineObject">
            <summary>Gets the state machine as a boxed object.  This should only be used for debugging purposes.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.Task">
            <summary>Gets the <see cref="T:System.Threading.Tasks.Task`1"/> for this builder.</summary>
            <returns>The <see cref="T:System.Threading.Tasks.Task`1"/> representing the builder's asynchronous operation.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.InitializeTaskAsPromise">
            <summary>
            Initializes the task, which must not yet be initialized.  Used only when the Task is being forced into
            existence when no state machine is needed, e.g. when the builder is being synchronously completed with
            an exception, when the builder is being used out of the context of an async method, etc.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.InitializeTaskAsStateMachineBox">
            <summary>
            Initializes the task, which must not yet be initialized.  Used only when the Task is being forced into
            existence due to the debugger trying to enable step-out/step-over/etc. prior to the first await yielding
            in an async method.  In that case, we don't know the actual TStateMachine type, so we're forced to
            use IAsyncStateMachine instead.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(`0)">
            <summary>
            Completes the <see cref="T:System.Threading.Tasks.Task`1"/> in the 
            <see cref="T:System.Threading.Tasks.TaskStatus">RanToCompletion</see> state with the specified result.
            </summary>
            <param name="result">The result to use to complete the task.</param>
            <exception cref="T:System.InvalidOperationException">The task has already completed.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetExistingTaskResult(`0)">
            <summary>Completes the already initialized task with the specified result.</summary>
            <param name="result">The result to use to complete the task.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetResult(System.Threading.Tasks.Task{`0})">
            <summary>
            Completes the builder by using either the supplied completed task, or by completing
            the builder's previously accessed task using default(TResult).
            </summary>
            <param name="completedTask">A task already completed with the value default(TResult).</param>
            <exception cref="T:System.InvalidOperationException">The task has already completed.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetException(System.Exception)">
            <summary>
            Completes the <see cref="T:System.Threading.Tasks.Task`1"/> in the 
            <see cref="T:System.Threading.Tasks.TaskStatus">Faulted</see> state with the specified exception.
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> to use to fault the task.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="exception"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The task has already completed.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.SetNotificationForWaitCompletion(System.Boolean)">
            <summary>
            Called by the debugger to request notification when the first wait operation
            (await, Wait, Result, etc.) on this builder's task completes.
            </summary>
            <param name="enabled">
            true to enable notification; false to disable a previously set notification.
            </param>
            <remarks>
            This should only be invoked from within an asynchronous method,
            and only by the debugger.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.ObjectIdForDebugger">
            <summary>
            Gets an object that may be used to uniquely identify this builder to the debugger.
            </summary>
            <remarks>
            This property lazily instantiates the ID in a non-thread-safe manner.  
            It must only be used by the debugger and tracing purposes, and only in a single-threaded manner
            when no other threads are in the middle of accessing this or other members that lazily initialize the task.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.GetTaskForResult(`0)">
            <summary>
            Gets a task for the specified result.  This will either
            be a cached or new task, never null.
            </summary>
            <param name="result">The result for which we need a task.</param>
            <returns>The completed task containing the result.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncTaskCache">
            <summary>Provides a cache of closed generic tasks for async methods.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskCache.TrueTask">
            <summary>A cached Task{Boolean}.Result == true.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskCache.FalseTask">
            <summary>A cached Task{Boolean}.Result == false.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskCache.Int32Tasks">
            <summary>The cache of Task{Int32}.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskCache.INCLUSIVE_INT32_MIN">
            <summary>The minimum value, inclusive, for which we want a cached task.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncTaskCache.EXCLUSIVE_INT32_MAX">
            <summary>The maximum value, exclusive, for which we want a cached task.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskCache.CreateInt32Tasks">
            <summary>Creates an array of cached tasks for the values in the range [INCLUSIVE_MIN,EXCLUSIVE_MAX).</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncTaskCache.CreateCacheableTask``1(``0)">
            <summary>Creates a non-disposable task.</summary>
            <typeparam name="TResult">Specifies the result type.</typeparam>
            <param name="result">The result for the task.</param>
            <returns>The cacheable task.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.IAsyncStateMachineBox">
            <summary>
            An interface implemented by all <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1.AsyncStateMachineBox`1"/> instances, regardless of generics.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.IAsyncStateMachineBox.MoveNext">
            <summary>Move the state machine forward.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.IAsyncStateMachineBox.MoveNextAction">
            <summary>
            Gets an action for moving forward the contained state machine.
            This will lazily-allocate the delegate as needed.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.IAsyncStateMachineBox.GetStateMachineObject">
            <summary>Gets the state machine as a boxed object.  This should only be used for debugging purposes.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncMethodBuilderCore">
            <summary>Shared helpers for manipulating state related to async state machines.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start``1(``0@)">
            <summary>Initiates the builder's execution with the associated state machine.</summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncMethodBuilderCore.TrackAsyncMethodCompletion">
            <summary>Gets whether we should be tracking async method completions for eventing.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderCore.GetAsyncStateMachineDescription(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Gets a description of the state of the state machine object, suitable for debug purposes.</summary>
            <param name="stateMachine">The state machine object.</param>
            <returns>A description of the state machine.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderCore.TryGetStateMachineForDebugger(System.Action)">
            <summary>This helper routine is targeted by the debugger. Its purpose is to remove any delegate wrappers introduced by
            the framework that the debugger doesn't want to see.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncMethodBuilderCore.ContinuationWrapper">
            <summary>
            Logically we pass just an Action (delegate) to a task for its action to 'ContinueWith' when it completes.
            However debuggers and profilers need more information about what that action is. (In particular what 
            the action after that is and after that.   To solve this problem we create a 'ContinuationWrapper 
            which when invoked just does the original action (the invoke action), but also remembers other information
            (like the action after that (which is also a ContinuationWrapper and thus form a linked list).  
             We also store that task if the action is associate with at task.  
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute">
            <summary>
            Indicates the type of the async method builder that should be used by a language compiler to
            build the attributed type when used as the return type of an async method.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.#ctor(System.Type)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute"/>.</summary>
            <param name="builderType">The <see cref="T:System.Type"/> of the associated builder.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.BuilderType">
            <summary>Gets the <see cref="T:System.Type"/> of the associated builder.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder">
            <summary>Represents a builder for asynchronous methods that return a <see cref="T:System.Threading.Tasks.ValueTask"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder._methodBuilder">
            <summary>The <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/> to which most operations are delegated.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder._haveResult">
            <summary>true if completed synchronously and successfully; otherwise, false.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder._useBuilder">
            <summary>true if the builder should be used for setting/getting the result; otherwise, false.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.Create">
            <summary>Creates an instance of the <see cref="T:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder"/> struct.</summary>
            <returns>The initialized instance.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.Start``1(``0@)">
            <summary>Begins running the builder with the associated state machine.</summary>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Associates the builder with the specified state machine.</summary>
            <param name="stateMachine">The state machine instance to associate with the builder.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.SetResult">
            <summary>Marks the task as successfully completed.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.SetException(System.Exception)">
            <summary>Marks the task as failed and binds the specified exception to the task.</summary>
            <param name="exception">The exception to bind to the task.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.Task">
            <summary>Gets the task for this builder.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.AwaitOnCompleted``2(``0@,``1@)">
            <summary>Schedules the state machine to proceed to the next action when the specified awaiter completes.</summary>
            <typeparam name="TAwaiter">The type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>Schedules the state machine to proceed to the next action when the specified awaiter completes.</summary>
            <typeparam name="TAwaiter">The type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1">
            <summary>Represents a builder for asynchronous methods that returns a <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1._methodBuilder">
            <summary>The <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1"/> to which most operations are delegated.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1._result">
            <summary>The result for this builder, if it's completed before any awaits occur.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1._haveResult">
            <summary>true if <see cref="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1._result"/> contains the synchronous result for the async method; otherwise, false.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1._useBuilder">
            <summary>true if the builder should be used for setting/getting the result; otherwise, false.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.Create">
            <summary>Creates an instance of the <see cref="T:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1"/> struct.</summary>
            <returns>The initialized instance.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.Start``1(``0@)">
            <summary>Begins running the builder with the associated state machine.</summary>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Associates the builder with the specified state machine.</summary>
            <param name="stateMachine">The state machine instance to associate with the builder.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.SetResult(`0)">
            <summary>Marks the task as successfully completed.</summary>
            <param name="result">The result to use to complete the task.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.SetException(System.Exception)">
            <summary>Marks the task as failed and binds the specified exception to the task.</summary>
            <param name="exception">The exception to bind to the task.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.Task">
            <summary>Gets the task for this builder.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.AwaitOnCompleted``2(``0@,``1@)">
            <summary>Schedules the state machine to proceed to the next action when the specified awaiter completes.</summary>
            <typeparam name="TAwaiter">The type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="awaiter">the awaiter</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>Schedules the state machine to proceed to the next action when the specified awaiter completes.</summary>
            <typeparam name="TAwaiter">The type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">The type of the state machine.</typeparam>
            <param name="awaiter">the awaiter</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilationRelaxations">
            IMPORTANT: Keep this in sync with corhdr.h
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
            <summary>Gets the value of the specified key.</summary>
            <param name="key">key of the value to find. Cannot be null.</param>
            <param name="value">
            If the key is found, contains the value associated with the key upon method return.
            If the key is not found, contains default(TValue).
            </param>
            <returns>Returns "true" if key was found, "false" otherwise.</returns>
            <remarks>
            The key may get garbaged collected during the TryGetValue operation. If so, TryGetValue
            may at its discretion, return "false" and set "value" to the default (as if the key was not present.)
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
            <summary>Adds a key to the table.</summary>
            <param name="key">key to add. May not be null.</param>
            <param name="value">value to associate with key.</param>
            <remarks>
            If the key is already entered into the dictionary, this method throws an exception.
            The key may get garbage collected during the Add() operation. If so, Add()
            has the right to consider any prior entries successfully removed and add a new entry without
            throwing an exception.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)">
            <summary>Adds the key and value if the key doesn't exist, or updates the existing key's value if it does exist.</summary>
            <param name="key">key to add or update. May not be null.</param>
            <param name="value">value to associate with key.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
            <summary>Removes a key and its value from the table.</summary>
            <param name="key">key to remove. May not be null.</param>
            <returns>true if the key is found and removed. Returns false if the key was not in the dictionary.</returns>
            <remarks>
            The key may get garbage collected during the Remove() operation. If so,
            Remove() will not fail or throw, however, the return value can be either true or false
            depending on who wins the race.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear">
            <summary>Clear all the key/value pairs</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)">
            <summary>
            Atomically searches for a specified key in the table and returns the corresponding value.
            If the key does not exist in the table, the method invokes a callback method to create a
            value that is bound to the specified key.
            </summary>
            <param name="key">key of the value to find. Cannot be null.</param>
            <param name="createValueCallback">callback that creates value for key. Cannot be null.</param>
            <returns></returns>
            <remarks>
            If multiple threads try to initialize the same key, the table may invoke createValueCallback
            multiple times with the same key. Exactly one of these calls will succeed and the returned
            value of that call will be the one added to the table and returned by all the racing GetValue() calls.
            This rule permits the table to invoke createValueCallback outside the internal table lock
            to prevent deadlocks.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
            <summary>
            Helper method to call GetValue without passing a creation delegate.  Uses Activator.CreateInstance
            to create new instances as needed.  If TValue does not have a default constructor, this will throw.
            </summary>
            <param name="key">key of the value to find. Cannot be null.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>Gets an enumerator for the table.</summary>
            <remarks>
            The returned enumerator will not extend the lifetime of
            any object pairs in the table, other than the one that's Current.  It will not return entries
            that have already been collected, nor will it return entries added after the enumerator was
            retrieved.  It may not return all entries that were present when the enumerat was retrieved,
            however, such as not returning entries that were collected or removed after the enumerator
            was retrieved but before they were enumerated.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.Enumerator">
            <summary>Provides an enumerator for the table.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateEntry(`0,`1)">
            <summary>Worker for adding a new key/value pair. Will resize the container if it is full.</summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container">
            <summary>
            Container holds the actual data for the table.  A given instance of Container always has the same capacity.  When we need
            more capacity, we create a new Container, copy the old one into the new one, and discard the old one.  This helps enable lock-free
            reads from the table, as readers never need to deal with motion of entries due to rehashing.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.CreateEntryNoResize(`0,`1)">
            <summary>Worker for adding a new key/value pair. Container must NOT be full.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.TryGetValueWorker(`0,`1@)">
            <summary>Worker for finding a key/value pair. Must hold _lock.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.FindEntry(`0,System.Object@)">
            <summary>
            Returns -1 if not found (if key expires during FindEntry, this can be treated as "not found.").
            Must hold _lock, or be prepared to retry the search while holding _lock.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.TryGetEntry(System.Int32,`0@,`1@)">
            <summary>Gets the entry at the specified entry index.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.RemoveAllKeys">
            <summary>Removes all of the keys in the table.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.Remove(`0)">
            <summary>Removes the specified key from the table, if it exists.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Container.Resize">
            <summary>Resize, and scrub expired keys off bucket lists. Must hold _lock.</summary>
            <remarks>
            _firstEntry is less than _entries.Length on exit, that is, the table has at least one free entry.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredAsyncDisposable">
            <summary>Provides a type that can be used to configure how awaits on an <see cref="T:System.IAsyncDisposable"/> are performed.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1">
            <summary>Provides an awaitable async enumerable that enables cancelable iteration and configured awaits.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.ConfigureAwait(System.Boolean)">
            <summary>Configures how awaits on the tasks returned from an async iteration will be performed.</summary>
            <param name="continueOnCapturedContext">Whether to capture and marshal back to the current context.</param>
            <returns>The configured enumerable.</returns>
            <remarks>This will replace any previous value set by <see cref="M:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.ConfigureAwait(System.Boolean)"/> for this iteration.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.WithCancellation(System.Threading.CancellationToken)">
            <summary>Sets the <see cref="T:System.Threading.CancellationToken"/> to be passed to <see cref="M:System.Collections.Generic.IAsyncEnumerable`1.GetAsyncEnumerator(System.Threading.CancellationToken)"/> when iterating.</summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to use.</param>
            <returns>The configured enumerable.</returns>
            <remarks>This will replace any previous <see cref="T:System.Threading.CancellationToken"/> set by <see cref="M:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.WithCancellation(System.Threading.CancellationToken)"/> for this iteration.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.Enumerator">
            <summary>Provides an awaitable async enumerator that enables cancelable iteration and configured awaits.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.Enumerator.MoveNextAsync">
            <summary>Advances the enumerator asynchronously to the next element of the collection.</summary>
            <returns>
            A <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1"/> that will complete with a result of <c>true</c>
            if the enumerator was successfully advanced to the next element, or <c>false</c> if the enumerator has
            passed the end of the collection.
            </returns>
        </member>
        <member name="P:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.Enumerator.Current">
            <summary>Gets the element in the collection at the current position of the enumerator.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.Enumerator.DisposeAsync">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or
            resetting unmanaged resources asynchronously.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable">
            <summary>Provides an awaitable type that enables configured awaits on a <see cref="T:System.Threading.Tasks.ValueTask"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable._value">
            <summary>The wrapped <see cref="T:System.Threading.Tasks.Task"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.#ctor(System.Threading.Tasks.ValueTask@)">
            <summary>Initializes the awaitable.</summary>
            <param name="value">The wrapped <see cref="T:System.Threading.Tasks.ValueTask"/>.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.GetAwaiter">
            <summary>Returns an awaiter for this <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable"/> instance.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter">
            <summary>Provides an awaiter for a <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter._value">
            <summary>The value being awaited.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter.#ctor(System.Threading.Tasks.ValueTask@)">
            <summary>Initializes the awaiter.</summary>
            <param name="value">The value to be awaited.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter.IsCompleted">
            <summary>Gets whether the <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable"/> has completed.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter.GetResult">
            <summary>Gets the result of the ValueTask.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter.OnCompleted(System.Action)">
            <summary>Schedules the continuation action for the <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation action for the <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1">
            <summary>Provides an awaitable type that enables configured awaits on a <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
            <typeparam name="TResult">The type of the result produced.</typeparam>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1._value">
            <summary>The wrapped <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.#ctor(System.Threading.Tasks.ValueTask{`0}@)">
            <summary>Initializes the awaitable.</summary>
            <param name="value">The wrapped <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.GetAwaiter">
            <summary>Returns an awaiter for this <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1"/> instance.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter">
            <summary>Provides an awaiter for a <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter._value">
            <summary>The value being awaited.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.#ctor(System.Threading.Tasks.ValueTask{`0}@)">
            <summary>Initializes the awaiter.</summary>
            <param name="value">The value to be awaited.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.IsCompleted">
            <summary>Gets whether the <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1"/> has completed.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.GetResult">
            <summary>Gets the result of the ValueTask.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.OnCompleted(System.Action)">
            <summary>Schedules the continuation action for the <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1"/>.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1.ConfiguredValueTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation action for the <see cref="T:System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1"/>.</summary>
        </member>
        <member name="E:System.Runtime.CompilerServices.ContractHelper.InternalContractFailed">
            <summary>
            Allows a managed application environment such as an interactive interpreter (IronPython) or a
            web browser host (Jolt hosting Silverlight in IE) to be notified of contract failures and 
            potentially "handle" them, either by throwing a particular exception type, etc.  If any of the
            event handlers sets the Cancel flag in the ContractFailedEventArgs, then the Contract class will
            not pop up an assert dialog box or trigger escalation policy.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ContractHelper.RaiseContractFailedEvent(System.Diagnostics.Contracts.ContractFailureKind,System.String,System.String,System.Exception)">
            <summary>
            Rewriter will call this method on a contract failure to allow listeners to be notified.
            The method should not perform any failure (assert/throw) itself.
            This method has 3 functions:
            1. Call any contract hooks (such as listeners to Contract failed events)
            2. Determine if the listeners deem the failure as handled (then resultFailureMessage should be set to null)
            3. Produce a localized resultFailureMessage used in advertising the failure subsequently.
            On exit: null if the event was handled and should not trigger a failure.
                     Otherwise, returns the localized failure message.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ContractHelper.TriggerFailure(System.Diagnostics.Contracts.ContractFailureKind,System.String,System.String,System.String,System.Exception)">
            <summary>
            Rewriter calls this method to get the default failure behavior.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ExtensionAttribute">
            <summary>
            Indicates that a method is an extension method, or that a class or assembly contains extension methods.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.FormattableStringFactory">
            <summary>
            A factory type used by compilers to create instances of the type <see cref="T:System.FormattableString"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.FormattableStringFactory.Create(System.String,System.Object[])">
            <summary>
            Create a <see cref="T:System.FormattableString"/> from a composite format string and object
            array containing zero or more objects to format.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IAsyncStateMachine">
            <summary>
            Represents state machines generated for asynchronous methods.
            This type is intended for compiler use only.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.IAsyncStateMachine.MoveNext">
            <summary>Moves the state machine to its next state.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.IAsyncStateMachine.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Configures the state machine with a heap-allocated replica.</summary>
            <param name="stateMachine">The heap-allocated replica.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.ICastable">
            <summary>
            Support for dynamic interface casting. Specifically implementing this interface on a type will allow the
            type to support interfaces (for the purposes of casting and interface dispatch) that do not appear in its
            interface map.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.INotifyCompletion">
            <summary>
            Represents an operation that will schedule continuations when the operation completes.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.INotifyCompletion.OnCompleted(System.Action)">
            <summary>Schedules the continuation action to be invoked when the instance completes.</summary>
            <param name="continuation">The action to invoke when the operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="T:System.Runtime.CompilerServices.ICriticalNotifyCompletion">
            <summary>
            Represents an awaiter used to schedule continuations when an await operation completes.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ICriticalNotifyCompletion.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation action to be invoked when the instance completes.</summary>
            <param name="continuation">The action to invoke when the operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <remarks>Unlike OnCompleted, UnsafeOnCompleted need not propagate ExecutionContext information.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsByRefLikeAttribute">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>
            This interface is required for types that want to be indexed into by dynamic patterns.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsReadOnlyAttribute">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RuntimeWrappedException">
            <summary>
            Exception used to wrap all non-CLS compliant exceptions.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.StrongBox`1">
            <summary>
            Holds a reference to a value.
            </summary>
            <typeparam name="T">The type of the value that the <see cref = "T:System.Runtime.CompilerServices.StrongBox`1"></see> references.</typeparam>
        </member>
        <member name="F:System.Runtime.CompilerServices.StrongBox`1.Value">
            <summary>
            Gets the strongly typed value associated with the <see cref = "T:System.Runtime.CompilerServices.StrongBox`1"></see>
            <remarks>This is explicitly exposed as a field instead of a property to enable loading the address of the field.</remarks>
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor">
            <summary>
            Initializes a new StrongBox which can receive a value when used in a reference call.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor(`0)">
            <summary>
            Initializes a new <see cref = "T:System.Runtime.CompilerServices.StrongBox`1"></see> with the specified value.
            </summary>
            <param name="value">A value that the <see cref = "T:System.Runtime.CompilerServices.StrongBox`1"></see> will reference.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.IStrongBox">
            <summary>
            Defines a property for accessing the value that an object references.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.IStrongBox.Value">
            <summary>
            Gets or sets the value the object references.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TaskAwaiter">
            <summary>Provides an awaiter for awaiting a <see cref="T:System.Threading.Tasks.Task"/>.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.TaskAwaiter.m_task">
            <summary>The task being awaited.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.#ctor(System.Threading.Tasks.Task)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to be awaited.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.TaskAwaiter.IsCompleted">
            <summary>Gets whether the task being awaited is completed.</summary>
            <remarks>This property is intended for compiler user rather than use directly in code.</remarks>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.InvalidOperationException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.GetResult">
            <summary>Ends the await on the completed <see cref="T:System.Threading.Tasks.Task"/>.</summary>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The task was canceled.</exception>
            <exception cref="T:System.Exception">The task completed in a Faulted state.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(System.Threading.Tasks.Task)">
            <summary>
            Fast checks for the end of an await operation to determine whether more needs to be done
            prior to completing the await.
            </summary>
            <param name="task">The awaited task.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task)">
            <summary>
            Ensures the task is completed, triggers any necessary debugger breakpoints for completing 
            the await on the task, and throws an exception if the task did not complete successfully.
            </summary>
            <param name="task">The awaited task.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(System.Threading.Tasks.Task)">
            <summary>Throws an exception to handle a task that completed in a state other than RanToCompletion.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.OnCompletedInternal(System.Threading.Tasks.Task,System.Action,System.Boolean,System.Boolean)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="task">The task being awaited.</param>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <param name="continueOnCapturedContext">Whether to capture and marshal back to the current context.</param>
            <param name="flowExecutionContext">Whether to flow ExecutionContext across the await.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.UnsafeOnCompletedInternal(System.Threading.Tasks.Task,System.Runtime.CompilerServices.IAsyncStateMachineBox,System.Boolean)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="task">The task being awaited.</param>
            <param name="stateMachineBox">The box to invoke when the await operation completes.</param>
            <param name="continueOnCapturedContext">Whether to capture and marshal back to the current context.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter.OutputWaitEtwEvents(System.Threading.Tasks.Task,System.Action)">
            <summary>
            Outputs a WaitBegin ETW event, and augments the continuation action to output a WaitEnd ETW event.
            </summary>
            <param name="task">The task being awaited.</param>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <returns>The action to use as the actual continuation.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.TaskAwaiter`1">
            <summary>Provides an awaiter for awaiting a <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.TaskAwaiter`1.m_task">
            <summary>The task being awaited.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.TaskAwaiter`1"/>.</summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task`1"/> to be awaited.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.TaskAwaiter`1.IsCompleted">
            <summary>Gets whether the task being awaited is completed.</summary>
            <remarks>This property is intended for compiler user rather than use directly in code.</remarks>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter`1.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.TaskAwaiter`1.GetResult">
            <summary>Ends the await on the completed <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <returns>The result of the completed <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The task was canceled.</exception>
            <exception cref="T:System.Exception">The task completed in a Faulted state.</exception>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITaskAwaiter">
            <summary>
            Marker interface used to know whether a particular awaiter is either a
            TaskAwaiter or a TaskAwaiter`1.  It must not be implemented by any other
            awaiters.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IConfiguredTaskAwaiter">
            <summary>
            Marker interface used to know whether a particular awaiter is either a
            CTA.ConfiguredTaskAwaiter or a CTA`1.ConfiguredTaskAwaiter.  It must not
            be implemented by any other awaiters.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable">
            <summary>Provides an awaitable object that allows for configured awaits on <see cref="T:System.Threading.Tasks.Task"/>.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.m_configuredTaskAwaiter">
            <summary>The task being awaited.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable"/>.</summary>
            <param name="task">The awaitable <see cref="T:System.Threading.Tasks.Task"/>.</param>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured; otherwise, false.
            </param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.GetAwaiter">
            <summary>Gets an awaiter for this awaitable.</summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter">
            <summary>Provides an awaiter for a <see cref="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable"/>.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.m_task">
            <summary>The task being awaited.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.m_continueOnCapturedContext">
            <summary>Whether to attempt marshaling back to the original context.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter"/>.</summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to await.</param>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured
            when BeginAwait is called; otherwise, false.
            </param>
        </member>
        <member name="P:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.IsCompleted">
            <summary>Gets whether the task being awaited is completed.</summary>
            <remarks>This property is intended for compiler user rather than use directly in code.</remarks>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter.GetResult">
            <summary>Ends the await on the completed <see cref="T:System.Threading.Tasks.Task"/>.</summary>
            <returns>The result of the completed <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The task was canceled.</exception>
            <exception cref="T:System.Exception">The task completed in a Faulted state.</exception>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1">
            <summary>Provides an awaitable object that allows for configured awaits on <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.m_configuredTaskAwaiter">
            <summary>The underlying awaitable on whose logic this awaitable relies.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.#ctor(System.Threading.Tasks.Task{`0},System.Boolean)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1"/>.</summary>
            <param name="task">The awaitable <see cref="T:System.Threading.Tasks.Task`1"/>.</param>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured; otherwise, false.
            </param>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.GetAwaiter">
            <summary>Gets an awaiter for this awaitable.</summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter">
            <summary>Provides an awaiter for a <see cref="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1"/>.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.m_task">
            <summary>The task being awaited.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.m_continueOnCapturedContext">
            <summary>Whether to attempt marshaling back to the original context.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.#ctor(System.Threading.Tasks.Task{`0},System.Boolean)">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter"/>.</summary>
            <param name="task">The awaitable <see cref="T:System.Threading.Tasks.Task`1"/>.</param>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured; otherwise, false.
            </param>
        </member>
        <member name="P:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.IsCompleted">
            <summary>Gets whether the task being awaited is completed.</summary>
            <remarks>This property is intended for compiler user rather than use directly in code.</remarks>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:System.Threading.Tasks.Task"/> associated with this <see cref="T:System.Runtime.CompilerServices.TaskAwaiter"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter.GetResult">
            <summary>Ends the await on the completed <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <returns>The result of the completed <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <exception cref="T:System.NullReferenceException">The awaiter was not properly initialized.</exception>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The task was canceled.</exception>
            <exception cref="T:System.Exception">The task completed in a Faulted state.</exception>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
            Indicates that the use of <see cref="T:System.ValueTuple"/> on a member is meant to be treated as a tuple with element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see
            cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute"/> class.
            </summary>
            <param name="transformNames">
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueType"/> occurrences are
            meant to carry element names.
            </param>
            <remarks>
            This constructor is meant to be used on types that contain an
            instantiation of <see cref="T:System.ValueType"/> that contains
            element names.  For instance, if <c>C</c> is a generic type with
            two type parameters, then a use of the constructed type <c>C{<see
            cref="T:System.ValueTuple`2"/>, <see
            cref="T:System.ValueTuple`3"/></c> might be intended to
            treat the first type argument as a tuple with element names and the
            second as a tuple without element names. In which case, the
            appropriate attribute specification should use a
            <c>transformNames</c> value of <c>{ "name1", "name2", null, null,
            null }</c>.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames">
            <summary>
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple"/> elements are
            meant to carry element names.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ValueTaskAwaiter">
            <summary>Provides an awaiter for a <see cref="T:System.Threading.Tasks.ValueTask"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ValueTaskAwaiter.s_invokeActionDelegate">
            <summary>Shim used to invoke an <see cref="T:System.Action"/> passed as the state argument to a <see cref="T:System.Action`1"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ValueTaskAwaiter._value">
            <summary>The value being awaited.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter.#ctor(System.Threading.Tasks.ValueTask@)">
            <summary>Initializes the awaiter.</summary>
            <param name="value">The value to be awaited.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.ValueTaskAwaiter.IsCompleted">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask"/> has completed.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter.GetResult">
            <summary>Gets the result of the ValueTask.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter.OnCompleted(System.Action)">
            <summary>Schedules the continuation action for this ValueTask.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation action for this ValueTask.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ValueTaskAwaiter`1">
            <summary>Provides an awaiter for a <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.ValueTaskAwaiter`1._value">
            <summary>The value being awaited.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter`1.#ctor(System.Threading.Tasks.ValueTask{`0}@)">
            <summary>Initializes the awaiter.</summary>
            <param name="value">The value to be awaited.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.ValueTaskAwaiter`1.IsCompleted">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask`1"/> has completed.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter`1.GetResult">
            <summary>Gets the result of the ValueTask.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter`1.OnCompleted(System.Action)">
            <summary>Schedules the continuation action for this ValueTask.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.ValueTaskAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation action for this ValueTask.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter">
            <summary>Internal interface used to enable optimizations from <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/>.</summary>>
        </member>
        <member name="M:System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter.AwaitUnsafeOnCompleted(System.Runtime.CompilerServices.IAsyncStateMachineBox)">
            <summary>Invoked to set <see cref="M:System.Threading.Tasks.ITaskCompletionAction.Invoke(System.Threading.Tasks.Task)"/> of the <paramref name="box"/> as the awaiter's continuation.</summary>
            <param name="box">The box object.</param>
        </member>
        <member name="T:System.Runtime.CompilerServices.YieldAwaitable">
            <summary>Provides an awaitable context for switching into a target environment.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.YieldAwaitable.GetAwaiter">
            <summary>Gets an awaiter for this <see cref="T:System.Runtime.CompilerServices.YieldAwaitable"/>.</summary>
            <returns>An awaiter for this awaitable.</returns>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter">
            <summary>Provides an awaiter that switches into a target environment.</summary>
            <remarks>This type is intended for compiler use only.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.IsCompleted">
            <summary>Gets whether a yield is not required.</summary>
            <remarks>This property is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.OnCompleted(System.Action)">
            <summary>Posts the <paramref name="continuation"/> back to the current context.</summary>
            <param name="continuation">The action to invoke asynchronously.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Posts the <paramref name="continuation"/> back to the current context.</summary>
            <param name="continuation">The action to invoke asynchronously.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.QueueContinuation(System.Action,System.Boolean)">
            <summary>Posts the <paramref name="continuation"/> back to the current context.</summary>
            <param name="continuation">The action to invoke asynchronously.</param>
            <param name="flowContext">true to flow ExecutionContext; false if flowing is not required.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="continuation"/> argument is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="F:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.s_waitCallbackRunAction">
            <summary>WaitCallback that invokes the Action supplied as object state.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.s_sendOrPostCallbackRunAction">
            <summary>SendOrPostCallback that invokes the Action supplied as object state.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.RunAction(System.Object)">
            <summary>Runs an Action delegate provided as state.</summary>
            <param name="state">The Action delegate to invoke.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter.GetResult">
            <summary>Ends the await operation.</summary>
        </member>
        <member name="T:System.Runtime.InteropServices.Expando.IExpando">
            <summary>
            IExpando is an interface which allows Objects implementing this interface to
            support the ability to modify the object by adding and removing members,
            represented by MemberInfo objects.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Expando.IExpando.AddField(System.String)">
            <summary>
            Add a new Field to the reflection object. The field has
            name as its name.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Expando.IExpando.RemoveMember(System.Reflection.MemberInfo)">
            <summary>
            Removes the specified member.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.GCHandle">
            <summary>
            Represents an opaque, GC handle to a managed object. A GC handle is used when an
            object reference must be reachable from unmanaged memory.
            </summary>
            <remarks>
            There are 4 kinds of roots:
            Normal: Keeps the object from being collected.
            Weak: Allows object to be collected and handle contents will be zeroed.
            Weak references are zeroed before the finalizer runs, so if the
            object is resurrected in the finalizer the weak reference is still zeroed.
            WeakTrackResurrection: Same as Weak, but stays until after object is really gone.
            Pinned - same as Normal, but allows the address of the actual object to be taken.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.GCHandle.Alloc(System.Object)">
            <summary>Creates a new GC handle for an object.</summary>
            <param name="value">The object that the GC handle is created for.</param>
            <returns>A new GC handle that protects the object.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.GCHandle.Alloc(System.Object,System.Runtime.InteropServices.GCHandleType)">
            <summary>Creates a new GC handle for an object.</summary>
            <param name="value">The object that the GC handle is created for.</param>
            <param name="type">The type of GC handle to create.</param>
            <returns>A new GC handle that protects the object.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.GCHandle.Free">
            <summary>Frees a GC handle.</summary>
        </member>
        <member name="M:System.Runtime.InteropServices.GCHandle.AddrOfPinnedObject">
            <summary>
            Retrieve the address of an object in a Pinned handle.  This throws
            an exception if the handle is any type other than Pinned.
            </summary>
        </member>
        <member name="P:System.Runtime.InteropServices.GCHandle.IsAllocated">
            <summary>Determine whether this handle has been allocated or not.</summary>
        </member>
        <member name="M:System.Runtime.InteropServices.GCHandle.op_Explicit(System.IntPtr)~System.Runtime.InteropServices.GCHandle">
            <summary>
            Used to create a GCHandle from an int.  This is intended to
            be used with the reverse conversion.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.GCHandle.op_Explicit(System.Runtime.InteropServices.GCHandle)~System.IntPtr">
            <summary>Used to get the internal integer representation of the handle out.</summary>
        </member>
        <member name="T:System.Runtime.InteropServices.Marshal">
            <summary>
            This class contains methods that are mainly used to marshal between unmanaged
            and managed types.
            </summary>
            <summary>
            This class contains methods that are mainly used to marshal between unmanaged
            and managed types.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.WriteValueSlow``1(System.Object,System.Int32,``0,System.Action{System.IntPtr,System.Int32,``0})">
            <summary>
            Write value into marshaled object (marshaled using AsAny) and propagate the
            value back. This is quite slow and can return back dangling pointers. It is
            only here for backcompat. People should instead use the IntPtr overloads.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
            <summary>
            Marshals data from a structure class to a native memory block. If the
            structure contains pointers to allocated blocks and "fDeleteOld" is
            true, this routine will call DestroyStructure() first. 
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.PtrToStructureHelper(System.IntPtr,System.Object,System.Boolean)">
            <summary>
            Helper function to copy a pointer into a preallocated structure.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
            <summary>
            Frees all substructures pointed to by the native memory block.
            "structuretype" is used to provide layout information.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
            <summary>
            The default character size for the system. This is always 2 because
            the framework only runs on UTF-16 systems.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
            <summary>
            The max DBCS character size for the system.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
            <summary>
            IMPORTANT NOTICE: This method does not do any verification on the array.
            It must be used with EXTREME CAUTION since passing in invalid index or
            an array that is not pinned can cause unexpected results.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
            <summary>
            Creates a new instance of "structuretype" and marshals data from a
            native memory block to it.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
            <summary>
            Marshals data from a native memory block to a preallocated structure class.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
            <summary>
            Converts the HRESULT to a CLR exception.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
            <summary>
            Throws a CLR exception based on the HRESULT.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
            <summary>
            Generates a GUID for the specified type. If the type has a GUID in the
            metadata then it is returned otherwise a stable guid is generated based
            on the fully qualified name of the type.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
            <summary>
            This method generates a PROGID for the specified type. If the type has
            a PROGID in the metadata then it is returned otherwise a stable PROGID
            is generated based on the fully qualified name of the type.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.NativeLibrary">
            <summary>
            APIs for managing Native Libraries 
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.LoadFromPath(System.String,System.Boolean)">
            External functions that implement the NativeLibrary interface
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.Load(System.String)">
            <summary>
            NativeLibrary Loader: Simple API
            This method is a wrapper around OS loader, using "default" flags.
            </summary>
            <param name="libraryPath">The name of the native library to be loaded</param>
            <returns>The handle for the loaded native library</returns>  
            <exception cref="T:System.ArgumentNullException">If libraryPath is null</exception>
            <exception cref="T:System.DllNotFoundException">If the library can't be found.</exception>
            <exception cref="T:System.BadImageFormatException">If the library is not valid.</exception>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.TryLoad(System.String,System.IntPtr@)">
            <summary>
            NativeLibrary Loader: Simple API that doesn't throw
            </summary>
            <param name="libraryPath">The name of the native library to be loaded</param>
            <param name="handle">The out-parameter for the loaded native library handle</param>
            <returns>True on successful load, false otherwise</returns>  
            <exception cref="T:System.ArgumentNullException">If libraryPath is null</exception>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.Load(System.String,System.Reflection.Assembly,System.Nullable{System.Runtime.InteropServices.DllImportSearchPath})">
            <summary>
            NativeLibrary Loader: High-level API
            Given a library name, this function searches specific paths based on the 
            runtime configuration, input parameters, and attributes of the calling assembly.
            If DllImportSearchPath parameter is non-null, the flags in this enumeration are used.
            Otherwise, the flags specified by the DefaultDllImportSearchPaths attribute on the 
            calling assembly (if any) are used. 
            This LoadLibrary() method does not invoke the managed call-backs for native library resolution: 
            * The per-assembly registered callback 
            * AssemblyLoadContext.LoadUnmanagedDll()
            * AssemblyLoadContext.ResolvingUnmanagedDllEvent
            </summary>
            <param name="libraryName">The name of the native library to be loaded</param>
            <param name="assembly">The assembly loading the native library</param>
            <param name="searchPath">The search path</param>
            <returns>The handle for the loaded library</returns>  
            <exception cref="T:System.ArgumentNullException">If libraryPath or assembly is null</exception>
            <exception cref="T:System.ArgumentException">If assembly is not a RuntimeAssembly</exception>
            <exception cref="T:System.DllNotFoundException">If the library can't be found.</exception>
            <exception cref="T:System.BadImageFormatException">If the library is not valid.</exception>        
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.TryLoad(System.String,System.Reflection.Assembly,System.Nullable{System.Runtime.InteropServices.DllImportSearchPath},System.IntPtr@)">
            <summary>
            NativeLibrary Loader: High-level API that doesn't throw.
            </summary>
            <param name="libraryName">The name of the native library to be loaded</param>
            <param name="searchPath">The search path</param>
            <param name="assembly">The assembly loading the native library</param>
            <param name="handle">The out-parameter for the loaded native library handle</param>
            <returns>True on successful load, false otherwise</returns>  
            <exception cref="T:System.ArgumentNullException">If libraryPath or assembly is null</exception>
            <exception cref="T:System.ArgumentException">If assembly is not a RuntimeAssembly</exception>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.Free(System.IntPtr)">
            <summary>
            Free a loaded library
            Given a library handle, free it.
            No action if the input handle is null.
            </summary>
            <param name="handle">The native library handle to be freed</param>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.GetExport(System.IntPtr,System.String)">
            <summary>
            Get the address of an exported Symbol
            This is a simple wrapper around OS calls, and does not perform any name mangling.
            </summary>
            <param name="handle">The native library handle</param>
            <param name="name">The name of the exported symbol</param>
            <returns>The address of the symbol</returns>  
            <exception cref="T:System.ArgumentNullException">If handle or name is null</exception>
            <exception cref="T:System.EntryPointNotFoundException">If the symbol is not found</exception>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.TryGetExport(System.IntPtr,System.String,System.IntPtr@)">
            <summary>
            Get the address of an exported Symbol, but do not throw
            </summary>
            <param name="handle">The  native library handle</param>
            <param name="name">The name of the exported symbol</param>
            <param name="address"> The out-parameter for the symbol address, if it exists</param>
            <returns>True on success, false otherwise</returns>  
            <exception cref="T:System.ArgumentNullException">If handle or name is null</exception>
        </member>
        <member name="F:System.Runtime.InteropServices.NativeLibrary.s_nativeDllResolveMap">
            <summary>
            Map from assembly to native-library resolver.
            Interop specific fields and properties are generally not added to Assembly class.
            Therefore, this table uses weak assembly pointers to indirectly achieve 
            similar behavior.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.SetDllImportResolver(System.Reflection.Assembly,System.Runtime.InteropServices.DllImportResolver)">
             <summary>
             Set a callback for resolving native library imports from an assembly.
             This per-assembly resolver is the first attempt to resolve native library loads 
             initiated by this assembly.
            
             Only one resolver can be registered per assembly. 
             Trying to register a second resolver fails with InvalidOperationException.
             </summary>
             <param name="assembly">The assembly for which the resolver is registered</param>
             <param name="resolver">The resolver callback to register</param>
             <exception cref="T:System.ArgumentNullException">If assembly or resolver is null</exception>
             <exception cref="T:System.ArgumentException">If a resolver is already set for this assembly</exception>
        </member>
        <member name="M:System.Runtime.InteropServices.NativeLibrary.LoadLibraryCallbackStub(System.String,System.Reflection.Assembly,System.Boolean,System.UInt32)">
            <summary>
            The helper function that calls the per-assembly native-library resolver 
            if one is registered for this assembly.
            </summary>
            <param name="libraryName">The native library to load</param>
            <param name="assembly">The assembly trying load the native library</param>
            <param name="hasDllImportSearchPathFlags">If the pInvoke has DefaultDllImportSearchPathAttribute</param>
            <param name="dllImportSearchPathFlags">If hasdllImportSearchPathFlags is true, the flags in 
                                                  DefaultDllImportSearchPathAttribute; meaningless otherwise </param>
            <returns>The handle for the loaded library on success. Null on failure.</returns>  
        </member>
        <member name="T:System.Runtime.InteropServices.COMException">
            <summary>
            Exception class for all errors from COM Interop where we don't
            recognize the HResult.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.InvalidComObjectException">
            <summary>
            The exception thrown when an invalid COM object is used. This happens
            when a the __ComObject type is used directly without having a backing
            class factory.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
            <summary>
            Exception thrown when the type of an OLE variant that was passed into the
            runtime is invalid.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.MemoryMarshal">
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Memory`1"/>, <see cref="T:System.ReadOnlyMemory`1"/>,
            <see cref="T:System.Span`1"/>, and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <summary>
            Provides a collection of methods for interoperating with <see cref="T:System.Memory`1"/>, <see cref="T:System.ReadOnlyMemory`1"/>,
            <see cref="T:System.Span`1"/>, and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetArray``1(System.ReadOnlyMemory{``0},System.ArraySegment{``0}@)">
            <summary>
            Get an array segment from the underlying memory.
            If unable to get the array segment, return false with a default array segment.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@)">
            <summary>
            Gets an <see cref="T:System.Buffers.MemoryManager`1"/> from the underlying read-only memory.
            If unable to get the <typeparamref name="TManager"/> type, returns false.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <typeparam name="TManager">The type of <see cref="T:System.Buffers.MemoryManager`1"/> to try and retrive.</typeparam>
            <param name="memory">The memory to get the manager for.</param>
            <param name="manager">The returned manager of the <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating if it was successful.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetMemoryManager``2(System.ReadOnlyMemory{``0},``1@,System.Int32@,System.Int32@)">
            <summary>
            Gets an <see cref="T:System.Buffers.MemoryManager`1"/> and <paramref name="start" />, <paramref name="length" /> from the underlying read-only memory.
            If unable to get the <typeparamref name="TManager"/> type, returns false.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <typeparam name="TManager">The type of <see cref="T:System.Buffers.MemoryManager`1"/> to try and retrive.</typeparam>
            <param name="memory">The memory to get the manager for.</param>
            <param name="manager">The returned manager of the <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <param name="start">The offset from the start of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
            <param name="length">The length of the <paramref name="manager" /> that the <paramref name="memory" /> represents.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating if it was successful.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.ToEnumerable``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> view of the given <paramref name="memory" /> to allow
            the <paramref name="memory" /> to be used in existing APIs that take an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The element type of the <paramref name="memory" />.</typeparam>
            <param name="memory">The ReadOnlyMemory to view as an <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> view of the given <paramref name="memory" /></returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryGetString(System.ReadOnlyMemory{System.Char},System.String@,System.Int32@,System.Int32@)">
            <summary>Attempts to get the underlying <see cref="T:System.String"/> from a <see cref="T:System.ReadOnlyMemory`1"/>.</summary>
            <param name="memory">The memory that may be wrapping a <see cref="T:System.String"/> object.</param>
            <param name="text">The string.</param>
            <param name="start">The starting location in <paramref name="text"/>.</param>
            <param name="length">The number of items in <paramref name="text"/>.</param>
            <returns></returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Read``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a structure of type T out of a read-only span of bytes.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryRead``1(System.ReadOnlySpan{System.Byte},``0@)">
            <summary>
            Reads a structure of type T out of a span of bytes.
            <returns>If the span is too small to contain the type T, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Write``1(System.Span{System.Byte},``0@)">
            <summary>
            Writes a structure of type T into a span of bytes.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.TryWrite``1(System.Span{System.Byte},``0@)">
            <summary>
            Writes a structure of type T into a span of bytes.
            <returns>If the span is too small to contain the type T, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.Span{System.Byte})">
            <summary>
            Re-interprets a span of bytes as a reference to structure of type T.
            The type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access or when the memory block is aligned by other means.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsRef``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Re-interprets a span of bytes as a reference to structure of type T.
            The type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access or when the memory block is aligned by other means.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateFromPinnedArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the pre-pinned target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The pre-pinned target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>This method should only be called on an array that is already pinned and 
            that array should not be unpinned while the returned Memory<typeparamref name="T"/> is still in use.
            Calling this method on an unpinned array could result in memory corruption.</remarks>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;=Length).
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.Span{``0})">
            <summary>
            Casts a Span of one primitive type <typeparamref name="T"/> to Span of bytes.
            That type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <param name="span">The source slice, of type <typeparamref name="T"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> contains pointers.
            </exception>
            <exception cref="T:System.OverflowException">
            Thrown if the Length property of the new Span would exceed int.MaxValue.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsBytes``1(System.ReadOnlySpan{``0})">
            <summary>
            Casts a ReadOnlySpan of one primitive type <typeparamref name="T"/> to ReadOnlySpan of bytes.
            That type may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <param name="span">The source slice, of type <typeparamref name="T"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> contains pointers.
            </exception>
            <exception cref="T:System.OverflowException">
            Thrown if the Length property of the new Span would exceed int.MaxValue.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})">
            <summary>Creates a <see cref="T:System.Memory`1"/> from a <see cref="T:System.ReadOnlyMemory`1"/>.</summary>
            <param name="memory">The <see cref="T:System.ReadOnlyMemory`1"/>.</param>
            <returns>A <see cref="T:System.Memory`1"/> representing the same memory as the <see cref="T:System.ReadOnlyMemory`1"/>, but writable.</returns>
            <remarks>
            <see cref="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})"/> must be used with extreme caution.  <see cref="T:System.ReadOnlyMemory`1"/> is used
            to represent immutable data and other memory that is not meant to be written to; <see cref="T:System.Memory`1"/> instances created
            by <see cref="M:System.Runtime.InteropServices.MemoryMarshal.AsMemory``1(System.ReadOnlyMemory{``0})"/> should not be written to.  The method exists to enable variables typed
            as <see cref="T:System.Memory`1"/> but only used for reading to store a <see cref="T:System.ReadOnlyMemory`1"/>.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.Span{``0})">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference may or may not be null. It can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetReference``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns a reference to the 0th element of the ReadOnlySpan. If the ReadOnlySpan is empty, returns a reference to the location where the 0th element
            would have been stored. Such a reference may or may not be null. It can be used for pinning but must never be dereferenced.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetNonNullPinnableReference``1(System.Span{``0})">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns a reference to fake non-null pointer. Such a reference can be used
            for pinning but must never be dereferenced. This is useful for interop with methods that do not accept null pointers for zero-sized buffers.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.GetNonNullPinnableReference``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns a reference to the 0th element of the ReadOnlySpan. If the ReadOnlySpan is empty, returns a reference to fake non-null pointer. Such a reference
            can be used for pinning but must never be dereferenced. This is useful for interop with methods that do not accept null pointers for zero-sized buffers.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.Span{``0})">
            <summary>
            Casts a Span of one primitive type <typeparamref name="TFrom"/> to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access or when the memory block is aligned by other means.
            </remarks>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="TFrom"/> or <typeparamref name="TTo"/> contains pointers.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.Cast``2(System.ReadOnlySpan{``0})">
            <summary>
            Casts a ReadOnlySpan of one primitive type <typeparamref name="TFrom"/> to another primitive type <typeparamref name="TTo"/>.
            These types may not contain pointers or references. This is checked at runtime in order to preserve type safety.
            </summary>
            <remarks>
            Supported only for platforms that support misaligned memory access or when the memory block is aligned by other means.
            </remarks>
            <param name="span">The source slice, of type <typeparamref name="TFrom"/>.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="TFrom"/> or <typeparamref name="TTo"/> contains pointers.
            </exception>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateSpan``1(``0@,System.Int32)">
            <summary>
            Create a new span over a portion of a regular managed object. This can be useful
            if part of a managed object represents a "fixed array." This is dangerous because the
            <paramref name="length"/> is not checked.
            </summary>
            <param name="reference">A reference to data.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <returns>The lifetime of the returned span will not be validated for safety by span-aware languages.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan``1(``0@,System.Int32)">
            <summary>
            Create a new read-only span over a portion of a regular managed object. This can be useful
            if part of a managed object represents a "fixed array." This is dangerous because the
            <paramref name="length"/> is not checked.
            </summary>
            <param name="reference">A reference to data.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <returns>The lifetime of the returned span will not be validated for safety by span-aware languages.</returns>
        </member>
        <member name="T:System.Runtime.InteropServices.NativeCallableAttribute">
            <summary>
            Any method marked with NativeCallableAttribute can be directly called from
            native code. The function token can be loaded to a local variable using LDFTN
            and passed as a callback to native method.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.NativeCallableAttribute.CallingConvention">
            <summary>
            Optional. If omitted, compiler will choose one for you.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.NativeCallableAttribute.EntryPoint">
            <summary>
            Optional. If omitted, then the method is native callable, but no EAT is emitted.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.DllImportResolver">
            <summary>
            A delegate used to resolve native libraries via callback.
            </summary>
            <param name="libraryName">The native library to resolve</param>
            <param name="assembly">The assembly requesting the resolution</param>
            <param name="searchPath">
                The DllImportSearchPathsAttribute on the PInvoke, if any. 
                Otherwise, the DllImportSearchPathsAttribute on the assembly, if any. 
                Otherwise null.
            </param>
            <returns>The handle for the loaded native library on success, null on failure</returns>  
        </member>
        <member name="T:System.Runtime.InteropServices.SafeArrayRankMismatchException">
            <summary>
            The exception is thrown when the runtime rank of a safe array is different
            than the array rank specified in the metadata.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.SafeArrayTypeMismatchException">
            <summary>
            The exception is thrown when the runtime type of an array is different
            than the safe array sub type specified in the metadata.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt64)">
            <summary>
            Specifies the size of the region of memory, in bytes.  Must be
            called before using the SafeBuffer.
            </summary>
            <param name="numBytes">Number of valid bytes in memory.</param>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.Initialize(System.UInt32,System.UInt32)">
            <summary>
            Specifies the size of the region in memory, as the number of
            elements in an array.  Must be called before using the SafeBuffer.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.Initialize``1(System.UInt32)">
            <summary>
            Specifies the size of the region in memory, as the number of
            elements in an array.  Must be called before using the SafeBuffer.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.AcquirePointer(System.Byte*@)">
            <summary>
            Obtain the pointer from a SafeBuffer for a block of code,
            with the express responsibility for bounds checking and calling
            ReleasePointer later to ensure the pointer can be freed later.
            This method either completes successfully or throws an exception 
            and returns with pointer set to null.
            </summary>
            <param name="pointer">A byte*, passed by reference, to receive
            the pointer from within the SafeBuffer.  You must set
            pointer to null before calling this method.</param>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.Read``1(System.UInt64)">
            <summary>
            Read a value type from memory at the given offset.  This is
            equivalent to:  return *(T*)(bytePtr + byteOffset);
            </summary>
            <typeparam name="T">The value type to read</typeparam>
            <param name="byteOffset">Where to start reading from memory.  You
            may have to consider alignment.</param>
            <returns>An instance of T read from memory.</returns>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.Write``1(System.UInt64,``0)">
            <summary>
            Write a value type to memory at the given offset.  This is
            equivalent to:  *(T*)(bytePtr + byteOffset) = value;
            </summary>
            <typeparam name="T">The type of the value type to write to memory.</typeparam>
            <param name="byteOffset">The location in memory to write to.  You
            may have to consider alignment.</param>
            <param name="value">The value type to write to memory.</param>
        </member>
        <member name="P:System.Runtime.InteropServices.SafeBuffer.ByteLength">
            <summary>
            Returns the number of bytes in the memory region.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.AlignedSizeOf``1">
            <summary>
            Returns the size that SafeBuffer (and hence, UnmanagedMemoryAccessor) reserves in the unmanaged buffer for each element of an array of T. This is not the same
            value that sizeof(T) returns! Since the primary use case is to parse memory mapped files, we cannot change this algorithm as this defines a de-facto serialization format.
            Throws if T contains GC references.
            </summary>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeBuffer.SizeOf``1">
            <summary>
            Returns same value as sizeof(T) but throws if T contains GC references.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.SafeHandle">
            <summary>Represents a wrapper class for operating system handles.</summary>
        </member>
        <member name="F:System.Runtime.InteropServices.SafeHandle.handle">
            <summary>Specifies the handle to be wrapped.</summary>
        </member>
        <member name="F:System.Runtime.InteropServices.SafeHandle._state">
            <summary>Combined ref count and closed/disposed flags (so we can atomically modify them).</summary>
        </member>
        <member name="F:System.Runtime.InteropServices.SafeHandle._ownsHandle">
            <summary>Whether we can release this handle.</summary>
        </member>
        <member name="F:System.Runtime.InteropServices.SafeHandle._fullyInitialized">
            <summary>Whether constructor completed.</summary>
        </member>
        <member name="T:System.Runtime.InteropServices.SafeHandle.StateBits">
             <summary>Bitmasks for the <see cref="F:System.Runtime.InteropServices.SafeHandle._state"/> field.</summary>
             <remarks>
             The state field ends up looking like this:
            
              31                                                        2  1   0
             +-----------------------------------------------------------+---+---+
             |                           Ref count                       | D | C |
             +-----------------------------------------------------------+---+---+
             
             Where D = 1 means a Dispose has been performed and C = 1 means the
             underlying handle has been (or will be shortly) released.
             </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>Creates a SafeHandle class.</summary>
        </member>
        <member name="T:System.Runtime.InteropServices.SEHException">
            <summary>
            Exception for Structured Exception Handler exceptions.
            </summary>
        </member>
        <member name="F:System.Runtime.Loader.AssemblyDependencyResolver.NeutralCultureName">
            <summary>
            The name of the neutral culture (same value as in Variables::Init in CoreCLR)
            </summary>
        </member>
        <member name="F:System.Runtime.Loader.AssemblyDependencyResolver.ResourceAssemblyExtension">
            <summary>
            The extension of resource assembly (same as in BindSatelliteResourceByResourceRoots in CoreCLR)
            </summary>
        </member>
        <member name="F:System.Runtime.Loader.AssemblyLoadContext.InternalState.Alive">
            <summary>
            The ALC is alive (default)
            </summary>
        </member>
        <member name="F:System.Runtime.Loader.AssemblyLoadContext.InternalState.Unloading">
            <summary>
            The unload process has started, the Unloading event will be called
            once the underlying LoaderAllocator has been finalized
            </summary>
        </member>
        <member name="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext">
             <summary>Nullable current AssemblyLoadContext used for context sensitive reflection APIs</summary>
             <remarks>
             This is an advanced setting used in reflection assembly loading scenarios.
            
             There are a set of contextual reflection APIs which load managed assemblies through an inferred AssemblyLoadContext.
             * <see cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
             * <see cref="M:System.Reflection.Assembly.Load(System.String)" />
             * <see cref="M:System.Reflection.Assembly.GetType(System.String)" />
             * <see cref="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
            
             When CurrentContextualReflectionContext is null, the AssemblyLoadContext is inferred.
             The inference logic is simple.
             * For static methods, it is the AssemblyLoadContext which loaded the method caller's assembly.
             * For instance methods, it is the AssemblyLoadContext which loaded the instance's assembly.
            
             When this property is set, the CurrentContextualReflectionContext value is used by these contextual reflection APIs for loading.
            
             This property is typically set in a using block by
             <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection"/>.
            
             The property is stored in an AsyncLocal&lt;AssemblyLoadContext&gt;. This means the setting can be unique for every async or thread in the process.
            
             For more details see https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/AssemblyLoadContext.ContextualReflection.md
             </remarks>
        </member>
        <member name="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection">
             <summary>Enter scope using this AssemblyLoadContext for ContextualReflection</summary>
             <returns>A disposable ContextualReflectionScope for use in a using block</returns>
             <remarks>
             Sets CurrentContextualReflectionContext to this instance.
             <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext"/>
            
             Returns a disposable ContextualReflectionScope for use in a using block. When the using calls the
             Dispose() method, it restores the ContextualReflectionScope to its previous value.
             </remarks>
        </member>
        <member name="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection(System.Reflection.Assembly)">
             <summary>Enter scope using this AssemblyLoadContext for ContextualReflection</summary>
             <param name="activating">Set CurrentContextualReflectionContext to the AssemblyLoadContext which loaded activating.</param>
             <returns>A disposable ContextualReflectionScope for use in a using block</returns>
             <remarks>
             Sets CurrentContextualReflectionContext to to the AssemblyLoadContext which loaded activating.
             <see cref="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext"/>
            
             Returns a disposable ContextualReflectionScope for use in a using block. When the using calls the
             Dispose() method, it restores the ContextualReflectionScope to its previous value.
             </remarks>
        </member>
        <member name="T:System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope">
            <summary>Opaque disposable struct used to restore CurrentContextualReflectionContext</summary>
            <remarks>
            This is an implmentation detail of the AssemblyLoadContext.EnterContextualReflection APIs.
            It is a struct, to avoid heap allocation.
            It is required to be public to avoid boxing.
            <see cref="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection"/>
            </remarks>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.As``2(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <typeparam name="U">The type of the vector <paramref name="vector" /> should be reinterpreted as.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) or the type of the target (<typeparamref name="U" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsByte``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsDouble``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsInt16``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsInt32``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsInt64``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsSByte``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsSingle``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsUInt16``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsUInt32``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.AsUInt64``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Int32,System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.Single,System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.Create(System.UInt32,System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalar(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalar(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalar(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalar(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalar(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalar(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalar(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalarUnsafe(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalarUnsafe(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalarUnsafe(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalarUnsafe(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalarUnsafe(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalarUnsafe(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.CreateScalarUnsafe(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instance with the first element initialized to <paramref name="value"/> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.GetElement``1(System.Runtime.Intrinsics.Vector64{``0},System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the element from.</param>
            <param name="index">The index of the element to get.</param>
            <returns>The value of the element at <paramref name="index" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.WithElement``1(System.Runtime.Intrinsics.Vector64{``0},System.Int32,``0)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with the element at the specified index set to the specified value and the remaining elements set to the same value as that in the given vector.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the remaining elements from.</param>
            <param name="index">The index of the element to set.</param>
            <param name="value">The value to set the element to.</param>
            <returns>A <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with the value of the element at <paramref name="index" /> set to <paramref name="value" /> and the remaining elements set to the same value as that in <paramref name="vector" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.ToScalar``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Converts the given vector to a scalar containing the value of the first element.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the first element from.</param>
            <returns>A scalar <typeparamref name="T" /> containing the value of the first element.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.ToVector128``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Converts the given vector to a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the lower 64-bits set to the value of the given vector and the upper 64-bits initialized to zero.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to extend.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the lower 64-bits set to the value of <paramref name="vector" /> and the upper 64-bits initialized to zero.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64.ToVector128Unsafe``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Converts the given vector to a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the lower 64-bits set to the value of the given vector and the upper 64-bits left uninitialized.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to extend.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the lower 64-bits set to the value of <paramref name="vector" /> and the upper 64-bits left uninitialized.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="P:System.Runtime.Intrinsics.Vector64`1.Count">
            <summary>Gets the number of <typeparamref name="T" /> that are in a <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="P:System.Runtime.Intrinsics.Vector64`1.Zero">
            <summary>Gets a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> with all elements initialized to zero.</summary>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64`1.Equals(System.Runtime.Intrinsics.Vector64{`0})">
            <summary>Determines whether the specified <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> is equal to the current instance.</summary>
            <param name="other">The <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> to compare with the current instance.</param>
            <returns><c>true</c> if <paramref name="other" /> is equal to the current instance; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64`1.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current instance.</summary>
            <param name="obj">The object to compare with the current instance.</param>
            <returns><c>true</c> if <paramref name="obj" /> is a <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> and is equal to the current instance; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64`1.GetHashCode">
            <summary>Gets the hash code for the instance.</summary>
            <returns>The hash code for the instance.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector64`1.ToString">
            <summary>Converts the current instance to an equivalent string representation.</summary>
            <returns>An equivalent string representation of the current instance.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.As``2(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <typeparam name="U">The type of the vector <paramref name="vector" /> should be reinterpreted as.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) or the type of the target (<typeparamref name="U" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsByte``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsDouble``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsInt16``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsInt32``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsInt64``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsSByte``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsSingle``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsUInt16``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsUInt32``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.AsUInt64``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <param name="e8">The value that element 8 will be initialized to.</param>
            <param name="e9">The value that element 9 will be initialized to.</param>
            <param name="e10">The value that element 10 will be initialized to.</param>
            <param name="e11">The value that element 11 will be initialized to.</param>
            <param name="e12">The value that element 12 will be initialized to.</param>
            <param name="e13">The value that element 13 will be initialized to.</param>
            <param name="e14">The value that element 14 will be initialized to.</param>
            <param name="e15">The value that element 15 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Double,System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Int64,System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <param name="e8">The value that element 8 will be initialized to.</param>
            <param name="e9">The value that element 9 will be initialized to.</param>
            <param name="e10">The value that element 10 will be initialized to.</param>
            <param name="e11">The value that element 11 will be initialized to.</param>
            <param name="e12">The value that element 12 will be initialized to.</param>
            <param name="e13">The value that element 13 will be initialized to.</param>
            <param name="e14">The value that element 14 will be initialized to.</param>
            <param name="e15">The value that element 15 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.UInt64,System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.Byte},System.Runtime.Intrinsics.Vector64{System.Byte})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.Double},System.Runtime.Intrinsics.Vector64{System.Double})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.Int16},System.Runtime.Intrinsics.Vector64{System.Int16})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.Int32},System.Runtime.Intrinsics.Vector64{System.Int32})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.Int64},System.Runtime.Intrinsics.Vector64{System.Int64})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.SByte},System.Runtime.Intrinsics.Vector64{System.SByte})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.Single},System.Runtime.Intrinsics.Vector64{System.Single})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.UInt16},System.Runtime.Intrinsics.Vector64{System.UInt16})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.UInt32},System.Runtime.Intrinsics.Vector64{System.UInt32})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.Create(System.Runtime.Intrinsics.Vector64{System.UInt64},System.Runtime.Intrinsics.Vector64{System.UInt64})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector64`1" /> instances.</summary>
            <param name="lower">The value that the lower 64-bits will be initialized to.</param>
            <param name="upper">The value that the upper 64-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalar(System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.CreateScalarUnsafe(System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.GetElement``1(System.Runtime.Intrinsics.Vector128{``0},System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the element from.</param>
            <param name="index">The index of the element to get.</param>
            <returns>The value of the element at <paramref name="index" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.WithElement``1(System.Runtime.Intrinsics.Vector128{``0},System.Int32,``0)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the element at the specified index set to the specified value and the remaining elements set to the same value as that in the given vector.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the remaining elements from.</param>
            <param name="index">The index of the element to set.</param>
            <param name="value">The value to set the element to.</param>
            <returns>A <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the value of the element at <paramref name="index" /> set to <paramref name="value" /> and the remaining elements set to the same value as that in <paramref name="vector" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.GetLower``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Gets the value of the lower 64-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the lower 64-bits from.</param>
            <returns>The value of the lower 64-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.WithLower``1(System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the lower 64-bits set to the specified value and the upper 64-bits set to the same value as that in the given vector.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the upper 64-bits from.</param>
            <param name="value">The value of the lower 64-bits as a <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the lower 64-bits set to the specified value and the upper 64-bits set to the same value as that in <paramref name="vector" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.GetUpper``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Gets the value of the upper 64-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the upper 64-bits from.</param>
            <returns>The value of the upper 64-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.WithUpper``1(System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the upper 64-bits set to the specified value and the upper 64-bits set to the same value as that in the given vector.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the lower 64-bits from.</param>
            <param name="value">The value of the upper 64-bits as a <see cref="T:System.Runtime.Intrinsics.Vector64`1" />.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with the upper 64-bits set to the specified value and the upper 64-bits set to the same value as that in <paramref name="vector" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.ToScalar``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Converts the given vector to a scalar containing the value of the first element.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the first element from.</param>
            <returns>A scalar <typeparamref name="T" /> containing the value of the first element.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.ToVector256``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Converts the given vector to a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the lower 128-bits set to the value of the given vector and the upper 128-bits initialized to zero.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to extend.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the lower 128-bits set to the value of <paramref name="vector" /> and the upper 128-bits initialized to zero.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128.ToVector256Unsafe``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Converts the given vector to a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the lower 128-bits set to the value of the given vector and the upper 128-bits left uninitialized.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to extend.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the lower 128-bits set to the value of <paramref name="vector" /> and the upper 128-bits left uninitialized.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="P:System.Runtime.Intrinsics.Vector128`1.Count">
            <summary>Gets the number of <typeparamref name="T" /> that are in a <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="P:System.Runtime.Intrinsics.Vector128`1.Zero">
            <summary>Gets a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> with all elements initialized to zero.</summary>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128`1.Equals(System.Runtime.Intrinsics.Vector128{`0})">
            <summary>Determines whether the specified <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> is equal to the current instance.</summary>
            <param name="other">The <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> to compare with the current instance.</param>
            <returns><c>true</c> if <paramref name="other" /> is equal to the current instance; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128`1.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current instance.</summary>
            <param name="obj">The object to compare with the current instance.</param>
            <returns><c>true</c> if <paramref name="obj" /> is a <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> and is equal to the current instance; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128`1.GetHashCode">
            <summary>Gets the hash code for the instance.</summary>
            <returns>The hash code for the instance.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector128`1.ToString">
            <summary>Converts the current instance to an equivalent string representation.</summary>
            <returns>An equivalent string representation of the current instance.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.As``2(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <typeparam name="U">The type of the vector <paramref name="vector" /> should be reinterpreted as.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) or the type of the target (<typeparamref name="U" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsByte``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsDouble``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsInt16``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsInt32``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsInt64``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsSByte``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsSingle``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsUInt16``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsUInt32``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.AsUInt64``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Reinterprets a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to reinterpret.</param>
            <returns><paramref name="vector" /> reinterpreted as a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with all elements initialized to the specified value.</summary>
            <param name="value">The value that all elements will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to <paramref name="value" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <param name="e8">The value that element 8 will be initialized to.</param>
            <param name="e9">The value that element 9 will be initialized to.</param>
            <param name="e10">The value that element 10 will be initialized to.</param>
            <param name="e11">The value that element 11 will be initialized to.</param>
            <param name="e12">The value that element 12 will be initialized to.</param>
            <param name="e13">The value that element 13 will be initialized to.</param>
            <param name="e14">The value that element 14 will be initialized to.</param>
            <param name="e15">The value that element 15 will be initialized to.</param>
            <param name="e16">The value that element 16 will be initialized to.</param>
            <param name="e17">The value that element 17 will be initialized to.</param>
            <param name="e18">The value that element 18 will be initialized to.</param>
            <param name="e19">The value that element 19 will be initialized to.</param>
            <param name="e20">The value that element 20 will be initialized to.</param>
            <param name="e21">The value that element 21 will be initialized to.</param>
            <param name="e22">The value that element 22 will be initialized to.</param>
            <param name="e23">The value that element 23 will be initialized to.</param>
            <param name="e24">The value that element 24 will be initialized to.</param>
            <param name="e25">The value that element 25 will be initialized to.</param>
            <param name="e26">The value that element 26 will be initialized to.</param>
            <param name="e27">The value that element 27 will be initialized to.</param>
            <param name="e28">The value that element 28 will be initialized to.</param>
            <param name="e29">The value that element 29 will be initialized to.</param>
            <param name="e30">The value that element 30 will be initialized to.</param>
            <param name="e31">The value that element 31 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Double,System.Double,System.Double,System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <param name="e8">The value that element 8 will be initialized to.</param>
            <param name="e9">The value that element 9 will be initialized to.</param>
            <param name="e10">The value that element 10 will be initialized to.</param>
            <param name="e11">The value that element 11 will be initialized to.</param>
            <param name="e12">The value that element 12 will be initialized to.</param>
            <param name="e13">The value that element 13 will be initialized to.</param>
            <param name="e14">The value that element 14 will be initialized to.</param>
            <param name="e15">The value that element 15 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <param name="e8">The value that element 8 will be initialized to.</param>
            <param name="e9">The value that element 9 will be initialized to.</param>
            <param name="e10">The value that element 10 will be initialized to.</param>
            <param name="e11">The value that element 11 will be initialized to.</param>
            <param name="e12">The value that element 12 will be initialized to.</param>
            <param name="e13">The value that element 13 will be initialized to.</param>
            <param name="e14">The value that element 14 will be initialized to.</param>
            <param name="e15">The value that element 15 will be initialized to.</param>
            <param name="e16">The value that element 16 will be initialized to.</param>
            <param name="e17">The value that element 17 will be initialized to.</param>
            <param name="e18">The value that element 18 will be initialized to.</param>
            <param name="e19">The value that element 19 will be initialized to.</param>
            <param name="e20">The value that element 20 will be initialized to.</param>
            <param name="e21">The value that element 21 will be initialized to.</param>
            <param name="e22">The value that element 22 will be initialized to.</param>
            <param name="e23">The value that element 23 will be initialized to.</param>
            <param name="e24">The value that element 24 will be initialized to.</param>
            <param name="e25">The value that element 25 will be initialized to.</param>
            <param name="e26">The value that element 26 will be initialized to.</param>
            <param name="e27">The value that element 27 will be initialized to.</param>
            <param name="e28">The value that element 28 will be initialized to.</param>
            <param name="e29">The value that element 29 will be initialized to.</param>
            <param name="e30">The value that element 30 will be initialized to.</param>
            <param name="e31">The value that element 31 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <param name="e8">The value that element 8 will be initialized to.</param>
            <param name="e9">The value that element 9 will be initialized to.</param>
            <param name="e10">The value that element 10 will be initialized to.</param>
            <param name="e11">The value that element 11 will be initialized to.</param>
            <param name="e12">The value that element 12 will be initialized to.</param>
            <param name="e13">The value that element 13 will be initialized to.</param>
            <param name="e14">The value that element 14 will be initialized to.</param>
            <param name="e15">The value that element 15 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <param name="e4">The value that element 4 will be initialized to.</param>
            <param name="e5">The value that element 5 will be initialized to.</param>
            <param name="e6">The value that element 6 will be initialized to.</param>
            <param name="e7">The value that element 7 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with each element initialized to the corresponding specified value.</summary>
            <param name="e0">The value that element 0 will be initialized to.</param>
            <param name="e1">The value that element 1 will be initialized to.</param>
            <param name="e2">The value that element 2 will be initialized to.</param>
            <param name="e3">The value that element 3 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with each element initialized to corresponding specified value.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.Create(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance from two <see cref="T:System.Runtime.Intrinsics.Vector128`1" /> instances.</summary>
            <param name="lower">The value that the lower 128-bits will be initialized to.</param>
            <param name="upper">The value that the upper 128-bits will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> initialized from <paramref name="lower" /> and <paramref name="upper" />.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalar(System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements initialized to zero.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements initialized to zero.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.Byte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.Double)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.Int16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.Int32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.Int64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.SByte)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.Single)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.UInt16)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.UInt32)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.CreateScalarUnsafe(System.UInt64)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to the specified value and the remaining elements left uninitialized.</summary>
            <param name="value">The value that element 0 will be initialized to.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> instance with the first element initialized to <paramref name="value" /> and the remaining elements left uninitialized.</returns>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.GetElement``1(System.Runtime.Intrinsics.Vector256{``0},System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the element from.</param>
            <param name="index">The index of the element to get.</param>
            <returns>The value of the element at <paramref name="index" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.WithElement``1(System.Runtime.Intrinsics.Vector256{``0},System.Int32,``0)">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the element at the specified index set to the specified value and the remaining elements set to the same value as that in the given vector.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the remaining elements from.</param>
            <param name="index">The index of the element to set.</param>
            <param name="value">The value to set the element to.</param>
            <returns>A <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the value of the element at <paramref name="index" /> set to <paramref name="value" /> and the remaining elements set to the same value as that in <paramref name="vector" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> was less than zero or greater than the number of elements.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.GetLower``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Gets the value of the lower 128-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the lower 128-bits from.</param>
            <returns>The value of the lower 128-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.WithLower``1(System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the lower 128-bits set to the specified value and the upper 128-bits set to the same value as that in the given vector.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the upper 128-bits from.</param>
            <param name="value">The value of the lower 128-bits as a <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the lower 128-bits set to the specified value and the upper 128-bits set to the same value as that in <paramref name="vector" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.GetUpper``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Gets the value of the upper 128-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the upper 128-bits from.</param>
            <returns>The value of the upper 128-bits as a new <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.WithUpper``1(System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector128{``0})">
            <summary>Creates a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the upper 128-bits set to the specified value and the upper 128-bits set to the same value as that in the given vector.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the lower 128-bits from.</param>
            <param name="value">The value of the upper 128-bits as a <see cref="T:System.Runtime.Intrinsics.Vector128`1" />.</param>
            <returns>A new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with the upper 128-bits set to the specified value and the upper 128-bits set to the same value as that in <paramref name="vector" />.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256.ToScalar``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>Converts the given vector to a scalar containing the value of the first element.</summary>
            <typeparam name="T">The type of the input vector.</typeparam>
            <param name="vector">The vector to get the first element from.</param>
            <returns>A scalar <typeparamref name="T" /> containing the value of the first element.</returns>
            <exception cref="T:System.NotSupportedException">The type of <paramref name="vector" /> (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="P:System.Runtime.Intrinsics.Vector256`1.Count">
            <summary>Gets the number of <typeparamref name="T" /> that are in a <see cref="T:System.Runtime.Intrinsics.Vector256`1" />.</summary>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="P:System.Runtime.Intrinsics.Vector256`1.Zero">
            <summary>Gets a new <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> with all elements initialized to zero.</summary>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256`1.Equals(System.Runtime.Intrinsics.Vector256{`0})">
            <summary>Determines whether the specified <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> is equal to the current instance.</summary>
            <param name="other">The <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> to compare with the current instance.</param>
            <returns><c>true</c> if <paramref name="other" /> is equal to the current instance; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256`1.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current instance.</summary>
            <param name="obj">The object to compare with the current instance.</param>
            <returns><c>true</c> if <paramref name="obj" /> is a <see cref="T:System.Runtime.Intrinsics.Vector256`1" /> and is equal to the current instance; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256`1.GetHashCode">
            <summary>Gets the hash code for the instance.</summary>
            <returns>The hash code for the instance.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="M:System.Runtime.Intrinsics.Vector256`1.ToString">
            <summary>Converts the current instance to an equivalent string representation.</summary>
            <returns>An equivalent string representation of the current instance.</returns>
            <exception cref="T:System.NotSupportedException">The type of the current instance (<typeparamref name="T" />) is not supported.</exception>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedEqualNonSignaling">
            <summary>
            _CMP_EQ_OQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedLessThanSignaling">
            <summary>
            _CMP_LT_OS
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedLessThanOrEqualSignaling">
            <summary>
            _CMP_LE_OS
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNonSignaling">
            <summary>
            _CMP_UNORD_Q
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotEqualNonSignaling">
            <summary>
            _CMP_NEQ_UQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotLessThanSignaling">
            <summary>
            _CMP_NLT_US
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotLessThanOrEqualSignaling">
            <summary>
            _CMP_NLE_US
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedNonSignaling">
            <summary>
            _CMP_ORD_Q
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedEqualNonSignaling">
            <summary>
            _CMP_EQ_UQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotGreaterThanOrEqualSignaling">
            <summary>
            _CMP_NGE_US
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotGreaterThanSignaling">
            <summary>
            _CMP_NGT_US
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedFalseNonSignaling">
            <summary>
            _CMP_FALSE_OQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedNotEqualNonSignaling">
            <summary>
            _CMP_NEQ_OQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedGreaterThanOrEqualSignaling">
            <summary>
            _CMP_GE_OS
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedGreaterThanSignaling">
            <summary>
            _CMP_GT_OS
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedTrueNonSignaling">
            <summary>
            _CMP_TRUE_UQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedEqualSignaling">
            <summary>
            _CMP_EQ_OS
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedLessThanNonSignaling">
            <summary>
            _CMP_LT_OQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedLessThanOrEqualNonSignaling">
            <summary>
            _CMP_LE_OQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedSignaling">
            <summary>
            _CMP_UNORD_S
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotEqualSignaling">
            <summary>
            _CMP_NEQ_US
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotLessThanNonSignaling">
            <summary>
            _CMP_NLT_UQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotLessThanOrEqualNonSignaling">
            <summary>
            _CMP_NLE_UQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedSignaling">
            <summary>
            _CMP_ORD_S
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedEqualSignaling">
            <summary>
            _CMP_EQ_US
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotGreaterThanOrEqualNonSignaling">
            <summary>
            _CMP_NGE_UQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedNotGreaterThanNonSignaling">
            <summary>
            _CMP_NGT_UQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedFalseSignaling">
            <summary>
            _CMP_FALSE_OS
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedNotEqualSignaling">
            <summary>
            _CMP_NEQ_OS
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedGreaterThanOrEqualNonSignaling">
            <summary>
            _CMP_GE_OQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.OrderedGreaterThanNonSignaling">
            <summary>
            _CMP_GT_OQ
            </summary>
        </member>
        <member name="F:System.Runtime.Intrinsics.X86.FloatComparisonMode.UnorderedTrueSignaling">
            <summary>
            _CMP_TRUE_US
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Aes">
            <summary>
            This class provides access to Intel AES hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Aes.Decrypt(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesdec_si128 (__m128i a, __m128i RoundKey)
              AESDEC xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Aes.DecryptLast(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesdeclast_si128 (__m128i a, __m128i RoundKey)
              AESDECLAST xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Aes.Encrypt(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey)
              AESENC xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Aes.EncryptLast(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey)
              AESENCLAST xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Aes.InverseMixColumns(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesimc_si128 (__m128i a)
              AESIMC xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Aes.KeygenAssist(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_aeskeygenassist_si128 (__m128i a, const int imm8)
              AESKEYGENASSIST xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Avx">
            <summary>
            This class provides access to Intel AVX hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Add(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_add_ps (__m256 a, __m256 b)
              VADDPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Add(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_add_pd (__m256d a, __m256d b)
              VADDPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.AddSubtract(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_addsub_ps (__m256 a, __m256 b)
              VADDSUBPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.AddSubtract(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_addsub_pd (__m256d a, __m256d b)
              VADDSUBPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.And(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_and_ps (__m256 a, __m256 b)
              VANDPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.And(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_and_pd (__m256d a, __m256d b)
              VANDPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.AndNot(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_andnot_ps (__m256 a, __m256 b)
              VANDNPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.AndNot(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_andnot_pd (__m256d a, __m256d b)
              VANDNPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Blend(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_blend_ps (__m256 a, __m256 b, const int imm8)
              VBLENDPS ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Blend(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8)
              VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.BlendVariable(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask)
              VBLENDVPS ymm, ymm, ymm/m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.BlendVariable(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)
              VBLENDVPD ymm, ymm, ymm/m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.BroadcastScalarToVector128(System.Single*)">
            <summary>
            __m128 _mm_broadcast_ss (float const * mem_addr)
              VBROADCASTSS xmm, m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.BroadcastScalarToVector256(System.Single*)">
            <summary>
            __m256 _mm256_broadcast_ss (float const * mem_addr)
              VBROADCASTSS ymm, m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.BroadcastScalarToVector256(System.Double*)">
            <summary>
            __m256d _mm256_broadcast_sd (double const * mem_addr)
              VBROADCASTSD ymm, m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.BroadcastVector128ToVector256(System.Single*)">
            <summary>
            __m256 _mm256_broadcast_ps (__m128 const * mem_addr)
              VBROADCASTF128, ymm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.BroadcastVector128ToVector256(System.Double*)">
            <summary>
            __m256d _mm256_broadcast_pd (__m128d const * mem_addr)
              VBROADCASTF128, ymm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Ceiling(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_ceil_ps (__m256 a)
              VROUNDPS ymm, ymm/m256, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Ceiling(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_ceil_pd (__m256d a)
              VROUNDPD ymm, ymm/m256, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Compare(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.X86.FloatComparisonMode)">
            <summary>
            __m128 _mm_cmp_ps (__m128 a, __m128 b, const int imm8)
              VCMPPS xmm, xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Compare(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.X86.FloatComparisonMode)">
            <summary>
            __m128d _mm_cmp_pd (__m128d a, __m128d b, const int imm8)
              VCMPPD xmm, xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Compare(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.X86.FloatComparisonMode)">
            <summary>
            __m256 _mm256_cmp_ps (__m256 a, __m256 b, const int imm8)
              VCMPPS ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Compare(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.X86.FloatComparisonMode)">
            <summary>
            __m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)
              VCMPPD ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.CompareScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.X86.FloatComparisonMode)">
            <summary>
            __m128d _mm_cmp_sd (__m128d a, __m128d b, const int imm8)
              VCMPSS xmm, xmm, xmm/m32, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.CompareScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.X86.FloatComparisonMode)">
            <summary>
            __m128 _mm_cmp_ss (__m128 a, __m128 b, const int imm8)
              VCMPSD xmm, xmm, xmm/m64, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector128Int32(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m128i _mm256_cvtpd_epi32 (__m256d a)
              VCVTPD2DQ xmm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector128Single(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m128 _mm256_cvtpd_ps (__m256d a)
              VCVTPD2PS xmm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Int32(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256i _mm256_cvtps_epi32 (__m256 a)
              VCVTPS2DQ ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Single(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256 _mm256_cvtepi32_ps (__m256i a)
              VCVTDQ2PS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Double(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m256d _mm256_cvtps_pd (__m128 a)
              VCVTPS2PD ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Double(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m256d _mm256_cvtepi32_pd (__m128i a)
              VCVTDQ2PD ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector128Int32WithTruncation(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m128i _mm256_cvttpd_epi32 (__m256d a)
              VCVTTPD2DQ xmm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Int32WithTruncation(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256i _mm256_cvttps_epi32 (__m256 a)
              VCVTTPS2DQ ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Divide(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_div_ps (__m256 a, __m256 b)
              VDIVPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Divide(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_div_pd (__m256d a, __m256d b)
              VDIVPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.DotProduct(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_dp_ps (__m256 a, __m256 b, const int imm8)
              VDPPS ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.DuplicateEvenIndexed(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_moveldup_ps (__m256 a)
              VMOVSLDUP ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.DuplicateEvenIndexed(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_movedup_pd (__m256d a)
              VMOVDDUP ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.DuplicateOddIndexed(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_movehdup_ps (__m256 a)
              VMOVSHDUP ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m128 _mm256_extractf128_ps (__m256 a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m128d _mm256_extractf128_pd (__m256d a, const int imm8)
              VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Floor(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_floor_ps (__m256 a)
              VROUNDPS ymm, ymm/m256, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Floor(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_floor_pd (__m256d a)
              VROUNDPS ymm, ymm/m256, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.HorizontalAdd(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_hadd_ps (__m256 a, __m256 b)
              VHADDPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.HorizontalAdd(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_hadd_pd (__m256d a, __m256d b)
              VHADDPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.HorizontalSubtract(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_hsub_ps (__m256 a, __m256 b)
              VHSUBPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.HorizontalSubtract(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_hsub_pd (__m256d a, __m256d b)
              VHSUBPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_insertf128_ps (__m256 a, __m128 b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_insertf128_pd (__m256d a, __m128d b, int imm8)
              VINSERTF128 ymm, ymm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.SByte*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.Byte*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.Int16*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.UInt16*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.Int32*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.UInt32*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.Int64*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.UInt64*)">
            <summary>
            __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
              VMOVDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.Single*)">
            <summary>
            __m256 _mm256_loadu_ps (float const * mem_addr)
              VMOVUPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadVector256(System.Double*)">
            <summary>
            __m256d _mm256_loadu_pd (double const * mem_addr)
              VMOVUPD ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.SByte*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.Byte*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.Int16*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.UInt16*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.Int32*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.UInt32*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.Int64*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.UInt64*)">
            <summary>
            __m256i _mm256_load_si256 (__m256i const * mem_addr)
              VMOVDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.Single*)">
            <summary>
            __m256 _mm256_load_ps (float const * mem_addr)
              VMOVAPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadAlignedVector256(System.Double*)">
            <summary>
            __m256d _mm256_load_pd (double const * mem_addr)
              VMOVAPD ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.SByte*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.Byte*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.Int16*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.UInt16*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.Int32*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.UInt32*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.Int64*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.LoadDquVector256(System.UInt64*)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
              VLDDQU ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskLoad(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_maskload_ps (float const * mem_addr, __m128i mask)
              VMASKMOVPS xmm, xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskLoad(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_maskload_pd (double const * mem_addr, __m128i mask)
              VMASKMOVPD xmm, xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskLoad(System.Single*,System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_maskload_ps (float const * mem_addr, __m256i mask)
              VMASKMOVPS ymm, ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskLoad(System.Double*,System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_maskload_pd (double const * mem_addr, __m256i mask)
              VMASKMOVPD ymm, ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskStore(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_maskstore_ps (float * mem_addr, __m128i mask, __m128 a)
              VMASKMOVPS m128, xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskStore(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_maskstore_pd (double * mem_addr, __m128i mask, __m128d a)
              VMASKMOVPD m128, xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskStore(System.Single*,System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            void _mm256_maskstore_ps (float * mem_addr, __m256i mask, __m256 a)
              VMASKMOVPS m256, ymm, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MaskStore(System.Double*,System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            void _mm256_maskstore_pd (double * mem_addr, __m256i mask, __m256d a)
              VMASKMOVPD m256, ymm, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Max(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_max_ps (__m256 a, __m256 b)
              VMAXPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Max(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_max_pd (__m256d a, __m256d b)
              VMAXPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Min(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_min_ps (__m256 a, __m256 b)
              VMINPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Min(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_min_pd (__m256d a, __m256d b)
              VMINPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MoveMask(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            int _mm256_movemask_ps (__m256 a)
              VMOVMSKPS reg, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.MoveMask(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            int _mm256_movemask_pd (__m256d a)
              VMOVMSKPD reg, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Multiply(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_mul_ps (__m256 a, __m256 b)
              VMULPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Multiply(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_mul_pd (__m256d a, __m256d b)
              VMULPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Or(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_or_ps (__m256 a, __m256 b)
              VORPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Or(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_or_pd (__m256d a, __m256d b)
              VORPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute(System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_permute_ps (__m128 a, int imm8)
              VPERMILPS xmm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute(System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m128d _mm_permute_pd (__m128d a, int imm8)
              VPERMILPD xmm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute(System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_permute_ps (__m256 a, int imm8)
              VPERMILPS ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute(System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_permute_pd (__m256d a, int imm8)
              VPERMILPD ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_permute2f128_ps (__m256 a, __m256 b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_permute2f128_pd (__m256d a, __m256d b, int imm8)
              VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.PermuteVar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128 _mm_permutevar_ps (__m128 a, __m128i b)
              VPERMILPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.PermuteVar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128d _mm_permutevar_pd (__m128d a, __m128i b)
              VPERMILPD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.PermuteVar(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256 _mm256_permutevar_ps (__m256 a, __m256i b)
              VPERMILPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.PermuteVar(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256d _mm256_permutevar_pd (__m256d a, __m256i b)
              VPERMILPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Reciprocal(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_rcp_ps (__m256 a)
              VRCPPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.ReciprocalSqrt(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_rsqrt_ps (__m256 a)
              VRSQRTPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToNearestInteger(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
              VROUNDPS ymm, ymm/m256, imm8(8)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToNegativeInfinity(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
              VROUNDPS ymm, ymm/m256, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToPositiveInfinity(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
              VROUNDPS ymm, ymm/m256, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToZero(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
              VROUNDPS ymm, ymm/m256, imm8(11)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundCurrentDirection(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_round_ps (__m256 a, _MM_FROUND_CUR_DIRECTION)
              VROUNDPS ymm, ymm/m256, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToNearestInteger(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
              VROUNDPD ymm, ymm/m256, imm8(8)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToNegativeInfinity(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
              VROUNDPD ymm, ymm/m256, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToPositiveInfinity(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
              VROUNDPD ymm, ymm/m256, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundToZero(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
              VROUNDPD ymm, ymm/m256, imm8(11)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.RoundCurrentDirection(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_round_pd (__m256d a, _MM_FROUND_CUR_DIRECTION)
              VROUNDPD ymm, ymm/m256, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Shuffle(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_shuffle_ps (__m256 a, __m256 b, const int imm8)
              VSHUFPS ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Shuffle(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int imm8)
              VSHUFPD ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Sqrt(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_sqrt_ps (__m256 a)
              VSQRTPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Sqrt(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_sqrt_pd (__m256d a)
              VSQRTPD ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.SByte*,System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.Byte*,System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.Int16*,System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.UInt16*,System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.UInt32*,System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.Int64*,System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.UInt64*,System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
              MOVDQA m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.Single*,System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            void _mm256_store_ps (float * mem_addr, __m256 a)
              VMOVAPS m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAligned(System.Double*,System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            void _mm256_store_pd (double * mem_addr, __m256d a)
              VMOVAPD m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.SByte*,System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.Byte*,System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.Int16*,System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.UInt16*,System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.UInt32*,System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.Int64*,System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.UInt64*,System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
              VMOVNTDQ m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.Single*,System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            void _mm256_stream_ps (float * mem_addr, __m256 a)
              MOVNTPS m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.StoreAlignedNonTemporal(System.Double*,System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            void _mm256_stream_pd (double * mem_addr, __m256d a)
              MOVNTPD m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.SByte*,System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.Byte*,System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.Int16*,System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.UInt16*,System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.UInt32*,System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.Int64*,System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.UInt64*,System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
              MOVDQU m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.Single*,System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            void _mm256_storeu_ps (float * mem_addr, __m256 a)
              MOVUPS m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Store(System.Double*,System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            void _mm256_storeu_pd (double * mem_addr, __m256d a)
              MOVUPD m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Subtract(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_sub_ps (__m256 a, __m256 b)
              VSUBPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Subtract(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_sub_pd (__m256d a, __m256d b)
              VSUBPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_testc_ps (__m128 a, __m128 b)
              VTESTPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_testc_pd (__m128d a, __m128d b)
              VTESTPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            int _mm256_testc_ps (__m256 a, __m256 b)
              VTESTPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestC(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            int _mm256_testc_pd (__m256d a, __m256d b)
              VTESTPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_testnzc_ps (__m128 a, __m128 b)
              VTESTPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_testnzc_pd (__m128d a, __m128d b)
              VTESTPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            int _mm256_testnzc_ps (__m256 a, __m256 b)
              VTESTPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            int _mm256_testnzc_pd (__m256d a, __m256d b)
              VTESTPD ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_testz_ps (__m128 a, __m128 b)
              VTESTPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_testz_pd (__m128d a, __m128d b)
              VTESTPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b)
              VPTEST ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            int _mm256_testz_ps (__m256 a, __m256 b)
              VTESTPS ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.TestZ(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            int _mm256_testz_pd (__m256d a, __m256d b)
              VTESTPD ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_unpackhi_ps (__m256 a, __m256 b)
              VUNPCKHPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_unpackhi_pd (__m256d a, __m256d b)
              VUNPCKHPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.UnpackLow(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_unpacklo_ps (__m256 a, __m256 b)
              VUNPCKLPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.UnpackLow(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_unpacklo_pd (__m256d a, __m256d b)
              VUNPCKLPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Xor(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_xor_ps (__m256 a, __m256 b)
              VXORPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx.Xor(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_xor_pd (__m256d a, __m256d b)
              VXORPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Avx2">
            <summary>
            This class provides access to Intel AVX2 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Abs(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_abs_epi8 (__m256i a)
              VPABSB ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Abs(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_abs_epi16 (__m256i a)
              VPABSW ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Abs(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_abs_epi32 (__m256i a)
              VPABSD ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_add_epi8 (__m256i a, __m256i b)
              VPADDB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_add_epi8 (__m256i a, __m256i b)
              VPADDB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_add_epi16 (__m256i a, __m256i b)
              VPADDW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_add_epi16 (__m256i a, __m256i b)
              VPADDW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_add_epi32 (__m256i a, __m256i b)
              VPADDD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_add_epi32 (__m256i a, __m256i b)
              VPADDD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_add_epi64 (__m256i a, __m256i b)
              VPADDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Add(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_add_epi64 (__m256i a, __m256i b)
              VPADDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AddSaturate(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_adds_epi8 (__m256i a, __m256i b)
              VPADDSB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AddSaturate(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_adds_epu8 (__m256i a, __m256i b)
              VPADDUSB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AddSaturate(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_adds_epi16 (__m256i a, __m256i b)
              VPADDSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AddSaturate(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_adds_epu16 (__m256i a, __m256i b)
              VPADDUSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            This intrinsic generates VPALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            This intrinsic generates VPALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            This intrinsic generates VPALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            This intrinsic generates VPALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            This intrinsic generates VPALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AlignRight(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
              VPALIGNR ymm, ymm, ymm/m256, imm8
            This intrinsic generates VPALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.And(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b)
              VPAND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.AndNot(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
              VPANDN ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Average(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_avg_epu8 (__m256i a, __m256i b)
              VPAVGB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Average(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_avg_epu16 (__m256i a, __m256i b)
              VPAVGW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Blend(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8)
              VPBLENDD xmm, xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Blend(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8)
              VPBLENDD xmm, xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Blend(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8)
              VPBLENDW ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Blend(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8)
              VPBLENDW ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Blend(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8)
              VPBLENDD ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Blend(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8)
              VPBLENDD ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            This intrinsic generates VPBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            This intrinsic generates VPBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            This intrinsic generates VPBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            This intrinsic generates VPBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            This intrinsic generates VPBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BlendVariable(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
              VPBLENDVB ymm, ymm, ymm/m256, ymm
            This intrinsic generates VPBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_broadcastb_epi8 (__m128i a)
              VPBROADCASTB xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_broadcastb_epi8 (__m128i a)
              VPBROADCASTB xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_broadcastw_epi16 (__m128i a)
              VPBROADCASTW xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_broadcastw_epi16 (__m128i a)
              VPBROADCASTW xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_broadcastd_epi32 (__m128i a)
              VPBROADCASTD xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_broadcastd_epi32 (__m128i a)
              VPBROADCASTD xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_broadcastss_ps (__m128 a)
              VBROADCASTSS xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_broadcastsd_pd (__m128d a)
              VMOVDDUP xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Byte*)">
            <summary>
            __m128i _mm_broadcastb_epi8 (__m128i a)
              VPBROADCASTB xmm, m8
            The above native signature does not directly correspond to the managed signature. 
            We provide this additional overload for the lack of pointers to managed.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.SByte*)">
            <summary>
            __m128i _mm_broadcastb_epi8 (__m128i a)
              VPBROADCASTB xmm, m8
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Int16*)">
            <summary>
            __m128i _mm_broadcastw_epi16 (__m128i a)
              VPBROADCASTW xmm, m16
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.UInt16*)">
            <summary>
            __m128i _mm_broadcastw_epi16 (__m128i a)
              VPBROADCASTW xmm, m16
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Int32*)">
            <summary>
            __m128i _mm_broadcastd_epi32 (__m128i a)
              VPBROADCASTD xmm, m32
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.UInt32*)">
            <summary>
            __m128i _mm_broadcastd_epi32 (__m128i a)
              VPBROADCASTD xmm, m32
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.Int64*)">
            <summary>
            __m128i _mm_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ xmm, m64
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128(System.UInt64*)">
            <summary>
            __m128i _mm_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ xmm, m64
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m256i _mm256_broadcastb_epi8 (__m128i a)
              VPBROADCASTB ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m256i _mm256_broadcastb_epi8 (__m128i a)
              VPBROADCASTB ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m256i _mm256_broadcastw_epi16 (__m128i a)
              VPBROADCASTW ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m256i _mm256_broadcastw_epi16 (__m128i a)
              VPBROADCASTW ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m256i _mm256_broadcastd_epi32 (__m128i a)
              VPBROADCASTD ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m256i _mm256_broadcastd_epi32 (__m128i a)
              VPBROADCASTD ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m256i _mm256_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m256i _mm256_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m256 _mm256_broadcastss_ps (__m128 a)
              VBROADCASTSS ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m256d _mm256_broadcastsd_pd (__m128d a)
              VBROADCASTSD ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Byte*)">
            <summary>
            __m256i _mm256_broadcastb_epi8 (__m128i a)
              VPBROADCASTB ymm, m8
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.SByte*)">
            <summary>
            __m256i _mm256_broadcastb_epi8 (__m128i a)
              VPBROADCASTB ymm, m8
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Int16*)">
            <summary>
            __m256i _mm256_broadcastw_epi16 (__m128i a)
              VPBROADCASTW ymm, m16
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.UInt16*)">
            <summary>
            __m256i _mm256_broadcastw_epi16 (__m128i a)
              VPBROADCASTW ymm, m16
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Int32*)">
            <summary>
            __m256i _mm256_broadcastd_epi32 (__m128i a)
              VPBROADCASTD ymm, m32
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.UInt32*)">
            <summary>
            __m256i _mm256_broadcastd_epi32 (__m128i a)
              VPBROADCASTD ymm, m32
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.Int64*)">
            <summary>
            __m256i _mm256_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ ymm, m64
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256(System.UInt64*)">
            <summary>
            __m256i _mm256_broadcastq_epi64 (__m128i a)
              VPBROADCASTQ ymm, m64
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.SByte*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.Byte*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.Int16*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.UInt16*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.Int32*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.UInt32*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.Int64*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.BroadcastVector128ToVector256(System.UInt64*)">
            <summary>
            __m256i _mm256_broadcastsi128_si256 (__m128i a)
              VBROADCASTI128 ymm, m128
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_cmpeq_epi8 (__m256i a, __m256i b)
              VPCMPEQB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_cmpeq_epi8 (__m256i a, __m256i b)
              VPCMPEQB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_cmpeq_epi16 (__m256i a, __m256i b)
              VPCMPEQW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_cmpeq_epi16 (__m256i a, __m256i b)
              VPCMPEQW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)
              VPCMPEQD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)
              VPCMPEQD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_cmpeq_epi64 (__m256i a, __m256i b)
              VPCMPEQQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareEqual(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_cmpeq_epi64 (__m256i a, __m256i b)
              VPCMPEQQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareGreaterThan(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b)
              VPCMPGTB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareGreaterThan(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_cmpgt_epi16 (__m256i a, __m256i b)
              VPCMPGTW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareGreaterThan(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)
              VPCMPGTD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.CompareGreaterThan(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b)
              VPCMPGTQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToInt32(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            int _mm256_cvtsi256_si32 (__m256i a)
              MOVD reg/m32, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToUInt32(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_cvtsi256_si32 (__m256i a)
              MOVD reg/m32, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int16(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m256i _mm256_cvtepi8_epi16 (__m128i a)
              VPMOVSXBW ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int16(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a)
              VPMOVZXBW ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m256i _mm256_cvtepi8_epi32 (__m128i a)
              VPMOVSXBD ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m256i _mm256_cvtepu8_epi32 (__m128i a)
              VPMOVZXBD ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a)
              VPMOVSXWD ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m256i _mm256_cvtepu16_epi32 (__m128i a)
              VPMOVZXWD ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m256i _mm256_cvtepi8_epi64 (__m128i a)
              VPMOVSXBQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m256i _mm256_cvtepu8_epi64 (__m128i a)
              VPMOVZXBQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m256i _mm256_cvtepi16_epi64 (__m128i a)
              VPMOVSXWQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a)
              VPMOVZXWQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a)
              VPMOVSXDQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m256i _mm256_cvtepu32_epi64 (__m128i a)
              VPMOVZXDQ ymm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int16(System.SByte*)">
            <summary>
              VPMOVSXBW ymm, m128
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int16(System.Byte*)">
            <summary>
              VPMOVZXBW ymm, m128
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.SByte*)">
            <summary>
              VPMOVSXBD ymm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.Byte*)">
            <summary>
              VPMOVZXBD ymm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.Int16*)">
            <summary>
              VPMOVSXWD ymm, m128
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32(System.UInt16*)">
            <summary>
              VPMOVZXWD ymm, m128
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.SByte*)">
            <summary>
              VPMOVSXBQ ymm, m32
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Byte*)">
            <summary>
              VPMOVZXBQ ymm, m32
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Int16*)">
            <summary>
              VPMOVSXWQ ymm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.UInt16*)">
            <summary>
              VPMOVZXWQ ymm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.Int32*)">
            <summary>
              VPMOVSXDQ ymm, m128
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64(System.UInt32*)">
            <summary>
              VPMOVZXDQ ymm, m128
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ExtractVector128(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
              VEXTRACTI128 xmm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_i32gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
              VPGATHERDD xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.UInt32*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_i32gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
              VPGATHERDD xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
              VPGATHERDQ xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
              VPGATHERDQ xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Single*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128 _mm_i32gather_ps (float const* base_addr, __m128i vindex, const int scale)
              VGATHERDPS xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Double*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128d _mm_i32gather_pd (double const* base_addr, __m128i vindex, const int scale)
              VGATHERDPD xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_i64gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
              VPGATHERQD xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.UInt32*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_i64gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
              VPGATHERQD xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_i64gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
              VPGATHERQQ xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_i64gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
              VPGATHERQQ xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Single*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128 _mm_i64gather_ps (float const* base_addr, __m128i vindex, const int scale)
              VGATHERQPS xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Double*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128d _mm_i64gather_pd (double const* base_addr, __m128i vindex, const int scale)
              VGATHERQPD xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_i32gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
              VPGATHERDD ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.UInt32*,System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_i32gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
              VPGATHERDD ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
              VPGATHERDQ ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
              VPGATHERDQ ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.Single*,System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256 _mm256_i32gather_ps (float const* base_addr, __m256i vindex, const int scale)
              VGATHERDPS ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.Double*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m256d _mm256_i32gather_pd (double const* base_addr, __m128i vindex, const int scale)
              VGATHERDPD ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m128i _mm256_i64gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
              VPGATHERQD xmm, vm64y, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.UInt32*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m128i _mm256_i64gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
              VPGATHERQD xmm, vm64y, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.Int64*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_i64gather_epi64 (__int64 const* base_addr, __m256i vindex, const int scale)
              VPGATHERQQ ymm, vm64y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.UInt64*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_i64gather_epi64 (__int64 const* base_addr, __m256i vindex, const int scale)
              VPGATHERQQ ymm, vm64y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector128(System.Single*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m128 _mm256_i64gather_ps (float const* base_addr, __m256i vindex, const int scale)
              VGATHERQPS xmm, vm64y, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherVector256(System.Double*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256d _mm256_i64gather_pd (double const* base_addr, __m256i vindex, const int scale)
              VGATHERQPD ymm, vm64y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_mask_i32gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERDD xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_mask_i32gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERDD xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_mask_i32gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERDQ xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_mask_i32gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERDQ xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Single},System.Single*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_mask_i32gather_ps (__m128 src, float const* base_addr, __m128i vindex, __m128 mask, const int scale)
              VGATHERDPS xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Double},System.Double*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m128d _mm_mask_i32gather_pd (__m128d src, double const* base_addr, __m128i vindex, __m128d mask, const int scale)
              VGATHERDPD xmm, vm32x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERQD xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERQD xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_mask_i64gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERQQ xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_mask_i64gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
              VPGATHERQQ xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Single},System.Single*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_mask_i64gather_ps (__m128 src, float const* base_addr, __m128i vindex, __m128 mask, const int scale)
              VGATHERQPS xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Double},System.Double*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m128d _mm_mask_i64gather_pd (__m128d src, double const* base_addr, __m128i vindex, __m128d mask, const int scale)
              VGATHERQPD xmm, vm64x, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.Int32},System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_mask_i32gather_epi32 (__m256i src, int const* base_addr, __m256i vindex, __m256i mask, const int scale)
              VPGATHERDD ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.UInt32},System.UInt32*,System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_mask_i32gather_epi32 (__m256i src, int const* base_addr, __m256i vindex, __m256i mask, const int scale)
              VPGATHERDD ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.Int64},System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_mask_i32gather_epi64 (__m256i src, __int64 const* base_addr, __m128i vindex, __m256i mask, const int scale)
              VPGATHERDQ ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_mask_i32gather_epi64 (__m256i src, __int64 const* base_addr, __m128i vindex, __m256i mask, const int scale)
              VPGATHERDQ ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.Single},System.Single*,System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_mask_i32gather_ps (__m256 src, float const* base_addr, __m256i vindex, __m256 mask, const int scale)
              VPGATHERDPS ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.Double},System.Double*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_mask_i32gather_pd (__m256d src, double const* base_addr, __m128i vindex, __m256d mask, const int scale)
              VPGATHERDPD ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm256_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m256i vindex, __m128i mask, const int scale)
              VPGATHERQD xmm, vm32y, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm256_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m256i vindex, __m128i mask, const int scale)
              VPGATHERQD xmm, vm32y, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.Int64},System.Int64*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_mask_i64gather_epi64 (__m256i src, __int64 const* base_addr, __m256i vindex, __m256i mask, const int scale)
              VPGATHERQQ ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_mask_i64gather_epi64 (__m256i src, __int64 const* base_addr, __m256i vindex, __m256i mask, const int scale)
              VPGATHERQQ ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector128(System.Runtime.Intrinsics.Vector128{System.Single},System.Single*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm256_mask_i64gather_ps (__m128 src, float const* base_addr, __m256i vindex, __m128 mask, const int scale)
              VGATHERQPS xmm, vm32y, xmm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.GatherMaskVector256(System.Runtime.Intrinsics.Vector256{System.Double},System.Double*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_mask_i64gather_pd (__m256d src, double const* base_addr, __m256i vindex, __m256d mask, const int scale)
              VGATHERQPD ymm, vm32y, ymm
            The scale parameter should be 1, 2, 4 or 8, otherwise, ArgumentOutOfRangeException will be thrown.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.HorizontalAdd(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_hadd_epi16 (__m256i a, __m256i b)
              VPHADDW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.HorizontalAdd(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_hadd_epi32 (__m256i a, __m256i b)
              VPHADDD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.HorizontalAddSaturate(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_hadds_epi16 (__m256i a, __m256i b)
              VPHADDSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.HorizontalSubtract(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_hsub_epi16 (__m256i a, __m256i b)
              VPHSUBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.HorizontalSubtract(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_hsub_epi32 (__m256i a, __m256i b)
              VPHSUBD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.HorizontalSubtractSaturate(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_hsubs_epi16 (__m256i a, __m256i b)
              VPHSUBSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.InsertVector128(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
              VINSERTI128 ymm, ymm, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.SByte*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.Byte*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.Int16*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.UInt16*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.Int32*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.UInt32*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.Int64*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.LoadAlignedVector256NonTemporal(System.UInt64*)">
            <summary>
            __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
              VMOVNTDQA ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_maskload_epi32 (int const* mem_addr, __m128i mask)
              VPMASKMOVD xmm, xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.UInt32*,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_maskload_epi32 (int const* mem_addr, __m128i mask)
              VPMASKMOVD xmm, xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_maskload_epi64 (__int64 const* mem_addr, __m128i mask)
              VPMASKMOVQ xmm, xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_maskload_epi64 (__int64 const* mem_addr, __m128i mask)
              VPMASKMOVQ xmm, xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_maskload_epi32 (int const* mem_addr, __m256i mask)
              VPMASKMOVD ymm, ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.UInt32*,System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_maskload_epi32 (int const* mem_addr, __m256i mask)
              VPMASKMOVD ymm, ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.Int64*,System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_maskload_epi64 (__int64 const* mem_addr, __m256i mask)
              VPMASKMOVQ ymm, ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskLoad(System.UInt64*,System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_maskload_epi64 (__int64 const* mem_addr, __m256i mask)
              VPMASKMOVQ ymm, ymm, m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            void _mm_maskstore_epi32 (int* mem_addr, __m128i mask, __m128i a)
              VPMASKMOVD m128, xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.UInt32*,System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            void _mm_maskstore_epi32 (int* mem_addr, __m128i mask, __m128i a)
              VPMASKMOVD m128, xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            void _mm_maskstore_epi64 (__int64* mem_addr, __m128i mask, __m128i a)
              VPMASKMOVQ m128, xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            void _mm_maskstore_epi64 (__int64* mem_addr, __m128i mask, __m128i a)
              VPMASKMOVQ m128, xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.Int32*,System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            void _mm256_maskstore_epi32 (int* mem_addr, __m256i mask, __m256i a)
              VPMASKMOVD m256, ymm, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.UInt32*,System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            void _mm256_maskstore_epi32 (int* mem_addr, __m256i mask, __m256i a)
              VPMASKMOVD m256, ymm, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.Int64*,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a)
              VPMASKMOVQ m256, ymm, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MaskStore(System.UInt64*,System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a)
              VPMASKMOVQ m256, ymm, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyAddAdjacent(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_madd_epi16 (__m256i a, __m256i b)
              VPMADDWD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyAddAdjacent(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_maddubs_epi16 (__m256i a, __m256i b)
              VPMADDUBSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Max(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_max_epi8 (__m256i a, __m256i b)
              VPMAXSB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Max(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_max_epu8 (__m256i a, __m256i b)
              VPMAXUB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Max(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_max_epi16 (__m256i a, __m256i b)
              VPMAXSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Max(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_max_epu16 (__m256i a, __m256i b)
              VPMAXUW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Max(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_max_epi32 (__m256i a, __m256i b)
              VPMAXSD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Max(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_max_epu32 (__m256i a, __m256i b)
              VPMAXUD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Min(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_min_epi8 (__m256i a, __m256i b)
              VPMINSB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Min(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_min_epu8 (__m256i a, __m256i b)
              VPMINUB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Min(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_min_epi16 (__m256i a, __m256i b)
              VPMINSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Min(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_min_epu16 (__m256i a, __m256i b)
              VPMINUW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Min(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_min_epi32 (__m256i a, __m256i b)
              VPMINSD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Min(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_min_epu32 (__m256i a, __m256i b)
              VPMINUD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MoveMask(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            int _mm256_movemask_epi8 (__m256i a)
              VPMOVMSKB reg, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MoveMask(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_movemask_epi8 (__m256i a)
              VPMOVMSKB reg, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultipleSumAbsoluteDifferences(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_mpsadbw_epu8 (__m256i a, __m256i b, const int imm8)
              VMPSADBW ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Multiply(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_mul_epi32 (__m256i a, __m256i b)
              VPMULDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Multiply(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_mul_epu32 (__m256i a, __m256i b)
              VPMULUDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyHigh(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_mulhi_epi16 (__m256i a, __m256i b)
              VPMULHW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyHigh(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_mulhi_epu16 (__m256i a, __m256i b)
              VPMULHUW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyHighRoundScale(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_mulhrs_epi16 (__m256i a, __m256i b)
              VPMULHRSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyLow(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_mullo_epi16 (__m256i a, __m256i b)
              VPMULLW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyLow(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_mullo_epi16 (__m256i a, __m256i b)
              VPMULLW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyLow(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_mullo_epi32 (__m256i a, __m256i b)
              VPMULLD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.MultiplyLow(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_mullo_epi32 (__m256i a, __m256i b)
              VPMULLD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Or(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_or_si256 (__m256i a, __m256i b)
              VPOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.PackSignedSaturate(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_packs_epi16 (__m256i a, __m256i b)
              VPACKSSWB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.PackSignedSaturate(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_packs_epi32 (__m256i a, __m256i b)
              VPACKSSDW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.PackUnsignedSaturate(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_packus_epi16 (__m256i a, __m256i b)
              VPACKUSWB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.PackUnsignedSaturate(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_packus_epi32 (__m256i a, __m256i b)
              VPACKUSDW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute2x128(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
              VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute4x64(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8)
              VPERMQ ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute4x64(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8)
              VPERMQ ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Permute4x64(System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_permute4x64_pd (__m256d a, const int imm8)
              VPERMPD ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.PermuteVar8x32(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx)
              VPERMD ymm, ymm/m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.PermuteVar8x32(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx)
              VPERMD ymm, ymm/m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.PermuteVar8x32(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256 _mm256_permutevar8x32_ps (__m256 a, __m256i idx)
              VPERMPS ymm, ymm/m256, ymm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m256i _mm256_sll_epi16 (__m256i a, __m128i count)
              VPSLLW ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m256i _mm256_sll_epi16 (__m256i a, __m128i count)
              VPSLLW ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m256i _mm256_sll_epi32 (__m256i a, __m128i count)
              VPSLLD ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m256i _mm256_sll_epi32 (__m256i a, __m128i count)
              VPSLLD ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m256i _mm256_sll_epi64 (__m256i a, __m128i count)
              VPSLLQ ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m256i _mm256_sll_epi64 (__m256i a, __m128i count)
              VPSLLQ ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi16 (__m256i a, int imm8)
              VPSLLW ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi16 (__m256i a, int imm8)
              VPSLLW ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi32 (__m256i a, int imm8)
              VPSLLD ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi32 (__m256i a, int imm8)
              VPSLLD ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi64 (__m256i a, int imm8)
              VPSLLQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi64 (__m256i a, int imm8)
              VPSLLQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
              VPSLLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_sllv_epi32 (__m256i a, __m256i count)
              VPSLLVD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_sllv_epi32 (__m256i a, __m256i count)
              VPSLLVD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_sllv_epi64 (__m256i a, __m256i count)
              VPSLLVQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_sllv_epi64 (__m256i a, __m256i count)
              VPSLLVQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_sllv_epi32 (__m128i a, __m128i count)
              VPSLLVD xmm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_sllv_epi32 (__m128i a, __m128i count)
              VPSLLVD xmm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_sllv_epi64 (__m128i a, __m128i count)
              VPSLLVQ xmm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_sllv_epi64 (__m128i a, __m128i count)
              VPSLLVQ xmm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            _mm256_sra_epi16 (__m256i a, __m128i count)
              VPSRAW ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            _mm256_sra_epi32 (__m256i a, __m128i count)
              VPSRAD ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_srai_epi16 (__m256i a, int imm8)
              VPSRAW ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_srai_epi32 (__m256i a, int imm8)
              VPSRAD ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightArithmeticVariable(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_srav_epi32 (__m256i a, __m256i count)
              VPSRAVD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightArithmeticVariable(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_srav_epi32 (__m128i a, __m128i count)
              VPSRAVD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m256i _mm256_srl_epi16 (__m256i a, __m128i count)
              VPSRLW ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m256i _mm256_srl_epi16 (__m256i a, __m128i count)
              VPSRLW ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m256i _mm256_srl_epi32 (__m256i a, __m128i count)
              VPSRLD ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m256i _mm256_srl_epi32 (__m256i a, __m128i count)
              VPSRLD ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m256i _mm256_srl_epi64 (__m256i a, __m128i count)
              VPSRLQ ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m256i _mm256_srl_epi64 (__m256i a, __m128i count)
              VPSRLQ ymm, ymm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi16 (__m256i a, int imm8)
              VPSRLW ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi16 (__m256i a, int imm8)
              VPSRLW ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi32 (__m256i a, int imm8)
              VPSRLD ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi32 (__m256i a, int imm8)
              VPSRLD ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi64 (__m256i a, int imm8)
              VPSRLQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi64 (__m256i a, int imm8)
              VPSRLQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
              VPSRLDQ ymm, ymm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_srlv_epi32 (__m256i a, __m256i count)
              VPSRLVD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_srlv_epi32 (__m256i a, __m256i count)
              VPSRLVD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_srlv_epi64 (__m256i a, __m256i count)
              VPSRLVQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_srlv_epi64 (__m256i a, __m256i count)
              VPSRLVQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_srlv_epi32 (__m128i a, __m128i count)
              VPSRLVD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_srlv_epi32 (__m128i a, __m128i count)
              VPSRLVD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_srlv_epi64 (__m128i a, __m128i count)
              VPSRLVQ xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_srlv_epi64 (__m128i a, __m128i count)
              VPSRLVQ xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Shuffle(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b)
              VPSHUFB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Shuffle(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b)
              VPSHUFB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Shuffle(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8)
              VPSHUFD ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Shuffle(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8)
              VPSHUFD ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShuffleHigh(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8)
              VPSHUFHW ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShuffleHigh(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8)
              VPSHUFHW ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShuffleLow(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8)
              VPSHUFLW ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.ShuffleLow(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8)
              VPSHUFLW ymm, ymm/m256, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Sign(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_sign_epi8 (__m256i a, __m256i b)
              VPSIGNB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Sign(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_sign_epi16 (__m256i a, __m256i b)
              VPSIGNW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Sign(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_sign_epi32 (__m256i a, __m256i b)
              VPSIGND ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_sub_epi8 (__m256i a, __m256i b)
              VPSUBB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_sub_epi8 (__m256i a, __m256i b)
              VPSUBB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_sub_epi16 (__m256i a, __m256i b)
              VPSUBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_sub_epi16 (__m256i a, __m256i b)
              VPSUBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_sub_epi32 (__m256i a, __m256i b)
              VPSUBD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_sub_epi32 (__m256i a, __m256i b)
              VPSUBD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_sub_epi64 (__m256i a, __m256i b)
              VPSUBQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Subtract(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_sub_epi64 (__m256i a, __m256i b)
              VPSUBQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.SubtractSaturate(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_subs_epi8 (__m256i a, __m256i b)
              VPSUBSB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.SubtractSaturate(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_subs_epi16 (__m256i a, __m256i b)
              VPSUBSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.SubtractSaturate(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_subs_epu8 (__m256i a, __m256i b)
              VPSUBUSB ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.SubtractSaturate(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_subs_epu16 (__m256i a, __m256i b)
              VPSUBUSW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.SumAbsoluteDifferences(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_sad_epu8 (__m256i a, __m256i b)
              VPSADBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_unpackhi_epi8 (__m256i a, __m256i b)
              VPUNPCKHBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_unpackhi_epi8 (__m256i a, __m256i b)
              VPUNPCKHBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_unpackhi_epi16 (__m256i a, __m256i b)
              VPUNPCKHWD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_unpackhi_epi16 (__m256i a, __m256i b)
              VPUNPCKHWD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_unpackhi_epi32 (__m256i a, __m256i b)
              VPUNPCKHDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_unpackhi_epi32 (__m256i a, __m256i b)
              VPUNPCKHDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_unpackhi_epi64 (__m256i a, __m256i b)
              VPUNPCKHQDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackHigh(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_unpackhi_epi64 (__m256i a, __m256i b)
              VPUNPCKHQDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_unpacklo_epi8 (__m256i a, __m256i b)
              VPUNPCKLBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_unpacklo_epi8 (__m256i a, __m256i b)
              VPUNPCKLBW ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_unpacklo_epi16 (__m256i a, __m256i b)
              VPUNPCKLWD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_unpacklo_epi16 (__m256i a, __m256i b)
              VPUNPCKLWD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_unpacklo_epi32 (__m256i a, __m256i b)
              VPUNPCKLDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_unpacklo_epi32 (__m256i a, __m256i b)
              VPUNPCKLDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_unpacklo_epi64 (__m256i a, __m256i b)
              VPUNPCKLQDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.UnpackLow(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_unpacklo_epi64 (__m256i a, __m256i b)
              VPUNPCKLQDQ ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Avx2.Xor(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_xor_si256 (__m256i a, __m256i b)
              VPXOR ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Bmi1">
            <summary>
            This class provides access to Intel BMI1 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.X64.AndNot(System.UInt64,System.UInt64)">
            <summary>
            unsigned __int64 _andn_u64 (unsigned __int64 a, unsigned __int64 b)
              ANDN r64a, r64b, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.X64.BitFieldExtract(System.UInt64,System.Byte,System.Byte)">
            <summary>
            unsigned __int64 _bextr_u64 (unsigned __int64 a, unsigned int start, unsigned int len)
              BEXTR r64a, reg/m64, r64b
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.X64.BitFieldExtract(System.UInt64,System.UInt16)">
            <summary>
            unsigned __int64 _bextr2_u64 (unsigned __int64 a, unsigned __int64 control)
              BEXTR r64a, reg/m64, r64b
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.X64.ExtractLowestSetBit(System.UInt64)">
            <summary>
            unsigned __int64 _blsi_u64 (unsigned __int64 a)
              BLSI reg, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.X64.GetMaskUpToLowestSetBit(System.UInt64)">
            <summary>
            unsigned __int64 _blsmsk_u64 (unsigned __int64 a)
              BLSMSK reg, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.X64.ResetLowestSetBit(System.UInt64)">
            <summary>
            unsigned __int64 _blsr_u64 (unsigned __int64 a)
              BLSR reg, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.X64.TrailingZeroCount(System.UInt64)">
            <summary>
            __int64 _mm_tzcnt_64 (unsigned __int64 a)
              TZCNT reg, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.AndNot(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _andn_u32 (unsigned int a, unsigned int b)
              ANDN r32a, r32b, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.BitFieldExtract(System.UInt32,System.Byte,System.Byte)">
            <summary>
            unsigned int _bextr_u32 (unsigned int a, unsigned int start, unsigned int len)
              BEXTR r32a, reg/m32, r32b
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.BitFieldExtract(System.UInt32,System.UInt16)">
            <summary>
            unsigned int _bextr2_u32 (unsigned int a, unsigned int control)
              BEXTR r32a, reg/m32, r32b
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.ExtractLowestSetBit(System.UInt32)">
            <summary>
            unsigned int _blsi_u32 (unsigned int a)
              BLSI reg, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.GetMaskUpToLowestSetBit(System.UInt32)">
            <summary>
            unsigned int _blsmsk_u32 (unsigned int a)
              BLSMSK reg, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.ResetLowestSetBit(System.UInt32)">
            <summary>
            unsigned int _blsr_u32 (unsigned int a)
              BLSR reg, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi1.TrailingZeroCount(System.UInt32)">
            <summary>
            int _mm_tzcnt_32 (unsigned int a)
              TZCNT reg, reg/m32
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Bmi2">
            <summary>
            This class provides access to Intel BMI2 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.X64.ZeroHighBits(System.UInt64,System.UInt64)">
            <summary>
            unsigned __int64 _bzhi_u64 (unsigned __int64 a, unsigned int index)
              BZHI r64a, reg/m32, r64b
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.X64.MultiplyNoFlags(System.UInt64,System.UInt64)">
            <summary>
            unsigned __int64 _mulx_u64 (unsigned __int64 a, unsigned __int64 b, unsigned __int64* hi)
              MULX r64a, r64b, reg/m64
            The above native signature does not directly correspond to the managed signature. 
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.X64.MultiplyNoFlags(System.UInt64,System.UInt64,System.UInt64*)">
            <summary>
            unsigned __int64 _mulx_u64 (unsigned __int64 a, unsigned __int64 b, unsigned __int64* hi)
              MULX r64a, r64b, reg/m64
            The above native signature does not directly correspond to the managed signature. 
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.X64.ParallelBitDeposit(System.UInt64,System.UInt64)">
            <summary>
            unsigned __int64 _pdep_u64 (unsigned __int64 a, unsigned __int64 mask)
              PDEP r64a, r64b, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.X64.ParallelBitExtract(System.UInt64,System.UInt64)">
            <summary>
            unsigned __int64 _pext_u64 (unsigned __int64 a, unsigned __int64 mask)
              PEXT r64a, r64b, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.ZeroHighBits(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _bzhi_u32 (unsigned int a, unsigned int index)
              BZHI r32a, reg/m32, r32b
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.MultiplyNoFlags(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _mulx_u32 (unsigned int a, unsigned int b, unsigned int* hi)
              MULX r32a, r32b, reg/m32
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.MultiplyNoFlags(System.UInt32,System.UInt32,System.UInt32*)">
            <summary>
            unsigned int _mulx_u32 (unsigned int a, unsigned int b, unsigned int* hi)
              MULX r32a, r32b, reg/m32
            The above native signature does not directly correspond to the managed signature. 
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.ParallelBitDeposit(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _pdep_u32 (unsigned int a, unsigned int mask)
              PDEP r32a, r32b, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Bmi2.ParallelBitExtract(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _pext_u32 (unsigned int a, unsigned int mask)
              PEXT r32a, r32b, reg/m32
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Fma">
            <summary>
            This class provides access to Intel FMA hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAdd(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmadd_ps (__m128 a, __m128 b, __m128 c)
              VFMADDPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAdd(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmadd_pd (__m128d a, __m128d b, __m128d c)
              VFMADDPD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAdd(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_fmadd_ps (__m256 a, __m256 b, __m256 c)
              VFMADDPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAdd(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_fmadd_pd (__m256d a, __m256d b, __m256d c)
              VFMADDPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmadd_ss (__m128 a, __m128 b, __m128 c)
              VFMADDSS xmm, xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmadd_sd (__m128d a, __m128d b, __m128d c)
              VFMADDSS xmm, xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddSubtract(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmaddsub_ps (__m128 a, __m128 b, __m128 c)
              VFMADDSUBPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddSubtract(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmaddsub_pd (__m128d a, __m128d b, __m128d c)
              VFMADDSUBPD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddSubtract(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_fmaddsub_ps (__m256 a, __m256 b, __m256 c)
              VFMADDSUBPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddSubtract(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_fmaddsub_pd (__m256d a, __m256d b, __m256d c)
              VFMADDSUBPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtract(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmsub_ps (__m128 a, __m128 b, __m128 c)
              VFMSUBPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtract(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmsub_pd (__m128d a, __m128d b, __m128d c)
              VFMSUBPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtract(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_fmsub_ps (__m256 a, __m256 b, __m256 c)
              VFMSUBPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtract(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_fmsub_pd (__m256d a, __m256d b, __m256d c)
              VFMSUBPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmsub_ss (__m128 a, __m128 b, __m128 c)
              VFMSUBSS xmm, xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmsub_sd (__m128d a, __m128d b, __m128d c)
              VFMSUBSD xmm, xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractAdd(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmsubadd_ps (__m128 a, __m128 b, __m128 c)
              VFMSUBADDPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractAdd(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmsubadd_pd (__m128d a, __m128d b, __m128d c)
              VFMSUBADDPD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractAdd(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_fmsubadd_ps (__m256 a, __m256 b, __m256 c)
              VFMSUBADDPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractAdd(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_fmsubadd_pd (__m256d a, __m256d b, __m256d c)
              VFMSUBADDPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddNegated(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fnmadd_ps (__m128 a, __m128 b, __m128 c)
              VFNMADDPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddNegated(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fnmadd_pd (__m128d a, __m128d b, __m128d c)
              VFNMADDPD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddNegated(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_fnmadd_ps (__m256 a, __m256 b, __m256 c)
              VFNMADDPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddNegated(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_fnmadd_pd (__m256d a, __m256d b, __m256d c)
              VFNMADDPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddNegatedScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fnmadd_ss (__m128 a, __m128 b, __m128 c)
              VFNMADDSS xmm, xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplyAddNegatedScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fnmadd_sd (__m128d a, __m128d b, __m128d c)
              VFNMADDSD xmm, xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractNegated(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fnmsub_ps (__m128 a, __m128 b, __m128 c)
              VFNMSUBPS xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractNegated(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fnmsub_pd (__m128d a, __m128d b, __m128d c)
              VFNMSUBPD xmm, xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractNegated(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_fnmsub_ps (__m256 a, __m256 b, __m256 c)
              VFNMSUBPS ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractNegated(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_fnmsub_pd (__m256d a, __m256d b, __m256d c)
              VFNMSUBPD ymm, ymm, ymm/m256
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractNegatedScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fnmsub_ss (__m128 a, __m128 b, __m128 c)
              VFNMSUBSS xmm, xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Fma.MultiplySubtractNegatedScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fnmsub_sd (__m128d a, __m128d b, __m128d c)
              VFNMSUBSD xmm, xmm, xmm/m64
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Lzcnt">
            <summary>
            This class provides access to Intel LZCNT hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Lzcnt.X64.LeadingZeroCount(System.UInt64)">
            <summary>
            unsigned __int64 _lzcnt_u64 (unsigned __int64 a)
              LZCNT reg, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Lzcnt.LeadingZeroCount(System.UInt32)">
            <summary>
            unsigned int _lzcnt_u32 (unsigned int a)
              LZCNT reg, reg/m32
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Pclmulqdq">
            <summary>
            This class provides access to Intel PCLMULQDQ hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Pclmulqdq.CarrylessMultiply(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_clmulepi64_si128 (__m128i a, __m128i b, const int imm8)
              PCLMULQDQ xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Pclmulqdq.CarrylessMultiply(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_clmulepi64_si128 (__m128i a, __m128i b, const int imm8)
              PCLMULQDQ xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Popcnt">
            <summary>
            This class provides access to Intel POPCNT hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount(System.UInt64)">
            <summary>
            __int64 _mm_popcnt_u64 (unsigned __int64 a)
              POPCNT reg64, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Popcnt.PopCount(System.UInt32)">
            <summary>
            int _mm_popcnt_u32 (unsigned int a)
              POPCNT reg, reg/m32
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Sse">
            <summary>
            This class provides access to Intel SSE hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.X64.ConvertToInt64(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __int64 _mm_cvtss_si64 (__m128 a)
              CVTSS2SI r64, xmm/m32
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.X64.ConvertScalarToVector128Single(System.Runtime.Intrinsics.Vector128{System.Single},System.Int64)">
            <summary>
            __m128 _mm_cvtsi64_ss (__m128 a, __int64 b)
              CVTSI2SS xmm, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.X64.ConvertToInt64WithTruncation(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __int64 _mm_cvttss_si64 (__m128 a)
              CVTTSS2SI r64, xmm/m32
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Add(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_add_ps (__m128 a,  __m128 b)
              ADDPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.AddScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_add_ss (__m128 a,  __m128 b)
              ADDSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.And(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_and_ps (__m128 a, __m128 b)
              ANDPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.AndNot(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_andnot_ps (__m128 a, __m128 b)
              ANDNPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpeq_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(0)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comieq_ss (__m128 a, __m128 b)
              COMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_ucomieq_ss (__m128 a, __m128 b)
              UCOMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpeq_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(0)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareGreaterThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpgt_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedGreaterThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comigt_ss (__m128 a, __m128 b)
              COMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedGreaterThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_ucomigt_ss (__m128 a, __m128 b)
              UCOMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarGreaterThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpgt_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpge_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comige_ss (__m128 a, __m128 b)
              COMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_ucomige_ss (__m128 a, __m128 b)
              UCOMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpge_ss (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m32, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareLessThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmplt_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedLessThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comilt_ss (__m128 a, __m128 b)
              COMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedLessThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_ucomilt_ss (__m128 a, __m128 b)
              UCOMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarLessThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmplt_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmple_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comile_ss (__m128 a, __m128 b)
              COMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_ucomile_ss (__m128 a, __m128 b)
              UCOMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmple_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareNotEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpneq_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedNotEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comineq_ss (__m128 a, __m128 b)
              COMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedNotEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_ucomineq_ss (__m128 a, __m128 b)
              UCOMISS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarNotEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpneq_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareNotGreaterThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpngt_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarNotGreaterThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpngt_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareNotGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpnge_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarNotGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpnge_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareNotLessThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpnlt_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarNotLessThan(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpnlt_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareNotLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpnle_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarNotLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpnle_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareOrdered(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpord_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(7)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarOrdered(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpord_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(7)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareUnordered(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpunord_ps (__m128 a,  __m128 b)
              CMPPS xmm, xmm/m128, imm8(3)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.CompareScalarUnordered(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpunord_ss (__m128 a,  __m128 b)
              CMPSS xmm, xmm/m32, imm8(3)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ConvertToInt32(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_cvtss_si32 (__m128 a)
              CVTSS2SI r32, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ConvertScalarToVector128Single(System.Runtime.Intrinsics.Vector128{System.Single},System.Int32)">
            <summary>
            __m128 _mm_cvtsi32_ss (__m128 a, int b)
              CVTSI2SS xmm, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ConvertToInt32WithTruncation(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_cvttss_si32 (__m128 a)
              CVTTSS2SI r32, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Divide(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_div_ps (__m128 a,  __m128 b)
              DIVPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.DivideScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_div_ss (__m128 a,  __m128 b)
              DIVSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.LoadVector128(System.Single*)">
            <summary>
            __m128 _mm_loadu_ps (float const* mem_address)
              MOVUPS xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.LoadScalarVector128(System.Single*)">
            <summary>
            __m128 _mm_load_ss (float const* mem_address)
              MOVSS xmm, m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.LoadAlignedVector128(System.Single*)">
            <summary>
            __m128 _mm_load_ps (float const* mem_address)
              MOVAPS xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.LoadHigh(System.Runtime.Intrinsics.Vector128{System.Single},System.Single*)">
            <summary>
            __m128 _mm_loadh_pi (__m128 a, __m64 const* mem_addr)
              MOVHPS xmm, m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.LoadLow(System.Runtime.Intrinsics.Vector128{System.Single},System.Single*)">
            <summary>
            __m128 _mm_loadl_pi (__m128 a, __m64 const* mem_addr)
              MOVLPS xmm, m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Max(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_max_ps (__m128 a,  __m128 b)
              MAXPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.MaxScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_max_ss (__m128 a,  __m128 b)
              MAXSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Min(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_min_ps (__m128 a,  __m128 b)
              MINPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.MinScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_min_ss (__m128 a,  __m128 b)
              MINSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.MoveScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_move_ss (__m128 a, __m128 b)
              MOVSS xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.MoveHighToLow(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_movehl_ps (__m128 a,  __m128 b)
              MOVHLPS xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.MoveLowToHigh(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_movelh_ps (__m128 a,  __m128 b)
              MOVLHPS xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.MoveMask(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_movemask_ps (__m128 a)
              MOVMSKPS reg, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Multiply(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_mul_ps (__m128 a, __m128 b)
              MULPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.MultiplyScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_mul_ss (__m128 a, __m128 b)
              MULPS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Prefetch0(System.Void*)">
            <summary>
            void _mm_prefetch(char* p, int i)
              PREFETCHT0 m8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Prefetch1(System.Void*)">
            <summary>
            void _mm_prefetch(char* p, int i)
              PREFETCHT1 m8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Prefetch2(System.Void*)">
            <summary>
            void _mm_prefetch(char* p, int i)
              PREFETCHT2 m8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.PrefetchNonTemporal(System.Void*)">
            <summary>
            void _mm_prefetch(char* p, int i)
              PREFETCHNTA m8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Or(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_or_ps (__m128 a,  __m128 b)
              ORPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Reciprocal(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rcp_ps (__m128 a)
              RCPPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ReciprocalScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rcp_ss (__m128 a)
              RCPSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ReciprocalScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rcp_ss (__m128 a, __m128 b)
              RCPSS xmm, xmm/m32
            The above native signature does not exist. We provide this additional overload for consistency with the other scalar APIs.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ReciprocalSqrt(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rsqrt_ps (__m128 a)
              RSQRTPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ReciprocalSqrtScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rsqrt_ss (__m128 a)
              RSQRTSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.ReciprocalSqrtScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rsqrt_ss (__m128 a, __m128 b)
              RSQRTSS xmm, xmm/m32
            The above native signature does not exist. We provide this additional overload for consistency with the other scalar APIs.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Shuffle(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_shuffle_ps (__m128 a,  __m128 b, unsigned int control)
              SHUFPS xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Sqrt(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sqrt_ps (__m128 a)
              SQRTPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.SqrtScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sqrt_ss (__m128 a)
              SQRTSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.SqrtScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sqrt_ss (__m128 a, __m128 b)
              SQRTSS xmm, xmm/m32
            The above native signature does not exist. We provide this additional overload for consistency with the other scalar APIs.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.StoreAligned(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_store_ps (float* mem_addr, __m128 a)
              MOVAPS m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.StoreAlignedNonTemporal(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_stream_ps (float* mem_addr, __m128 a)
              MOVNTPS m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Store(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_storeu_ps (float* mem_addr, __m128 a)
              MOVUPS m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.StoreFence">
            <summary>
            void _mm_sfence(void)
              SFENCE
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.StoreScalar(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_store_ss (float* mem_addr, __m128 a)
              MOVSS m32, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.StoreHigh(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_storeh_pi (__m64* mem_addr, __m128 a)
              MOVHPS m64, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.StoreLow(System.Single*,System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_storel_pi (__m64* mem_addr, __m128 a)
              MOVLPS m64, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Subtract(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128d _mm_sub_ps (__m128d a, __m128d b)
              SUBPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.SubtractScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sub_ss (__m128 a, __m128 b)
              SUBSS xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_unpackhi_ps (__m128 a,  __m128 b)
              UNPCKHPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.UnpackLow(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_unpacklo_ps (__m128 a,  __m128 b)
              UNPCKLPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse.Xor(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_xor_ps (__m128 a,  __m128 b)
              XORPS xmm, xmm/m128
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Sse2">
            <summary>
            This class provides access to Intel SSE2 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.ConvertToInt64(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __int64 _mm_cvtsd_si64 (__m128d a)
              CVTSD2SI r64, xmm/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.ConvertToInt64(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __int64 _mm_cvtsi128_si64 (__m128i a)
              MOVQ reg/m64, xmm
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.ConvertToUInt64(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __int64 _mm_cvtsi128_si64 (__m128i a)
              MOVQ reg/m64, xmm
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.ConvertScalarToVector128Double(System.Runtime.Intrinsics.Vector128{System.Double},System.Int64)">
            <summary>
            __m128d _mm_cvtsi64_sd (__m128d a, __int64 b)
              CVTSI2SD xmm, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.ConvertScalarToVector128Int64(System.Int64)">
            <summary>
            __m128i _mm_cvtsi64_si128 (__int64 a)
              MOVQ xmm, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.ConvertScalarToVector128UInt64(System.UInt64)">
            <summary>
            __m128i _mm_cvtsi64_si128 (__int64 a)
              MOVQ xmm, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.ConvertToInt64WithTruncation(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __int64 _mm_cvttsd_si64 (__m128d a)
              CVTTSD2SI reg, xmm/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.StoreNonTemporal(System.Int64*,System.Int64)">
            <summary>
            void _mm_stream_si64(__int64 *p, __int64 a)
              MOVNTI m64, r64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.X64.StoreNonTemporal(System.UInt64*,System.UInt64)">
            <summary>
            void _mm_stream_si64(__int64 *p, __int64 a)
              MOVNTI m64, r64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_add_epi8 (__m128i a,  __m128i b)
              PADDB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_add_epi8 (__m128i a,  __m128i b)
              PADDB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_add_epi16 (__m128i a,  __m128i b)
              PADDW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_add_epi16 (__m128i a,  __m128i b)
              PADDW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_add_epi32 (__m128i a,  __m128i b)
              PADDD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_add_epi32 (__m128i a,  __m128i b)
              PADDD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_add_epi64 (__m128i a,  __m128i b)
              PADDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_add_epi64 (__m128i a,  __m128i b)
              PADDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Add(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_add_pd (__m128d a,  __m128d b)
              ADDPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AddScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_add_sd (__m128d a,  __m128d b)
              ADDSD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AddSaturate(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_adds_epi8 (__m128i a,  __m128i b)
              PADDSB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AddSaturate(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_adds_epu8 (__m128i a,  __m128i b)
              PADDUSB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AddSaturate(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_adds_epi16 (__m128i a,  __m128i b)
              PADDSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AddSaturate(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_adds_epu16 (__m128i a,  __m128i b)
              PADDUSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_and_si128 (__m128i a,  __m128i b)
              PAND xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.And(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_and_pd (__m128d a, __m128d b)
              ANDPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
              PANDN xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.AndNot(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_andnot_pd (__m128d a, __m128d b)
              ADDNPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Average(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_avg_epu8 (__m128i a,  __m128i b)
              PAVGB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Average(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_avg_epu16 (__m128i a,  __m128i b)
              PAVGW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareEqual(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cmpeq_epi8 (__m128i a,  __m128i b)
              PCMPEQB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareEqual(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_cmpeq_epi8 (__m128i a,  __m128i b)
              PCMPEQB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareEqual(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_cmpeq_epi16 (__m128i a,  __m128i b)
              PCMPEQW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareEqual(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_cmpeq_epi16 (__m128i a,  __m128i b)
              PCMPEQW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareEqual(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_cmpeq_epi32 (__m128i a,  __m128i b)
              PCMPEQD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareEqual(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_cmpeq_epi32 (__m128i a,  __m128i b)
              PCMPEQD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpeq_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(0)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comieq_sd (__m128d a, __m128d b)
              COMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomieq_sd (__m128d a, __m128d b)
              UCOMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpeq_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(0)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThan(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cmpgt_epi8 (__m128i a,  __m128i b)
              PCMPGTB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThan(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_cmpgt_epi16 (__m128i a,  __m128i b)
              PCMPGTW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThan(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_cmpgt_epi32 (__m128i a,  __m128i b)
              PCMPGTD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpgt_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedGreaterThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comigt_sd (__m128d a, __m128d b)
              COMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedGreaterThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomigt_sd (__m128d a, __m128d b)
              UCOMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarGreaterThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpgt_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpge_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comige_sd (__m128d a, __m128d b)
              COMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomige_sd (__m128d a, __m128d b)
              UCOMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpge_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareLessThan(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cmplt_epi8 (__m128i a,  __m128i b)
              PCMPGTB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareLessThan(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_cmplt_epi16 (__m128i a,  __m128i b)
              PCMPGTW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareLessThan(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_cmplt_epi32 (__m128i a,  __m128i b)
              PCMPGTD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareLessThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmplt_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedLessThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comilt_sd (__m128d a, __m128d b)
              COMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedLessThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomilt_sd (__m128d a, __m128d b)
              UCOMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarLessThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmplt_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmple_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comile_sd (__m128d a, __m128d b)
              COMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomile_sd (__m128d a, __m128d b)
              UCOMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmple_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareNotEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpneq_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedNotEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comineq_sd (__m128d a, __m128d b)
              COMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedNotEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomineq_sd (__m128d a, __m128d b)
              UCOMISD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpneq_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareNotGreaterThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpngt_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotGreaterThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpngt_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(2)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareNotGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnge_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotGreaterThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnge_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(1)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareNotLessThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnlt_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotLessThan(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnlt_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(5)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareNotLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnle_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotLessThanOrEqual(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnle_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(6)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareOrdered(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpord_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(7)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrdered(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpord_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(7)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareUnordered(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpunord_pd (__m128d a,  __m128d b)
              CMPPD xmm, xmm/m128, imm8(3)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnordered(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpunord_sd (__m128d a,  __m128d b)
              CMPSD xmm, xmm/m64, imm8(3)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Int32(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128i _mm_cvtps_epi32 (__m128 a)
              CVTPS2DQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Int32(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128i _mm_cvtpd_epi32 (__m128d a)
              CVTPD2DQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Single(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128 _mm_cvtepi32_ps (__m128i a)
              CVTDQ2PS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Single(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128 _mm_cvtpd_ps (__m128d a)
              CVTPD2PS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Double(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128d _mm_cvtepi32_pd (__m128i a)
              CVTDQ2PD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Double(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128d _mm_cvtps_pd (__m128 a)
              CVTPS2PD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToInt32(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_cvtsd_si32 (__m128d a)
              CVTSD2SI r32, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToInt32(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            int _mm_cvtsi128_si32 (__m128i a)
              MOVD reg/m32, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToUInt32(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            int _mm_cvtsi128_si32 (__m128i a)
              MOVD reg/m32, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128Double(System.Runtime.Intrinsics.Vector128{System.Double},System.Int32)">
            <summary>
            __m128d _mm_cvtsi32_sd (__m128d a, int b)
              CVTSI2SD xmm, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128Double(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128d _mm_cvtss_sd (__m128d a, __m128 b)
              CVTSS2SD xmm, xmm/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128Int32(System.Int32)">
            <summary>
            __m128i _mm_cvtsi32_si128 (int a)
              MOVD xmm, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128Single(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128 _mm_cvtsd_ss (__m128 a, __m128d b)
              CVTSD2SS xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128UInt32(System.UInt32)">
            <summary>
            __m128i _mm_cvtsi32_si128 (int a)
              MOVD xmm, reg/m32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Int32WithTruncation(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128i _mm_cvttps_epi32 (__m128 a)
              CVTTPS2DQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Int32WithTruncation(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128i _mm_cvttpd_epi32 (__m128d a)
              CVTTPD2DQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ConvertToInt32WithTruncation(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_cvttsd_si32 (__m128d a)
              CVTTSD2SI reg, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Divide(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_div_pd (__m128d a,  __m128d b)
              DIVPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.DivideScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_div_sd (__m128d a,  __m128d b)
              DIVSD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Extract(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            int _mm_extract_epi16 (__m128i a,  int immediate)
              PEXTRW reg, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Insert(System.Runtime.Intrinsics.Vector128{System.Int16},System.Int16,System.Byte)">
            <summary>
            __m128i _mm_insert_epi16 (__m128i a,  int i, int immediate)
              PINSRW xmm, reg/m16, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Insert(System.Runtime.Intrinsics.Vector128{System.UInt16},System.UInt16,System.Byte)">
            <summary>
            __m128i _mm_insert_epi16 (__m128i a,  int i, int immediate)
              PINSRW xmm, reg/m16, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.SByte*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.Byte*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.Int16*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.UInt16*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.Int32*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.UInt32*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.Int64*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.UInt64*)">
            <summary>
            __m128i _mm_loadu_si128 (__m128i const* mem_address)
              MOVDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadVector128(System.Double*)">
            <summary>
            __m128d _mm_loadu_pd (double const* mem_address)
              MOVUPD xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadScalarVector128(System.Double*)">
            <summary>
            __m128d _mm_load_sd (double const* mem_address)
              MOVSD xmm, m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.SByte*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.Byte*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.Int16*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.UInt16*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.Int32*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.UInt32*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.Int64*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.UInt64*)">
            <summary>
            __m128i _mm_load_si128 (__m128i const* mem_address)
              MOVDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadAlignedVector128(System.Double*)">
            <summary>
            __m128d _mm_load_pd (double const* mem_address)
              MOVAPD xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadFence">
            <summary>
            void _mm_lfence(void)
              LFENCE
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadHigh(System.Runtime.Intrinsics.Vector128{System.Double},System.Double*)">
            <summary>
            __m128d _mm_loadh_pd (__m128d a, double const* mem_addr)
              MOVHPD xmm, m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadLow(System.Runtime.Intrinsics.Vector128{System.Double},System.Double*)">
            <summary>
            __m128d _mm_loadl_pd (__m128d a, double const* mem_addr)
              MOVLPD xmm, m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadScalarVector128(System.Int32*)">
            <summary>
            __m128i _mm_loadl_epi32 (__m128i const* mem_addr)
              MOVD xmm, reg/m64
            The above native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadScalarVector128(System.UInt32*)">
            <summary>
            __m128i _mm_loadl_epi32 (__m128i const* mem_addr)
              MOVD xmm, reg/m64
            The above native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadScalarVector128(System.Int64*)">
            <summary>
            __m128i _mm_loadl_epi64 (__m128i const* mem_addr)
              MOVQ xmm, reg/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.LoadScalarVector128(System.UInt64*)">
            <summary>
            __m128i _mm_loadl_epi64 (__m128i const* mem_addr)
              MOVQ xmm, reg/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MaskMove(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.SByte*)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a,  __m128i mask, char* mem_address)
              MASKMOVDQU xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MaskMove(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte*)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a,  __m128i mask, char* mem_address)
              MASKMOVDQU xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Max(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_max_epu8 (__m128i a,  __m128i b)
              PMAXUB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Max(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_max_epi16 (__m128i a,  __m128i b)
              PMAXSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Max(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_max_pd (__m128d a,  __m128d b)
              MAXPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MaxScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_max_sd (__m128d a,  __m128d b)
              MAXSD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MemoryFence">
            <summary>
            void _mm_mfence(void)
              MFENCE
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Min(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_min_epu8 (__m128i a,  __m128i b)
              PMINUB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Min(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_min_epi16 (__m128i a,  __m128i b)
              PMINSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Min(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_min_pd (__m128d a,  __m128d b)
              MINPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MinScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_min_sd (__m128d a,  __m128d b)
              MINSD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MoveScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_move_sd (__m128d a, __m128d b)
              MOVSD xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MoveMask(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            int _mm_movemask_epi8 (__m128i a)
              PMOVMSKB reg, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MoveMask(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            int _mm_movemask_epi8 (__m128i a)
              PMOVMSKB reg, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MoveMask(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_movemask_pd (__m128d a)
              MOVMSKPD reg, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MoveScalar(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_move_epi64 (__m128i a)
              MOVQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MoveScalar(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_move_epi64 (__m128i a)
              MOVQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Multiply(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_mul_epu32 (__m128i a,  __m128i b)
              PMULUDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Multiply(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_mul_pd (__m128d a,  __m128d b)
              MULPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MultiplyScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_mul_sd (__m128d a,  __m128d b)
              MULSD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MultiplyHigh(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_mulhi_epi16 (__m128i a,  __m128i b)
              PMULHW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MultiplyHigh(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_mulhi_epu16 (__m128i a,  __m128i b)
              PMULHUW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MultiplyAddAdjacent(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_madd_epi16 (__m128i a,  __m128i b)
              PMADDWD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MultiplyLow(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_mullo_epi16 (__m128i a,  __m128i b)
              PMULLW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.MultiplyLow(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_mullo_epi16 (__m128i a,  __m128i b)
              PMULLW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_or_si128 (__m128i a,  __m128i b)
              POR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Or(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_or_pd (__m128d a,  __m128d b)
              ORPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.PackSignedSaturate(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_packs_epi16 (__m128i a,  __m128i b)
              PACKSSWB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.PackSignedSaturate(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_packs_epi32 (__m128i a,  __m128i b)
              PACKSSDW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.PackUnsignedSaturate(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_packus_epi16 (__m128i a,  __m128i b)
              PACKUSWB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SumAbsoluteDifferences(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_sad_epu8 (__m128i a,  __m128i b)
              PSADBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Shuffle(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a,  int immediate)
              PSHUFD xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Shuffle(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a,  int immediate)
              PSHUFD xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Shuffle(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m128d _mm_shuffle_pd (__m128d a,  __m128d b, int immediate)
              SHUFPD xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShuffleHigh(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_shufflehi_epi16 (__m128i a,  int immediate)
              PSHUFHW xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShuffleHigh(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_shufflehi_epi16 (__m128i a,  int control)
              PSHUFHW xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShuffleLow(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a,  int control)
              PSHUFLW xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShuffleLow(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a,  int control)
              PSHUFLW xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_sll_epi16 (__m128i a, __m128i count)
              PSLLW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_sll_epi16 (__m128i a,  __m128i count)
              PSLLW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_sll_epi32 (__m128i a, __m128i count)
              PSLLD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_sll_epi32 (__m128i a, __m128i count)
              PSLLD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_sll_epi64 (__m128i a, __m128i count)
              PSLLQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_sll_epi64 (__m128i a, __m128i count)
              PSLLQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_slli_epi16 (__m128i a,  int immediate)
              PSLLW xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_slli_epi16 (__m128i a,  int immediate)
              PSLLW xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_slli_epi32 (__m128i a,  int immediate)
              PSLLD xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_slli_epi32 (__m128i a,  int immediate)
              PSLLD xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_slli_epi64 (__m128i a,  int immediate)
              PSLLQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_slli_epi64 (__m128i a,  int immediate)
              PSLLQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_bslli_si128 (__m128i a, int imm8)
              PSLLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_sra_epi16 (__m128i a, __m128i count)
              PSRAW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_sra_epi32 (__m128i a, __m128i count)
              PSRAD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_srai_epi16 (__m128i a,  int immediate)
              PSRAW xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightArithmetic(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_srai_epi32 (__m128i a,  int immediate)
              PSRAD xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_srl_epi16 (__m128i a, __m128i count)
              PSRLW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_srl_epi16 (__m128i a, __m128i count)
              PSRLW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_srl_epi32 (__m128i a, __m128i count)
              PSRLD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_srl_epi32 (__m128i a, __m128i count)
              PSRLD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_srl_epi64 (__m128i a, __m128i count)
              PSRLQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_srl_epi64 (__m128i a, __m128i count)
              PSRLQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_srli_epi16 (__m128i a,  int immediate)
              PSRLW xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_srli_epi16 (__m128i a,  int immediate)
              PSRLW xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_srli_epi32 (__m128i a,  int immediate)
              PSRLD xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_srli_epi32 (__m128i a,  int immediate)
              PSRLD xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_srli_epi64 (__m128i a,  int immediate)
              PSRLQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_srli_epi64 (__m128i a,  int immediate)
              PSRLQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8)
              PSRLDQ xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Sqrt(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_sqrt_pd (__m128d a)
              SQRTPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SqrtScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_sqrt_sd (__m128d a)
              SQRTSD xmm, xmm/64
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SqrtScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_sqrt_sd (__m128d a, __m128d b)
              SQRTSD xmm, xmm/64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreScalar(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_store_sd (double* mem_addr, __m128d a)
              MOVSD m64, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreScalar(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            void _mm_storel_epi64 (__m128i* mem_addr, __m128i a)
              MOVQ m64, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreScalar(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            void _mm_storel_epi64 (__m128i* mem_addr, __m128i a)
              MOVQ m64, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.SByte*,System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.Byte*,System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.Int16*,System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.UInt16*,System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.UInt32*,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            void _mm_store_si128 (__m128i* mem_addr, __m128i a)
              MOVDQA m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAligned(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_store_pd (double* mem_addr, __m128d a)
              MOVAPD m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.SByte*,System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.Byte*,System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.Int16*,System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.UInt16*,System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.UInt32*,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
              MOVNTDQ m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreAlignedNonTemporal(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_stream_pd (double* mem_addr, __m128d a)
              MOVNTPD m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.SByte*,System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.Byte*,System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.Int16*,System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.UInt16*,System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.Int32*,System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.UInt32*,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.Int64*,System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.UInt64*,System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
              MOVDQU m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Store(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_storeu_pd (double* mem_addr, __m128d a)
              MOVUPD m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreHigh(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_storeh_pd (double* mem_addr, __m128d a)
              MOVHPD m64, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreLow(System.Double*,System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_storel_pd (double* mem_addr, __m128d a)
              MOVLPD m64, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreNonTemporal(System.Int32*,System.Int32)">
            <summary>
            void _mm_stream_si32(int *p, int a)
              MOVNTI m32, r32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.StoreNonTemporal(System.UInt32*,System.UInt32)">
            <summary>
            void _mm_stream_si32(int *p, int a)
              MOVNTI m32, r32
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_sub_epi8 (__m128i a,  __m128i b)
              PSUBB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_sub_epi8 (__m128i a,  __m128i b)
              PSUBB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_sub_epi16 (__m128i a,  __m128i b)
              PSUBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_sub_epi16 (__m128i a,  __m128i b)
              PSUBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_sub_epi32 (__m128i a,  __m128i b)
              PSUBD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_sub_epi32 (__m128i a,  __m128i b)
              PSUBD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_sub_epi64 (__m128i a,  __m128i b)
              PSUBQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_sub_epi64 (__m128i a,  __m128i b)
              PSUBQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Subtract(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_sub_pd (__m128d a, __m128d b)
              SUBPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SubtractScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_sub_sd (__m128d a, __m128d b)
              SUBSD xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SubtractSaturate(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_subs_epi8 (__m128i a,  __m128i b)
              PSUBSB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SubtractSaturate(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_subs_epi16 (__m128i a,  __m128i b)
              PSUBSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SubtractSaturate(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_subs_epu8 (__m128i a,  __m128i b)
              PSUBUSB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.SubtractSaturate(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_subs_epu16 (__m128i a,  __m128i b)
              PSUBUSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_unpackhi_epi8 (__m128i a,  __m128i b)
              PUNPCKHBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_unpackhi_epi8 (__m128i a,  __m128i b)
              PUNPCKHBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_unpackhi_epi16 (__m128i a,  __m128i b)
              PUNPCKHWD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_unpackhi_epi16 (__m128i a,  __m128i b)
              PUNPCKHWD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_unpackhi_epi32 (__m128i a,  __m128i b)
              PUNPCKHDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_unpackhi_epi32 (__m128i a,  __m128i b)
              PUNPCKHDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_unpackhi_epi64 (__m128i a,  __m128i b)
              PUNPCKHQDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_unpackhi_epi64 (__m128i a,  __m128i b)
              PUNPCKHQDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackHigh(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_unpackhi_pd (__m128d a,  __m128d b)
              UNPCKHPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_unpacklo_epi8 (__m128i a,  __m128i b)
              PUNPCKLBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_unpacklo_epi8 (__m128i a,  __m128i b)
              PUNPCKLBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_unpacklo_epi16 (__m128i a,  __m128i b)
              PUNPCKLWD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_unpacklo_epi16 (__m128i a,  __m128i b)
              PUNPCKLWD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_unpacklo_epi32 (__m128i a,  __m128i b)
              PUNPCKLDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_unpacklo_epi32 (__m128i a,  __m128i b)
              PUNPCKLDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_unpacklo_epi64 (__m128i a,  __m128i b)
              PUNPCKLQDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_unpacklo_epi64 (__m128i a,  __m128i b)
              PUNPCKLQDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.UnpackLow(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_unpacklo_pd (__m128d a,  __m128d b)
              UNPCKLPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_xor_si128 (__m128i a,  __m128i b)
              PXOR xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse2.Xor(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_xor_pd (__m128d a,  __m128d b)
              XORPD xmm, xmm/m128
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Sse3">
            <summary>
            This class provides access to Intel SSE3 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.AddSubtract(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_addsub_ps (__m128 a, __m128 b)
              ADDSUBPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.AddSubtract(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_addsub_pd (__m128d a, __m128d b)
              ADDSUBPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.HorizontalAdd(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_hadd_ps (__m128 a, __m128 b)
              HADDPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.HorizontalAdd(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_hadd_pd (__m128d a, __m128d b)
              HADDPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.HorizontalSubtract(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_hsub_ps (__m128 a, __m128 b)
              HSUBPS xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.HorizontalSubtract(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_hsub_pd (__m128d a, __m128d b)
              HSUBPD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.LoadAndDuplicateToVector128(System.Double*)">
            <summary>
            __m128d _mm_loaddup_pd (double const* mem_addr)
            MOVDDUP xmm, m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.LoadDquVector128(System.SByte*)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr)
              LDDQU xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.MoveAndDuplicate(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_movedup_pd (__m128d a)
              MOVDDUP xmm, xmm/m64
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.MoveHighAndDuplicate(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_movehdup_ps (__m128 a)
              MOVSHDUP xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse3.MoveLowAndDuplicate(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_moveldup_ps (__m128 a)
              MOVSLDUP xmm, xmm/m128
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Sse41">
            <summary>
            This class provides access to Intel SSE4.1 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.X64.Extract(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __int64 _mm_extract_epi64 (__m128i a, const int imm8)
              PEXTRQ reg/m64, xmm, imm8
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.X64.Extract(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __int64 _mm_extract_epi64 (__m128i a, const int imm8)
              PEXTRQ reg/m64, xmm, imm8
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.X64.Insert(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64,System.Byte)">
            <summary>
            __m128i _mm_insert_epi64 (__m128i a, __int64 i, const int imm8)
              PINSRQ xmm, reg/m64, imm8
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.X64.Insert(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64,System.Byte)">
            <summary>
            __m128i _mm_insert_epi64 (__m128i a, __int64 i, const int imm8)
              PINSRQ xmm, reg/m64, imm8
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Blend(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8)
              PBLENDW xmm, xmm/m128 imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Blend(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8)
              PBLENDW xmm, xmm/m128 imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Blend(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_blend_ps (__m128 a, __m128 b, const int imm8)
              BLENDPS xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Blend(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8)
              BLENDPD xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            This intrinsic generates PBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            This intrinsic generates PBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            This intrinsic generates PBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            This intrinsic generates PBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            This intrinsic generates PBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
              PBLENDVB xmm, xmm/m128, xmm
            This intrinsic generates PBLENDVB that needs a BYTE mask-vector, so users should correctly set each mask byte for the selected elements.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_blendv_ps (__m128 a, __m128 b, __m128 mask)
              BLENDVPS xmm, xmm/m128, xmm0
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.BlendVariable(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_blendv_pd (__m128d a, __m128d b, __m128d mask)
              BLENDVPD xmm, xmm/m128, xmm0
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Ceiling(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_ceil_ps (__m128 a)
              ROUNDPS xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Ceiling(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_ceil_pd (__m128d a)
              ROUNDPD xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.CeilingScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_ceil_sd (__m128d a)
              ROUNDSD xmm, xmm/m128, imm8(10)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.CeilingScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_ceil_ss (__m128 a)
              ROUNDSD xmm, xmm/m128, imm8(10)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.CeilingScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_ceil_sd (__m128d a, __m128d b)
              ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.CeilingScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_ceil_ss (__m128 a, __m128 b)
              ROUNDSS xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.CompareEqual(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_cmpeq_epi64 (__m128i a, __m128i b)
              PCMPEQQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.CompareEqual(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_cmpeq_epi64 (__m128i a, __m128i b)
              PCMPEQQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int16(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a)
              PMOVSXBW xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int16(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a)
              PMOVZXBW xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cvtepi8_epi32 (__m128i a)
              PMOVSXBD xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_cvtepu8_epi32 (__m128i a)
              PMOVZXBD xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_cvtepi16_epi32 (__m128i a)
              PMOVSXWD xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_cvtepu16_epi32 (__m128i a)
              PMOVZXWD xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cvtepi8_epi64 (__m128i a)
              PMOVSXBQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_cvtepu8_epi64 (__m128i a)
              PMOVZXBQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_cvtepi16_epi64 (__m128i a)
              PMOVSXWQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_cvtepu16_epi64 (__m128i a)
              PMOVZXWQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_cvtepi32_epi64 (__m128i a)
              PMOVSXDQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a)
              PMOVZXDQ xmm, xmm
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int16(System.SByte*)">
            <summary>
              PMOVSXBW xmm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int16(System.Byte*)">
            <summary>
              PMOVZXBW xmm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.SByte*)">
            <summary>
              PMOVSXBD xmm, m32
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.Byte*)">
            <summary>
              PMOVZXBD xmm, m32
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.Int16*)">
            <summary>
              PMOVSXWD xmm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32(System.UInt16*)">
            <summary>
              PMOVZXWD xmm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.SByte*)">
            <summary>
              PMOVSXBQ xmm, m16
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Byte*)">
            <summary>
              PMOVZXBQ xmm, m16
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Int16*)">
            <summary>
              PMOVSXWQ xmm, m32
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.UInt16*)">
            <summary>
              PMOVZXWQ xmm, m32
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.Int32*)">
            <summary>
              PMOVSXDQ xmm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64(System.UInt32*)">
            <summary>
              PMOVZXDQ xmm, m64
            The native signature does not exist. We provide this additional overload for completeness.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.DotProduct(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_dp_ps (__m128 a, __m128 b, const int imm8)
              DPPS xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.DotProduct(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m128d _mm_dp_pd (__m128d a, __m128d b, const int imm8)
              DPPD xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Extract(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            int _mm_extract_epi8 (__m128i a, const int imm8)
              PEXTRB reg/m8, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Extract(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            int _mm_extract_epi32 (__m128i a, const int imm8)
              PEXTRD reg/m32, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Extract(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            int _mm_extract_epi32 (__m128i a, const int imm8)
              PEXTRD reg/m32, xmm, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Extract(System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            int _mm_extract_ps (__m128 a, const int imm8)
              EXTRACTPS xmm, xmm/m32, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Floor(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_floor_ps (__m128 a)
              ROUNDPS xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Floor(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_floor_pd (__m128d a)
              ROUNDPD xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.FloorScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_floor_sd (__m128d a)
              ROUNDSD xmm, xmm/m128, imm8(9)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.FloorScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_floor_ss (__m128 a)
              ROUNDSS xmm, xmm/m128, imm8(9)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.FloorScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_floor_sd (__m128d a, __m128d b)
              ROUNDSD xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.FloorScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_floor_ss (__m128 a, __m128 b)
              ROUNDSS xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Insert(System.Runtime.Intrinsics.Vector128{System.SByte},System.SByte,System.Byte)">
            <summary>
            __m128i _mm_insert_epi8 (__m128i a, int i, const int imm8)
              PINSRB xmm, reg/m8, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Insert(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte,System.Byte)">
            <summary>
            __m128i _mm_insert_epi8 (__m128i a, int i, const int imm8)
              PINSRB xmm, reg/m8, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Insert(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32,System.Byte)">
            <summary>
            __m128i _mm_insert_epi32 (__m128i a, int i, const int imm8)
              PINSRD xmm, reg/m32, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Insert(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32,System.Byte)">
            <summary>
            __m128i _mm_insert_epi32 (__m128i a, int i, const int imm8)
              PINSRD xmm, reg/m32, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Insert(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_insert_ps (__m128 a, __m128 b, const int imm8)
              INSERTPS xmm, xmm/m32, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Max(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_max_epi8 (__m128i a, __m128i b)
              PMAXSB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Max(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_max_epu16 (__m128i a, __m128i b)
              PMAXUW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Max(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_max_epi32 (__m128i a, __m128i b)
              PMAXSD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Max(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_max_epu32 (__m128i a, __m128i b)
              PMAXUD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Min(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_min_epi8 (__m128i a, __m128i b)
              PMINSB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Min(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_min_epu16 (__m128i a, __m128i b)
              PMINUW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Min(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_min_epi32 (__m128i a, __m128i b)
              PMINSD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Min(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_min_epu32 (__m128i a, __m128i b)
              PMINUD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.MinHorizontal(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_minpos_epu16 (__m128i a)
              PHMINPOSUW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.MultipleSumAbsoluteDifferences(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_mpsadbw_epu8 (__m128i a, __m128i b, const int imm8)
              MPSADBW xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.Multiply(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_mul_epi32 (__m128i a, __m128i b)
              PMULDQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.MultiplyLow(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_mullo_epi32 (__m128i a, __m128i b)
              PMULLD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.MultiplyLow(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_mullo_epi32 (__m128i a, __m128i b)
              PMULLD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.PackUnsignedSaturate(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_packus_epi32 (__m128i a, __m128i b)
              PACKUSDW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNearestInteger(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ps (__m128 a, int rounding)
              ROUNDPS xmm, xmm/m128, imm8(8)
            _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNegativeInfinity(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC; ROUNDPS xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToPositiveInfinity(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC; ROUNDPS xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToZero(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC; ROUNDPS xmm, xmm/m128, imm8(11)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirection(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            _MM_FROUND_CUR_DIRECTION; ROUNDPS xmm, xmm/m128, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNearestInteger(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_pd (__m128d a, int rounding)
              ROUNDPD xmm, xmm/m128, imm8(8)
            _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNegativeInfinity(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC; ROUNDPD xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToPositiveInfinity(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC; ROUNDPD xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToZero(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC; ROUNDPD xmm, xmm/m128, imm8(11)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirection(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            _MM_FROUND_CUR_DIRECTION; ROUNDPD xmm, xmm/m128, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirectionScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, _MM_FROUND_CUR_DIRECTION)
              ROUNDSD xmm, xmm/m128, imm8(4)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNearestIntegerScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(8)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNegativeInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(9)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToPositiveInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(10)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToZeroScalar(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(11)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirectionScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_CUR_DIRECTION)
              ROUNDSD xmm, xmm/m128, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNearestIntegerScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(8)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNegativeInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToPositiveInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToZeroScalar(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)
              ROUNDSD xmm, xmm/m128, imm8(11)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirectionScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, _MM_FROUND_CUR_DIRECTION)
              ROUNDSS xmm, xmm/m128, imm8(4)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNearestIntegerScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(8)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNegativeInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(9)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToPositiveInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(10)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToZeroScalar(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(11)
            The above native signature does not exist. We provide this additional overload for the recommended use case of this intrinsic.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirectionScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_CUR_DIRECTION)
              ROUNDSS xmm, xmm/m128, imm8(4)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNearestIntegerScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(8)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToNegativeInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(9)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToPositiveInfinityScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(10)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.RoundToZeroScalar(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
              ROUNDSS xmm, xmm/m128, imm8(11)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.SByte*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.Byte*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.Int16*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.UInt16*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.Int32*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.UInt32*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.Int64*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.LoadAlignedVector128NonTemporal(System.UInt64*)">
            <summary>
            __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
              MOVNTDQA xmm, m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.TestC(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b)
              PTEST xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.TestNotZAndNotC(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b)
              PTEST xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse41.TestZ(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b)
              PTEST xmm, xmm/m128
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Sse42">
            <summary>
            This class provides access to Intel SSE4.2 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse42.X64.Crc32(System.UInt64,System.UInt64)">
            <summary>
            unsigned __int64 _mm_crc32_u64 (unsigned __int64 crc, unsigned __int64 v)
              CRC32 reg, reg/m64
            This intrinisc is only available on 64-bit processes
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse42.CompareGreaterThan(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_cmpgt_epi64 (__m128i a, __m128i b)
              PCMPGTQ xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse42.Crc32(System.UInt32,System.Byte)">
            <summary>
            unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v)
              CRC32 reg, reg/m8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse42.Crc32(System.UInt32,System.UInt16)">
            <summary>
            unsigned int _mm_crc32_u16 (unsigned int crc, unsigned short v)
              CRC32 reg, reg/m16
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Sse42.Crc32(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _mm_crc32_u32 (unsigned int crc, unsigned int v)
              CRC32 reg, reg/m32
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.X86.Ssse3">
            <summary>
            This class provides access to Intel SSSE3 hardware instructions via intrinsics
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Abs(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_abs_epi8 (__m128i a)
              PABSB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Abs(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_abs_epi16 (__m128i a)
              PABSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Abs(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_abs_epi32 (__m128i a)
              PABSD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            This intrinsic generates PALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            This intrinsic generates PALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            This intrinsic generates PALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            This intrinsic generates PALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            This intrinsic generates PALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            This intrinsic generates PALIGNR that operates over bytes rather than elements of the vectors.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.AlignRight(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
              PALIGNR xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.HorizontalAdd(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_hadd_epi16 (__m128i a, __m128i b)
              PHADDW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.HorizontalAdd(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_hadd_epi32 (__m128i a, __m128i b)
              PHADDD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.HorizontalAddSaturate(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_hadds_epi16 (__m128i a, __m128i b)
              PHADDSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.HorizontalSubtract(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_hsub_epi16 (__m128i a, __m128i b)
              PHSUBW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.HorizontalSubtract(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_hsub_epi32 (__m128i a, __m128i b)
              PHSUBD xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.HorizontalSubtractSaturate(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_hsubs_epi16 (__m128i a, __m128i b)
              PHSUBSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.MultiplyAddAdjacent(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_maddubs_epi16 (__m128i a, __m128i b)
              PMADDUBSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.MultiplyHighRoundScale(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_mulhrs_epi16 (__m128i a, __m128i b)
              PMULHRSW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Shuffle(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b)
              PSHUFB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Shuffle(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b)
              PSHUFB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Sign(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_sign_epi8 (__m128i a, __m128i b)
              PSIGNB xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Sign(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_sign_epi16 (__m128i a, __m128i b)
              PSIGNW xmm, xmm/m128
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.X86.Ssse3.Sign(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_sign_epi32 (__m128i a, __m128i b)
              PSIGND xmm, xmm/m128
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.Arm.Arm64.Aes">
             <summary>
             This class provides access to the Arm64 AES Crypto intrinsics
            
             Arm64 CPU indicate support for this feature by setting
             ID_AA64ISAR0_EL1.AES is 1 or better
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Aes.Decrypt(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Performs AES single round decryption
            vaesdq_u8 (uint8x16_t data, uint8x16_t key)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Aes.Encrypt(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Performs AES single round encryption
            vaeseq_u8 (uint8x16_t data, uint8x16_t key)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Aes.MixColumns(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Performs AES  Mix Columns
            vaesmcq_u8 (uint8x16_t data)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Aes.InverseMixColumns(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Performs AES inverse mix columns
            vaesimcq_u8  (uint8x16_t data)
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.Arm.Arm64.Base">
             <summary>
             This class provides access to the Arm64 Base intrinsics
            
             These intrinsics are supported by all Arm64 CPUs
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Base.LeadingSignCount(System.Int32)">
            <summary>
            Vector LeadingSignCount
            Corresponds to integer forms of ARM64 CLS
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Base.LeadingZeroCount(System.Int32)">
            <summary>
            Vector LeadingZeroCount
            Corresponds to integer forms of ARM64 CLZ
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.Arm.Arm64.Sha1">
             <summary>
             This class provides access to the Arm64 SHA1 Crypto intrinsics
            
             Arm64 CPU indicate support for this feature by setting
             ID_AA64ISAR0_EL1.SHA1 is 1 or better
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha1.HashChoose(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA1 hash update choose form.
            vsha1cq_u32 (uint32x4_t hash_abcd, uint32_t hash_e, uint32x4_t wk)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha1.HashMajority(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA1 hash update majority form.
            vsha1mq_u32 (uint32x4_t hash_abcd, uint32_t hash_e, uint32x4_t wk)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha1.HashParity(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA1 hash update parity form.
            vsha1pq_u32 (uint32x4_t hash_abcd, uint32_t hash_e, uint32x4_t wk)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha1.FixedRotate(System.UInt32)">
            <summary>
            Performs SHA1 fixed rotate
            vsha1h_u32 (uint32_t hash_e)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha1.SchedulePart1(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA1 schedule update 0
            vsha1su0q_u32 (uint32x4_t w0_3, uint32x4_t w4_7, uint32x4_t w8_11)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha1.SchedulePart2(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA1 schedule update 1
            vsha1su1q_u32 (uint32x4_t tw0_3, uint32x4_t w12_15)
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.Arm.Arm64.Sha256">
             <summary>
             This class provides access to the Arm64 SHA256 Crypto intrinsics
            
             Arm64 CPU indicate support for this feature by setting
             ID_AA64ISAR0_EL1.SHA2 is 1 or better
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha256.HashLower(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA256 hash update (part 1).
            vsha256hq_u32 (uint32x4_t hash_abcd, uint32x4_t hash_efgh, uint32x4_t wk)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha256.HashUpper(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA256 hash update (part 2).
            vsha256h2q_u32 (uint32x4_t hash_efgh, uint32x4_t hash_abcd, uint32x4_t wk)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha256.SchedulePart1(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA256 schedule update 0
            vsha256su0q_u32 (uint32x4_t w0_3, uint32x4_t w4_7)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Sha256.SchedulePart2(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Performs SHA256 schedule update 1
            vsha256su1q_u32 (uint32x4_t w0_3, uint32x4_t w8_11, uint32x4_t w12_15)
            </summary>
        </member>
        <member name="T:System.Runtime.Intrinsics.Arm.Arm64.Simd">
             <summary>
             This class provides access to the Arm64 AdvSIMD intrinsics
            
             Arm64 CPU indicate support for this feature by setting
             ID_AA64PFR0_EL1.AdvSIMD == 0 or better.
             </summary>
        </member>
        <member name="P:System.Runtime.Intrinsics.Arm.Arm64.Simd.IsSupported">
            <summary>
            IsSupported property indicates whether any method provided
            by this class is supported by the current runtime.
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Abs(System.Runtime.Intrinsics.Vector64{System.SByte})">
            <summary>
            Vector abs
            Corresponds to vector forms of ARM64 ABS &amp; FABS
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Add``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector add
            Corresponds to vector forms of ARM64 ADD &amp; FADD
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.And``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector and
            Corresponds to vector forms of ARM64 AND
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.AndNot``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector and not
            Corresponds to vector forms of ARM64 BIC
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.BitwiseSelect``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector BitwiseSelect
            For each bit in the vector result[bit] = sel[bit] ? left[bit] : right[bit]
            Corresponds to vector forms of ARM64 BSL (Also BIF &amp; BIT)
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareEqual``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareEqual
            For each element result[elem] = (left[elem] == right[elem]) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMEQ &amp; FCMEQ
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareEqualZero``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareEqualZero
            For each element result[elem] = (left[elem] == 0) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMEQ &amp; FCMEQ
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareGreaterThan``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareGreaterThan
            For each element result[elem] = (left[elem] > right[elem]) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMGT/CMHI &amp; FCMGT
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareGreaterThanZero``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareGreaterThanZero
            For each element result[elem] = (left[elem] > 0) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMGT &amp; FCMGT
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareGreaterThanOrEqual``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareGreaterThanOrEqual
            For each element result[elem] = (left[elem] >= right[elem]) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMGE/CMHS &amp; FCMGE
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareGreaterThanOrEqualZero``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareGreaterThanOrEqualZero
            For each element result[elem] = (left[elem] >= 0) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMGE &amp; FCMGE
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareLessThanZero``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareLessThanZero
            For each element result[elem] = (left[elem] &lt; 0) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMGT &amp; FCMGT
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareLessThanOrEqualZero``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareLessThanOrEqualZero
            For each element result[elem] = (left[elem] &lt; 0) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMGT &amp; FCMGT
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.CompareTest``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector CompareTest
            For each element result[elem] = (left[elem] &amp; right[elem]) ? ~0 : 0
            Corresponds to vector forms of ARM64 CMTST
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Divide(System.Runtime.Intrinsics.Vector64{System.Single},System.Runtime.Intrinsics.Vector64{System.Single})">
            TBD Convert...
            <summary>
            Vector Divide
            Corresponds to vector forms of ARM64 FDIV
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Extract``1(System.Runtime.Intrinsics.Vector64{``0},System.Byte)">
             <summary>
             Vector extract item
            
             result = vector[index]
            
             Note: In order to be inlined, index must be a JIT time const expression which can be used to
             populate the literal immediate field.  Use of a non constant will result in generation of a switch table
            
             Corresponds to vector forms of ARM64 MOV
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Insert``1(System.Runtime.Intrinsics.Vector64{``0},System.Byte,``0)">
             <summary>
             Vector insert item
            
             result = vector;
             result[index] = data;
            
             Note: In order to be inlined, index must be a JIT time const expression which can be used to
             populate the literal immediate field.  Use of a non constant will result in generation of a switch table
            
             Corresponds to vector forms of ARM64 INS
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.LeadingSignCount(System.Runtime.Intrinsics.Vector64{System.SByte})">
            <summary>
            Vector LeadingSignCount
            Corresponds to vector forms of ARM64 CLS
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.LeadingZeroCount(System.Runtime.Intrinsics.Vector64{System.Byte})">
            <summary>
            Vector LeadingZeroCount
            Corresponds to vector forms of ARM64 CLZ
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Max(System.Runtime.Intrinsics.Vector64{System.Byte},System.Runtime.Intrinsics.Vector64{System.Byte})">
            <summary>
            Vector max
            Corresponds to vector forms of ARM64 SMAX, UMAX &amp; FMAX
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Min(System.Runtime.Intrinsics.Vector64{System.Byte},System.Runtime.Intrinsics.Vector64{System.Byte})">
            <summary>
            Vector min
            Corresponds to vector forms of ARM64 SMIN, UMIN &amp; FMIN
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Multiply(System.Runtime.Intrinsics.Vector64{System.Byte},System.Runtime.Intrinsics.Vector64{System.Byte})">
            TBD MOV, FMOV
             <summary>
             Vector multiply
            
             For each element result[elem] = left[elem] * right[elem]
            
             Corresponds to vector forms of ARM64 MUL &amp; FMUL
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Negate(System.Runtime.Intrinsics.Vector64{System.SByte})">
            <summary>
            Vector negate
            Corresponds to vector forms of ARM64 NEG &amp; FNEG
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Not``1(System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector not
            Corresponds to vector forms of ARM64 NOT
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Or``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector or
            Corresponds to vector forms of ARM64 ORR
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.OrNot``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector or not
            Corresponds to vector forms of ARM64 ORN
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.PopCount(System.Runtime.Intrinsics.Vector64{System.Byte})">
            <summary>
            Vector PopCount
            Corresponds to vector forms of ARM64 CNT
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.SetAllVector64``1(``0)">
             <summary>
             SetVector* Fill vector elements by replicating element value
            
             Corresponds to vector forms of ARM64 DUP (general), DUP (element 0), FMOV (vector, immediate)
             </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Sqrt(System.Runtime.Intrinsics.Vector64{System.Single})">
            <summary>
            Vector square root
            Corresponds to vector forms of ARM64 FRSQRT
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Subtract``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector subtract
            Corresponds to vector forms of ARM64 SUB &amp; FSUB
            </summary>
        </member>
        <member name="M:System.Runtime.Intrinsics.Arm.Arm64.Simd.Xor``1(System.Runtime.Intrinsics.Vector64{``0},System.Runtime.Intrinsics.Vector64{``0})">
            <summary>
            Vector exclusive or
            Corresponds to vector forms of ARM64 EOR
            </summary>
        </member>
        <member name="M:System.Runtime.Serialization.SerializationException.#ctor">
            <summary>
            Creates a new SerializationException with its message  
            string set to a default message.
            </summary>
        </member>
        <member name="T:System.Runtime.Serialization.SerializationInfo">
            <summary>The structure for holding all of the data needed for object serialization and deserialization.</summary>
        </member>
        <member name="M:System.Runtime.Serialization.SerializationInfo.UpdateValue(System.String,System.Object,System.Type)">
             <summary>
             Finds the value if it exists in the current data. If it does, we replace
             the values, if not, we append it to the end. This is useful to the 
             ObjectManager when it's performing fixups.
             
             All error checking is done with asserts. Although public in coreclr,
             it's not exposed in a contract and is only meant to be used by corefx.
            
             This isn't a public API, but it gets invoked dynamically by 
             BinaryFormatter
            
             This should not be used by clients: exposing out this functionality would allow children
             to overwrite their parent's values. It is public in order to give corefx access to it for
             its ObjectManager implementation, but it should not be exposed out of a contract.
             </summary>
             <param name="name"> The name of the data to be updated.</param>
             <param name="value"> The new value.</param>
             <param name="type"> The type of the data being added.</param>
        </member>
        <member name="M:System.Runtime.Serialization.SerializationInfo.GetElement(System.String,System.Type@)">
            <summary>
            Gets the location of a particular member and then returns
            the value of the element at that location.  The type of the member is
            returned in the foundType field.
            </summary>
            <param name="name"> The name of the element to find.</param>
            <param name="foundType"> The type of the element associated with the given name.</param>
            <returns>The value of the element at the position associated with name.</returns>
        </member>
        <member name="T:System.Security.SecureString.UnmanagedBuffer">
            <summary>SafeBuffer for managing memory meant to be kept confidential.</summary>
        </member>
        <member name="M:System.String.GetPinnableReference">
            <summary>
            Returns a reference to the first element of the String. If the string is null, an access will throw a NullReferenceException.
            </summary>
        </member>
        <member name="M:System.String.EnumerateRunes">
            <summary>
            Returns an enumeration of <see cref="T:System.Text.Rune"/> from this string.
            </summary>
            <remarks>
            Invalid sequences will be represented in the enumeration by <see cref="P:System.Text.Rune.ReplacementChar"/>.
            </remarks>
        </member>
        <member name="M:System.String.MakeSeparatorList(System.ReadOnlySpan{System.Char},System.Collections.Generic.ValueListBuilder{System.Int32}@)">
            <summary>
            Uses ValueListBuilder to create list that holds indexes of separators in string.
            </summary>
            <param name="separators"><see cref="T:System.ReadOnlySpan`1"/> of separator chars</param>
            <param name="sepListBuilder"><see cref="T:System.Collections.Generic.ValueListBuilder`1"/> to store indexes</param>
            <returns></returns>
        </member>
        <member name="M:System.String.MakeSeparatorList(System.String,System.Collections.Generic.ValueListBuilder{System.Int32}@)">
            <summary>
            Uses ValueListBuilder to create list that holds indexes of separators in string.
            </summary>
            <param name="separator">separator string</param>
            <param name="sepListBuilder"><see cref="T:System.Collections.Generic.ValueListBuilder`1"/> to store indexes</param>
            <returns></returns>
        </member>
        <member name="M:System.String.MakeSeparatorList(System.String[],System.Collections.Generic.ValueListBuilder{System.Int32}@,System.Collections.Generic.ValueListBuilder{System.Int32}@)">
            <summary>
            Uses ValueListBuilder to create list that holds indexes of separators in string and list that holds length of separator strings.
            </summary>
            <param name="separators">separator strngs</param>
            <param name="sepListBuilder"><see cref="T:System.Collections.Generic.ValueListBuilder`1"/> for separator indexes</param>
            <param name="lengthListBuilder"><see cref="T:System.Collections.Generic.ValueListBuilder`1"/> for separator length values</param>
        </member>
        <member name="M:System.Text.StringBuilder.InternalCopy(System.IntPtr,System.Int32)">
            <summary>
            Copies the contents of this builder to the specified buffer.
            </summary>
            <param name="dest">The destination buffer.</param>
            <param name="len">The number of bytes in the destination buffer.</param>
        </member>
        <member name="F:System.Text.StringBuilder.m_ChunkChars">
            <summary>
            The character buffer for this chunk.
            </summary>
        </member>
        <member name="F:System.Text.StringBuilder.m_ChunkPrevious">
            <summary>
            The chunk that logically precedes this chunk.
            </summary>
        </member>
        <member name="F:System.Text.StringBuilder.m_ChunkLength">
            <summary>
            The number of characters in this chunk.
            This is the number of elements in <see cref="F:System.Text.StringBuilder.m_ChunkChars"/> that are in use, from the start of the buffer.
            </summary>
        </member>
        <member name="F:System.Text.StringBuilder.m_ChunkOffset">
            <summary>
            The logical offset of this chunk's characters in the string it is a part of.
            This is the sum of the number of characters in preceding blocks.
            </summary>
        </member>
        <member name="F:System.Text.StringBuilder.m_MaxCapacity">
            <summary>
            The maximum capacity this builder is allowed to have.
            </summary>
        </member>
        <member name="F:System.Text.StringBuilder.DefaultCapacity">
            <summary>
            The default capacity of a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.StringBuilder"/> class.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.StringBuilder"/> class.
            </summary>
            <param name="capacity">The initial capacity of this builder.</param>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.StringBuilder"/> class.
            </summary>
            <param name="value">The initial contents of this builder.</param>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.StringBuilder"/> class.
            </summary>
            <param name="value">The initial contents of this builder.</param>
            <param name="capacity">The initial capacity of this builder.</param>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.StringBuilder"/> class.
            </summary>
            <param name="value">The initial contents of this builder.</param>
            <param name="startIndex">The index to start in <paramref name="value"/>.</param>
            <param name="length">The number of characters to read in <paramref name="value"/>.</param>
            <param name="capacity">The initial capacity of this builder.</param>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Text.StringBuilder"/> class.
            </summary>
            <param name="capacity">The initial capacity of this builder.</param>
            <param name="maxCapacity">The maximum capacity of this builder.</param>
        </member>
        <member name="P:System.Text.StringBuilder.MaxCapacity">
            <summary>
            Gets the maximum capacity this builder is allowed to have.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this builder is at least the specified value.
            </summary>
            <param name="capacity">The new capacity for this builder.</param>
            <remarks>
            If <paramref name="capacity"/> is less than or equal to the current capacity of
            this builder, the capacity remains unchanged.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)">
            <summary>
            Creates a string from a substring of this builder.
            </summary>
            <param name="startIndex">The index to start in this builder.</param>
            <param name="length">The number of characters to read in this builder.</param>
        </member>
        <member name="P:System.Text.StringBuilder.Length">
            <summary>
            Gets or sets the length of this builder.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilder.GetChunks">
             <summary>
             GetChunks returns ChunkEnumerator that follows the IEnumerable pattern and
             thus can be used in a C# 'foreach' statements to retreive the data in the StringBuilder
             as chunks (ReadOnlyMemory) of characters.  An example use is:
             
                  foreach (ReadOnlyMemory&lt;char&gt; chunk in sb.GetChunks())
                     foreach(char c in chunk.Span)
                         { /* operation on c }
            
             It is undefined what happens if the StringBuilder is modified while the chunk
             enumeration is incomplete.  StringBuilder is also not thread-safe, so operating
             on it with concurrent threads is illegal.  Finally the ReadOnlyMemory chunks returned 
             are NOT guarenteed to remain unchanged if the StringBuilder is modified, so do 
             not cache them for later use either.  This API's purpose is efficiently extracting
             the data of a CONSTANT StringBuilder.  
             
             Creating a ReadOnlySpan from a ReadOnlyMemory  (the .Span property) is expensive 
             compared to the fetching of the character, so create a local variable for the SPAN 
             if you need to use it in a nested for statement.  For example 
             
                foreach (ReadOnlyMemory&lt;char&gt; chunk in sb.GetChunks())
                {
                     var span = chunk.Span;
                     for(int i = 0; i &lt; span.Length; i++)
                         { /* operation on span[i] */ }
                }
             </summary>
        </member>
        <member name="T:System.Text.StringBuilder.ChunkEnumerator">
            <summary>
            ChunkEnumerator supports both the IEnumerable and IEnumerator pattern so foreach 
            works (see GetChunks).  It needs to be public (so the compiler can use it 
            when building a foreach statement) but users typically don't use it explicitly.
            (which is why it is a nested type). 
            </summary>
        </member>
        <member name="M:System.Text.StringBuilder.ChunkEnumerator.GetEnumerator">
            <summary>
            Implement IEnumerable.GetEnumerator() to return  'this' as the IEnumerator  
            </summary>
        </member>
        <member name="M:System.Text.StringBuilder.ChunkEnumerator.MoveNext">
            <summary>
            Implements the IEnumerator pattern.
            </summary>
        </member>
        <member name="P:System.Text.StringBuilder.ChunkEnumerator.Current">
            <summary>
            Implements the IEnumerator pattern.
            </summary>
        </member>
        <member name="T:System.Text.StringBuilder.ChunkEnumerator.ManyChunkInfo">
            <summary>
            Used to hold all the chunks indexes when you have many chunks. 
            </summary>
        </member>
        <member name="M:System.Text.StringBuilder.Append(System.Char,System.Int32)">
            <summary>
            Appends a character 0 or more times to the end of this builder.
            </summary>
            <param name="value">The character to append.</param>
            <param name="repeatCount">The number of times to append <paramref name="value"/>.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)">
            <summary>
            Appends a range of characters to the end of this builder.
            </summary>
            <param name="value">The characters to append.</param>
            <param name="startIndex">The index to start in <paramref name="value"/>.</param>
            <param name="charCount">The number of characters to read in <paramref name="value"/>.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Append(System.String)">
            <summary>
            Appends a string to the end of this builder.
            </summary>
            <param name="value">The string to append.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)">
            <summary>
            Appends part of a string to the end of this builder.
            </summary>
            <param name="value">The string to append.</param>
            <param name="startIndex">The index to start in <paramref name="value"/>.</param>
            <param name="count">The number of characters to read in <paramref name="value"/>.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)">
            <summary>
            Inserts a string 0 or more times into this builder at the specified position.
            </summary>
            <param name="index">The index to insert in this builder.</param>
            <param name="value">The string to insert.</param>
            <param name="count">The number of times to insert the string.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)">
            <summary>
            Removes a range of characters from this builder.
            </summary>
            <remarks>
            This method does not reduce the capacity of this builder.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.Replace(System.String,System.String)">
            <summary>
            Replaces all instances of one string with another in this builder.
            </summary>
            <param name="oldValue">The string to replace.</param>
            <param name="newValue">The string to replace <paramref name="oldValue"/> with.</param>
            <remarks>
            If <paramref name="newValue"/> is <c>null</c>, instances of <paramref name="oldValue"/>
            are removed from this builder.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)">
            <summary>
            Determines if the contents of this builder are equal to the contents of another builder.
            </summary>
            <param name="sb">The other builder.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})">
            <summary>
            Determines if the contents of this builder are equal to the contents of <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <param name="span">The <see cref="T:System.ReadOnlySpan`1"/>.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Replaces all instances of one string with another in part of this builder.
            </summary>
            <param name="oldValue">The string to replace.</param>
            <param name="newValue">The string to replace <paramref name="oldValue"/> with.</param>
            <param name="startIndex">The index to start in this builder.</param>
            <param name="count">The number of characters to read in this builder.</param>
            <remarks>
            If <paramref name="newValue"/> is <c>null</c>, instances of <paramref name="oldValue"/>
            are removed from this builder.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.Replace(System.Char,System.Char)">
            <summary>
            Replaces all instances of one character with another in this builder.
            </summary>
            <param name="oldChar">The character to replace.</param>
            <param name="newChar">The character to replace <paramref name="oldChar"/> with.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)">
            <summary>
            Replaces all instances of one character with another in this builder.
            </summary>
            <param name="oldChar">The character to replace.</param>
            <param name="newChar">The character to replace <paramref name="oldChar"/> with.</param>
            <param name="startIndex">The index to start in this builder.</param>
            <param name="count">The number of characters to read in this builder.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)">
            <summary>
            Appends a character buffer to this builder.
            </summary>
            <param name="value">The pointer to the start of the buffer.</param>
            <param name="valueCount">The number of characters in the buffer.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Insert(System.Int32,System.Char*,System.Int32)">
            <summary>
            Inserts a character buffer into this builder at the specified position.
            </summary>
            <param name="index">The index to insert in this builder.</param>
            <param name="value">The pointer to the start of the buffer.</param>
            <param name="valueCount">The number of characters in the buffer.</param>
        </member>
        <member name="M:System.Text.StringBuilder.ReplaceAllInChunk(System.Int32[],System.Int32,System.Text.StringBuilder,System.Int32,System.String)">
            <summary>
            Replaces strings at specified indices with a new string in a chunk.
            </summary>
            <param name="replacements">The list of indices, relative to the beginning of the chunk, to remove at.</param>
            <param name="replacementsCount">The number of replacements to make.</param>
            <param name="sourceChunk">The source chunk.</param>
            <param name="removeCount">The number of characters to remove at each replacement.</param>
            <param name="value">The string to insert at each replacement.</param>
            <remarks>
            This routine is very efficient because it does replacements in bulk.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.StartsWith(System.Text.StringBuilder,System.Int32,System.Int32,System.String)">
            <summary>
            Returns a value indicating whether a substring of a builder starts with a specified prefix.
            </summary>
            <param name="chunk">The chunk in which the substring starts.</param>
            <param name="indexInChunk">The index in <paramref name="chunk"/> at which the substring starts.</param>
            <param name="count">The logical count of the substring.</param>
            <param name="value">The prefix.</param>
        </member>
        <member name="M:System.Text.StringBuilder.ReplaceInPlaceAtChunk(System.Text.StringBuilder@,System.Int32@,System.Char*,System.Int32)">
            <summary>
            Replaces characters at a specified location with the contents of a character buffer.
            This function is the logical equivalent of memcpy.
            </summary>
            <param name="chunk">
            The chunk in which to start replacing characters.
            Receives the chunk in which character replacement ends.
            </param>
            <param name="indexInChunk">
            The index in <paramref name="chunk"/> to start replacing characters at.
            Receives the index at which character replacement ends.
            </param>
            <param name="value">The pointer to the start of the character buffer.</param>
            <param name="count">The number of characters in the buffer.</param>
        </member>
        <member name="M:System.Text.StringBuilder.ThreadSafeCopy(System.Char*,System.Char[],System.Int32,System.Int32)">
            <remarks>
            This method prevents out-of-bounds writes in the case a different thread updates a field in the builder just before a copy begins.
            All interesting variables are copied out of the heap into the parameters of this method, and then bounds checks are run.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.FindChunkForIndex(System.Int32)">
            <summary>
            Gets the chunk corresponding to the logical index in this builder.
            </summary>
            <param name="index">The logical index in this builder.</param>
            <remarks>
            After calling this method, you can obtain the actual index within the chunk by
            subtracting <see cref="F:System.Text.StringBuilder.m_ChunkOffset"/> from <paramref name="index"/>.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.FindChunkForByte(System.Int32)">
            <summary>
            Gets the chunk corresponding to the logical byte index in this builder.
            </summary>
            <param name="byteIndex">The logical byte index in this builder.</param>
        </member>
        <member name="P:System.Text.StringBuilder.RemainingCurrentChunk">
            <summary>Gets a span representing the remaining space available in the current chunk.</summary>
        </member>
        <member name="M:System.Text.StringBuilder.Next(System.Text.StringBuilder)">
            <summary>
            Finds the chunk that logically succeeds the specified chunk.
            </summary>
            <param name="chunk">The chunk whose successor should be found.</param>
            <remarks>
            Each chunk only stores the pointer to its logical predecessor, so this routine has to start
            from the 'this' pointer (which is assumed to represent the whole StringBuilder) and work its
            way down until it finds the specified chunk (which is O(n)). Thus, it is more expensive than
            a field fetch.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.ExpandByABlock(System.Int32)">
            <summary>
            Transfers the character buffer from this chunk to a new chunk, and allocates a new buffer with a minimum size for this chunk.
            </summary>
            <param name="minBlockCharCount">The minimum size of the new buffer to be allocated for this chunk.</param>
            <remarks>
            This method requires that the current chunk is full. Otherwise, there's no point in shifting the characters over.
            It also assumes that 'this' is the last chunk in the linked list.
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor(System.Text.StringBuilder)">
            <summary>
            Creates a new chunk with fields copied from an existing chunk.
            </summary>
            <param name="from">The chunk from which to copy fields.</param>
            <remarks>
            <para>
            This method runs in O(1) time. It does not copy data within the character buffer
            <paramref name="from"/> holds, but copies the reference to the character buffer itself
            (plus a few other fields).
            </para>
            <para>
            Callers are expected to update <paramref name="from"/> subsequently to point to this
            chunk as its predecessor.
            </para>
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.MakeRoom(System.Int32,System.Int32,System.Text.StringBuilder@,System.Int32@,System.Boolean)">
            <summary>
            Creates a gap at a logical index with the specified count.
            </summary>
            <param name="index">The logical index in this builder.</param>
            <param name="count">The number of characters in the gap.</param>
            <param name="chunk">Receives the chunk containing the gap.</param>
            <param name="indexInChunk">The index in <paramref name="chunk"/> that points to the gap.</param>
            <param name="doNotMoveFollowingChars">
            - If <c>true</c>, then room must be made by inserting a chunk before the current chunk.
            - If <c>false</c>, then room can be made by shifting characters ahead of <paramref name="index"/>
              in this block forward by <paramref name="count"/> provided the characters will still fit in
              the current chunk after being shifted.
              - Providing <c>false</c> does not make a difference most of the time, but it can matter when someone
                inserts lots of small strings at a position in the buffer.
            </param>
            <remarks>
            <para>
            Since chunks do not contain references to their successors, it is not always possible for us to make room
            by inserting space after <paramref name="index"/> in case this chunk runs out of space. Thus, we make room
            by inserting space before the specified index, and having logical indices refer to new locations by the end
            of this method.
            </para>
            <para>
            <see cref="M:System.Text.StringBuilder.ReplaceInPlaceAtChunk(System.Text.StringBuilder@,System.Int32@,System.Char*,System.Int32)"/> can be used in conjunction with this method to fill in the newly created gap.
            </para>
            </remarks>
        </member>
        <member name="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Used by <see cref="M:System.Text.StringBuilder.MakeRoom(System.Int32,System.Int32,System.Text.StringBuilder@,System.Int32@,System.Boolean)"/> to allocate another chunk.
            </summary>
            <param name="size">The size of the character buffer for this chunk.</param>
            <param name="maxCapacity">The maximum capacity, to be stored in this chunk.</param>
            <param name="previousBlock">The predecessor of this chunk.</param>
        </member>
        <member name="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32,System.Text.StringBuilder@,System.Int32@)">
            <summary>
            Removes a specified number of characters beginning at a logical index in this builder.
            </summary>
            <param name="startIndex">The logical index in this builder to start removing characters.</param>
            <param name="count">The number of characters to remove.</param>
            <param name="chunk">Receives the new chunk containing the logical index.</param>
            <param name="indexInChunk">
            Receives the new index in <paramref name="chunk"/> that is associated with the logical index.
            </param>
        </member>
        <member name="M:System.Text.ASCIIUtility.AllCharsInUInt32AreAscii(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff all chars in <paramref name="value"/> are ASCII.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.AllCharsInUInt64AreAscii(System.UInt64)">
            <summary>
            Returns <see langword="true"/> iff all chars in <paramref name="value"/> are ASCII.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.FirstCharInUInt32IsAscii(System.UInt32)">
            <summary>
            Given a DWORD which represents two packed chars in machine-endian order,
            <see langword="true"/> iff the first char (in machine-endian order) is ASCII.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.Text.ASCIIUtility.GetIndexOfFirstNonAsciiByte(System.Byte*,System.UInt32)">
            <summary>
            Returns the index in <paramref name="pBuffer"/> where the first non-ASCII byte is found.
            Returns <paramref name="bufferLength"/> if the buffer is empty or all-ASCII.
            </summary>
            <returns>An ASCII byte is defined as 0x00 - 0x7F, inclusive.</returns>
        </member>
        <member name="M:System.Text.ASCIIUtility.GetIndexOfFirstNonAsciiChar(System.Char*,System.UInt32)">
            <summary>
            Returns the index in <paramref name="pBuffer"/> where the first non-ASCII char is found.
            Returns <paramref name="bufferLength"/> if the buffer is empty or all-ASCII.
            </summary>
            <returns>An ASCII char is defined as 0x0000 - 0x007F, inclusive.</returns>
        </member>
        <member name="M:System.Text.ASCIIUtility.NarrowFourUtf16CharsToAsciiAndWriteToBuffer(System.Byte@,System.UInt64)">
            <summary>
            Given a QWORD which represents a buffer of 4 ASCII chars in machine-endian order,
            narrows each WORD to a BYTE, then writes the 4-byte result to the output buffer
            also in machine-endian order.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.NarrowTwoUtf16CharsToAsciiAndWriteToBuffer(System.Byte@,System.UInt32)">
            <summary>
            Given a DWORD which represents a buffer of 2 ASCII chars in machine-endian order,
            narrows each WORD to a BYTE, then writes the 2-byte result to the output buffer also in
            machine-endian order.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.NarrowUtf16ToAscii(System.Char*,System.Byte*,System.UInt32)">
            <summary>
            Copies as many ASCII characters (U+0000..U+007F) as possible from <paramref name="pUtf16Buffer"/>
            to <paramref name="pAsciiBuffer"/>, stopping when the first non-ASCII character is encountered
            or once <paramref name="elementCount"/> elements have been converted. Returns the total number
            of elements that were able to be converted.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.WidenAsciiToUtf16(System.Byte*,System.Char*,System.UInt32)">
            <summary>
            Copies as many ASCII bytes (00..7F) as possible from <paramref name="pAsciiBuffer"/>
            to <paramref name="pUtf16Buffer"/>, stopping when the first non-ASCII byte is encountered
            or once <paramref name="elementCount"/> elements have been converted. Returns the total number
            of elements that were able to be converted.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.WidenFourAsciiBytesToUtf16AndWriteToBuffer(System.Char@,System.UInt32)">
            <summary>
            Given a DWORD which represents a buffer of 4 bytes, widens the buffer into 4 WORDs and
            writes them to the output buffer with machine endianness.
            </summary>
        </member>
        <member name="F:System.Text.ASCIIUtility.UInt32HighBitsOnlyMask">
            <summary>
            A mask which selects only the high bit of each byte of the given <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="F:System.Text.ASCIIUtility.UInt64HighBitsOnlyMask">
            <summary>
            A mask which selects only the high bit of each byte of the given <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.AllBytesInUInt32AreAscii(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff all bytes in <paramref name="value"/> are ASCII.
            </summary>
        </member>
        <member name="M:System.Text.ASCIIUtility.CountNumberOfLeadingAsciiBytesFromUInt32WithSomeNonAsciiData(System.UInt32)">
            <summary>
            Given a DWORD which represents a four-byte buffer read in machine endianness, and which
            the caller has asserted contains a non-ASCII byte *somewhere* in the data, counts the
            number of consecutive ASCII bytes starting from the beginning of the buffer. Returns
            a value 0 - 3, inclusive. (The caller is responsible for ensuring that the buffer doesn't
            contain all-ASCII data.)
            </summary>
        </member>
        <member name="T:System.Text.StringBuilderCache">
            <summary>Provide a cached reusable instance of stringbuilder per thread.</summary>
        </member>
        <member name="M:System.Text.StringBuilderCache.Acquire(System.Int32)">
            <summary>Get a StringBuilder for the specified capacity.</summary>
            <remarks>If a StringBuilder of an appropriate size is cached, it will be returned and the cache emptied.</remarks>
        </member>
        <member name="M:System.Text.StringBuilderCache.Release(System.Text.StringBuilder)">
            <summary>Place the specified builder in the cache if it is not too big.</summary>
        </member>
        <member name="M:System.Text.StringBuilderCache.GetStringAndRelease(System.Text.StringBuilder)">
            <summary>ToString() the stringbuilder, Release it to the cache, and return the resulting string.</summary>
        </member>
        <member name="M:System.Text.DecoderNLS.ConcatInto(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Given a byte buffer <paramref name="dest"/>, concatenates as much of <paramref name="srcLeft"/> followed
            by <paramref name="srcRight"/> into it as will fit, then returns the total number of bytes copied.
            </summary>
        </member>
        <member name="P:System.Text.EncoderNLS.HasLeftoverData">
            <summary>
            States whether a call to <see cref="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Text.EncoderNLS)"/> must first drain data on this <see cref="T:System.Text.EncoderNLS"/> instance.
            </summary>
        </member>
        <member name="M:System.Text.Encoding.TryGetByteCount(System.Text.Rune,System.Int32@)">
            <summary>
            Given a <see cref="T:System.Text.Rune"/>, determines its byte count under the current <see cref="T:System.Text.Encoding"/>.
            Returns <see langword="false"/> if the <see cref="T:System.Text.Rune"/> cannot be represented in the
            current <see cref="T:System.Text.Encoding"/>.
            </summary>
        </member>
        <member name="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32,System.Text.EncoderNLS)">
            <summary>
            Entry point from <see cref="M:System.Text.EncoderNLS.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:System.Text.Encoding.GetByteCountFast(System.Char*,System.Int32,System.Text.EncoderFallback,System.Int32@)">
            <summary>
            Counts the number of <see langword="byte"/>s that would result from transcoding the source
            data, exiting when the source buffer is consumed or when the first unreadable data is encountered.
            The implementation may inspect <paramref name="fallback"/> to short-circuit any counting
            operation, but it should not attempt to call <see cref="M:System.Text.EncoderFallback.CreateFallbackBuffer"/>.
            </summary>
            <returns>
            Via <paramref name="charsConsumed"/>, the number of elements from <paramref name="pChars"/> which
            were consumed; and returns the transcoded byte count up to this point.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the byte count would be greater than <see cref="F:System.Int32.MaxValue"/>.
            (Implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
            <remarks>
            The implementation should not attempt to perform any sort of fallback behavior.
            If custom fallback behavior is necessary, override <see cref="M:System.Text.Encoding.GetByteCountWithFallback(System.Char*,System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Encoding.GetByteCountWithFallback(System.Char*,System.Int32,System.Int32)">
            <summary>
            Counts the number of bytes that would result from transcoding the provided chars,
            with no associated <see cref="T:System.Text.EncoderNLS"/>. The first two arguments are based on the
            original input before invoking this method; and <paramref name="charsConsumedSoFar"/>
            signals where in the provided buffer the fallback loop should begin operating.
            </summary>
            <returns>
            The byte count resulting from transcoding the input data.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the resulting byte count is greater than <see cref="F:System.Int32.MaxValue"/>.
            (Implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetByteCountWithFallback(System.Char*,System.Int32,System.Int32,System.Text.EncoderNLS)">
            <summary>
            Gets the number of <see langword="byte"/>s that would result from transcoding the provided
            input data, with an associated <see cref="T:System.Text.EncoderNLS"/>. The first two arguments are
            based on the original input before invoking this method; and <paramref name="charsConsumedSoFar"/>
            signals where in the provided source buffer the fallback loop should begin operating.
            The behavior of this method is to consume (non-destructively) any leftover data in the
            <see cref="T:System.Text.EncoderNLS"/> instance, then to invoke the <see cref="M:System.Text.Encoding.GetByteCountFast(System.Char*,System.Int32,System.Text.EncoderFallback,System.Int32@)"/> virtual method
            after data has been drained, then to call <see cref="M:System.Text.Encoding.GetByteCountWithFallback(System.ReadOnlySpan{System.Char},System.Int32,System.Text.EncoderNLS)"/>.
            </summary>
            <returns>
            The total number of bytes that would result from transcoding the remaining portion of the source buffer.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the return value would exceed <see cref="F:System.Int32.MaxValue"/>.
            (The implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetByteCountWithFallback(System.ReadOnlySpan{System.Char},System.Int32,System.Text.EncoderNLS)">
            <summary>
            Counts the number of bytes that would result from transcoding the provided chars,
            using the provided <see cref="T:System.Text.EncoderFallbackBuffer"/> if necessary.
            </summary>
            <returns>
            The byte count resulting from transcoding the input data.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the resulting byte count is greater than <see cref="F:System.Int32.MaxValue"/>.
            (Implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Text.EncoderNLS)">
            <summary>
            Entry point from <see cref="M:System.Text.EncoderNLS.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)"/> and <see cref="M:System.Text.EncoderNLS.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)"/>.
            </summary>
        </member>
        <member name="M:System.Text.Encoding.GetBytesFast(System.Char*,System.Int32,System.Byte*,System.Int32,System.Int32@)">
            <summary>
            Transcodes <see langword="char"/>s to <see langword="byte"/>s, exiting when the source or destination
            buffer is consumed or when the first unreadable data is encountered.
            </summary>
            <returns>
            Via <paramref name="charsConsumed"/>, the number of elements from <paramref name="pChars"/> which
            were consumed; and returns the number of elements written to <paramref name="pBytes"/>.
            </returns>
            <remarks>
            The implementation should not attempt to perform any sort of fallback behavior.
            If custom fallback behavior is necessary, override <see cref="M:System.Text.Encoding.GetBytesWithFallback(System.Char*,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Encoding.GetBytesWithFallback(System.Char*,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Transcodes chars to bytes, with no associated <see cref="T:System.Text.EncoderNLS"/>. The first four arguments are
            based on the original input before invoking this method; and <paramref name="charsConsumedSoFar"/>
            and <paramref name="bytesWrittenSoFar"/> signal where in the provided buffers the fallback loop
            should begin operating. The behavior of this method is to call the <see cref="M:System.Text.Encoding.GetBytesWithFallback(System.Char*,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32)"/>
            virtual method as overridden by the specific type, and failing that go down the shared fallback path.
            </summary>
            <returns>
            The total number of bytes written to <paramref name="pOriginalBytes"/>, including <paramref name="bytesWrittenSoFar"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the destination buffer is not large enough to hold the entirety of the transcoded data.
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetBytesWithFallback(System.Char*,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32,System.Text.EncoderNLS)">
            <summary>
            Transcodes chars to bytes, with an associated <see cref="T:System.Text.EncoderNLS"/>. The first four arguments are
            based on the original input before invoking this method; and <paramref name="charsConsumedSoFar"/>
            and <paramref name="bytesWrittenSoFar"/> signal where in the provided buffers the fallback loop
            should begin operating. The behavior of this method is to drain any leftover data in the
            <see cref="T:System.Text.EncoderNLS"/> instance, then to invoke the <see cref="M:System.Text.Encoding.GetBytesFast(System.Char*,System.Int32,System.Byte*,System.Int32,System.Int32@)"/> virtual method
            after data has been drained, then to call <see cref="M:System.Text.Encoding.GetBytesWithFallback(System.ReadOnlySpan{System.Char},System.Int32,System.Span{System.Byte},System.Int32,System.Text.EncoderNLS)"/>.
            </summary>
            <returns>
            The total number of bytes written to <paramref name="pOriginalBytes"/>, including <paramref name="bytesWrittenSoFar"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the destination buffer is too small to make any forward progress at all, or if the destination buffer is
            too small to contain the entirety of the transcoded data and the <see cref="T:System.Text.EncoderNLS"/> instance disallows
            partial transcoding.
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetBytesWithFallback(System.ReadOnlySpan{System.Char},System.Int32,System.Span{System.Byte},System.Int32,System.Text.EncoderNLS)">
            <summary>
            Transcodes chars to bytes, using <see cref="P:System.Text.Encoding.EncoderFallback"/> or <see cref="P:System.Text.Encoder.Fallback"/> if needed.
            </summary>
            <returns>
            The total number of bytes written to <paramref name="bytes"/> (based on <paramref name="originalBytesLength"/>).
            </returns>
            <remarks>
            The derived class should override this method if it might be able to provide a more optimized fallback
            implementation, deferring to the base implementation if needed. This method calls <see cref="M:System.Text.Encoding.ThrowBytesOverflow"/>
            if necessary.
            </remarks>
        </member>
        <member name="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32,System.Text.DecoderNLS)">
            <summary>
            Entry point from <see cref="M:System.Text.DecoderNLS.GetCharCount(System.Byte[],System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:System.Text.Encoding.GetCharCountFast(System.Byte*,System.Int32,System.Text.DecoderFallback,System.Int32@)">
            <summary>
            Counts the number of <see langword="char"/>s that would result from transcoding the source
            data, exiting when the source buffer is consumed or when the first unreadable data is encountered.
            The implementation may inspect <paramref name="fallback"/> to short-circuit any counting
            operation, but it should not attempt to call <see cref="M:System.Text.DecoderFallback.CreateFallbackBuffer"/>.
            </summary>
            <returns>
            Via <paramref name="bytesConsumed"/>, the number of elements from <paramref name="pBytes"/> which
            were consumed; and returns the transcoded char count up to this point.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the char count would be greater than <see cref="F:System.Int32.MaxValue"/>.
            (Implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
            <remarks>
            The implementation should not attempt to perform any sort of fallback behavior.
            If custom fallback behavior is necessary, override <see cref="M:System.Text.Encoding.GetCharCountWithFallback(System.Byte*,System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Encoding.GetCharCountWithFallback(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Counts the number of chars that would result from transcoding the provided bytes,
            with no associated <see cref="T:System.Text.DecoderNLS"/>. The first two arguments are based on the
            original input before invoking this method; and <paramref name="bytesConsumedSoFar"/>
            signals where in the provided buffer the fallback loop should begin operating.
            </summary>
            <returns>
            The char count resulting from transcoding the input data.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the resulting char count is greater than <see cref="F:System.Int32.MaxValue"/>.
            (Implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetCharCountWithFallback(System.Byte*,System.Int32,System.Int32,System.Text.DecoderNLS)">
            <summary>
            Gets the number of <see langword="char"/>s that would result from transcoding the provided
            input data, with an associated <see cref="T:System.Text.DecoderNLS"/>. The first two arguments are
            based on the original input before invoking this method; and <paramref name="bytesConsumedSoFar"/>
            signals where in the provided source buffer the fallback loop should begin operating.
            The behavior of this method is to consume (non-destructively) any leftover data in the
            <see cref="T:System.Text.DecoderNLS"/> instance, then to invoke the <see cref="M:System.Text.Encoding.GetCharCountFast(System.Byte*,System.Int32,System.Text.DecoderFallback,System.Int32@)"/> virtual method
            after data has been drained, then to call <see cref="M:System.Text.Encoding.GetCharCountWithFallback(System.ReadOnlySpan{System.Byte},System.Int32,System.Text.DecoderNLS)"/>.
            </summary>
            <returns>
            The total number of chars that would result from transcoding the remaining portion of the source buffer.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the return value would exceed <see cref="F:System.Int32.MaxValue"/>.
            (The implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetCharCountWithFallback(System.ReadOnlySpan{System.Byte},System.Int32,System.Text.DecoderNLS)">
            <summary>
            Counts the number of chars that would result from transcoding the provided bytes,
            using the provided <see cref="T:System.Text.DecoderFallbackBuffer"/> if necessary.
            </summary>
            <returns>
            The char count resulting from transcoding the input data.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the resulting char count is greater than <see cref="F:System.Int32.MaxValue"/>.
            (Implementation should call <see cref="M:System.Text.Encoding.ThrowConversionOverflow"/>.)
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Text.DecoderNLS)">
            <summary>
            Entry point from <see cref="M:System.Text.DecoderNLS.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)"/> and <see cref="M:System.Text.DecoderNLS.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)"/>.
            </summary>
        </member>
        <member name="M:System.Text.Encoding.GetCharsFast(System.Byte*,System.Int32,System.Char*,System.Int32,System.Int32@)">
            <summary>
            Transcodes <see langword="byte"/>s to <see langword="char"/>s, exiting when the source or destination
            buffer is consumed or when the first unreadable data is encountered.
            </summary>
            <returns>
            Via <paramref name="bytesConsumed"/>, the number of elements from <paramref name="pBytes"/> which
            were consumed; and returns the number of elements written to <paramref name="pChars"/>.
            </returns>
            <remarks>
            The implementation should not attempt to perform any sort of fallback behavior.
            If custom fallback behavior is necessary, override <see cref="M:System.Text.Encoding.GetCharsWithFallback(System.Byte*,System.Int32,System.Char*,System.Int32,System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Encoding.GetCharsWithFallback(System.Byte*,System.Int32,System.Char*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Transcodes bytes to chars, with no associated <see cref="T:System.Text.DecoderNLS"/>. The first four arguments are
            based on the original input before invoking this method; and <paramref name="bytesConsumedSoFar"/>
            and <paramref name="charsWrittenSoFar"/> signal where in the provided buffers the fallback loop
            should begin operating. The behavior of this method is to call the <see cref="M:System.Text.Encoding.GetCharsWithFallback(System.Byte*,System.Int32,System.Char*,System.Int32,System.Int32,System.Int32)"/>
            virtual method as overridden by the specific type, and failing that go down the shared fallback path.
            </summary>
            <returns>
            The total number of chars written to <paramref name="pOriginalChars"/>, including <paramref name="charsWrittenSoFar"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the destination buffer is not large enough to hold the entirety of the transcoded data.
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetCharsWithFallback(System.Byte*,System.Int32,System.Char*,System.Int32,System.Int32,System.Int32,System.Text.DecoderNLS)">
            <summary>
            Transcodes bytes to chars, with an associated <see cref="T:System.Text.DecoderNLS"/>. The first four arguments are
            based on the original input before invoking this method; and <paramref name="bytesConsumedSoFar"/>
            and <paramref name="charsWrittenSoFar"/> signal where in the provided buffers the fallback loop
            should begin operating. The behavior of this method is to drain any leftover data in the
            <see cref="T:System.Text.DecoderNLS"/> instance, then to invoke the <see cref="M:System.Text.Encoding.GetCharsFast(System.Byte*,System.Int32,System.Char*,System.Int32,System.Int32@)"/> virtual method
            after data has been drained, then to call <see cref="M:System.Text.Encoding.GetCharsWithFallback(System.ReadOnlySpan{System.Byte},System.Int32,System.Span{System.Char},System.Int32,System.Text.DecoderNLS)"/>.
            </summary>
            <returns>
            The total number of chars written to <paramref name="pOriginalChars"/>, including <paramref name="charsWrittenSoFar"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            If the destination buffer is too small to make any forward progress at all, or if the destination buffer is
            too small to contain the entirety of the transcoded data and the <see cref="T:System.Text.DecoderNLS"/> instance disallows
            partial transcoding.
            </exception>
        </member>
        <member name="M:System.Text.Encoding.GetCharsWithFallback(System.ReadOnlySpan{System.Byte},System.Int32,System.Span{System.Char},System.Int32,System.Text.DecoderNLS)">
            <summary>
            Transcodes bytes to chars, using <see cref="P:System.Text.Encoding.DecoderFallback"/> or <see cref="P:System.Text.Decoder.Fallback"/> if needed.
            </summary>
            <returns>
            The total number of chars written to <paramref name="chars"/> (based on <paramref name="originalCharsLength"/>).
            </returns>
            <remarks>
            The derived class should override this method if it might be able to provide a more optimized fallback
            implementation, deferring to the base implementation if needed. This method calls <see cref="M:System.Text.Encoding.ThrowCharsOverflow"/>
            if necessary.
            </remarks>
        </member>
        <member name="T:System.Text.Rune">
            <summary>
            Represents a Unicode scalar value ([ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive).
            </summary>
            <remarks>
            This type's constructors and conversion operators validate the input, so consumers can call the APIs
            assuming that the underlying <see cref="T:System.Text.Rune"/> instance is well-formed.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Char)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided UTF-16 code unit.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="ch"/> represents a UTF-16 surrogate code point
            U+D800..U+DFFF, inclusive.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Char,System.Char)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided UTF-16 surrogate pair.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="highSurrogate"/> does not represent a UTF-16 high surrogate code point
            or <paramref name="lowSurrogate"/> does not represent a UTF-16 low surrogate code point.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Int32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided Unicode scalar value.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="value"/> does not represent a value Unicode scalar value.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.UInt32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided Unicode scalar value.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="value"/> does not represent a value Unicode scalar value.
            </exception>
        </member>
        <member name="P:System.Text.Rune.IsAscii">
            <summary>
            Returns true if and only if this scalar value is ASCII ([ U+0000..U+007F ])
            and therefore representable by a single UTF-8 code unit.
            </summary>
        </member>
        <member name="P:System.Text.Rune.IsBmp">
            <summary>
            Returns true if and only if this scalar value is within the BMP ([ U+0000..U+FFFF ])
            and therefore representable by a single UTF-16 code unit.
            </summary>
        </member>
        <member name="P:System.Text.Rune.Plane">
            <summary>
            Returns the Unicode plane (0 to 16, inclusive) which contains this scalar.
            </summary>
        </member>
        <member name="P:System.Text.Rune.ReplacementChar">
            <summary>
            A <see cref="T:System.Text.Rune"/> instance that represents the Unicode replacement character U+FFFD.
            </summary>
        </member>
        <member name="P:System.Text.Rune.Utf16SequenceLength">
            <summary>
            Returns the length in code units (<see cref="T:System.Char"/>) of the
            UTF-16 sequence required to represent this scalar value.
            </summary>
            <remarks>
            The return value will be 1 or 2.
            </remarks>
        </member>
        <member name="P:System.Text.Rune.Utf8SequenceLength">
            <summary>
            Returns the length in code units of the
            UTF-8 sequence required to represent this scalar value.
            </summary>
            <remarks>
            The return value will be 1 through 4, inclusive.
            </remarks>
        </member>
        <member name="P:System.Text.Rune.Value">
            <summary>
            Returns the Unicode scalar value as an integer.
            </summary>
        </member>
        <member name="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the beginning of the provided UTF-16 source buffer.
            </summary>
            <returns>
            <para>
            If the source buffer begins with a valid UTF-16 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.Done"/>,
            and outs via <paramref name="result"/> the decoded <see cref="T:System.Text.Rune"/> and via <paramref name="charsConsumed"/> the
            number of <see langword="char"/>s used in the input buffer to encode the <see cref="T:System.Text.Rune"/>.
            </para>
            <para>
            If the source buffer is empty or contains only a standalone UTF-16 high surrogate character, returns <see cref="F:System.Buffers.OperationStatus.NeedMoreData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="charsConsumed"/> the length of the input buffer.
            </para>
            <para>
            If the source buffer begins with an ill-formed UTF-16 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.InvalidData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="charsConsumed"/> the number of
            <see langword="char"/>s used in the input buffer to encode the ill-formed sequence.
            </para>
            </returns>
            <remarks>
            The general calling convention is to call this method in a loop, slicing the <paramref name="source"/> buffer by
            <paramref name="charsConsumed"/> elements on each iteration of the loop. On each iteration of the loop <paramref name="result"/>
            will contain the real scalar value if successfully decoded, or it will contain <see cref="P:System.Text.Rune.ReplacementChar"/> if
            the data could not be successfully decoded. This pattern provides convenient automatic U+FFFD substitution of
            invalid sequences while iterating through the loop.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the beginning of the provided UTF-8 source buffer.
            </summary>
            <returns>
            <para>
            If the source buffer begins with a valid UTF-8 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.Done"/>,
            and outs via <paramref name="result"/> the decoded <see cref="T:System.Text.Rune"/> and via <paramref name="bytesConsumed"/> the
            number of <see langword="byte"/>s used in the input buffer to encode the <see cref="T:System.Text.Rune"/>.
            </para>
            <para>
            If the source buffer is empty or contains only a standalone UTF-8 high surrogate character, returns <see cref="F:System.Buffers.OperationStatus.NeedMoreData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="bytesConsumed"/> the length of the input buffer.
            </para>
            <para>
            If the source buffer begins with an ill-formed UTF-8 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.InvalidData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="bytesConsumed"/> the number of
            <see langword="char"/>s used in the input buffer to encode the ill-formed sequence.
            </para>
            </returns>
            <remarks>
            The general calling convention is to call this method in a loop, slicing the <paramref name="source"/> buffer by
            <paramref name="bytesConsumed"/> elements on each iteration of the loop. On each iteration of the loop <paramref name="result"/>
            will contain the real scalar value if successfully decoded, or it will contain <see cref="P:System.Text.Rune.ReplacementChar"/> if
            the data could not be successfully decoded. This pattern provides convenient automatic U+FFFD substitution of
            invalid sequences while iterating through the loop.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeLastFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the end of the provided UTF-16 source buffer.
            </summary>
            <remarks>
            This method is very similar to <see cref="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)"/>, but it allows
            the caller to loop backward instead of forward. The typical calling convention is that on each iteration
            of the loop, the caller should slice off the final <paramref name="charsConsumed"/> elements of
            the <paramref name="source"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeLastFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the end of the provided UTF-8 source buffer.
            </summary>
            <remarks>
            This method is very similar to <see cref="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)"/>, but it allows
            the caller to loop backward instead of forward. The typical calling convention is that on each iteration
            of the loop, the caller should slice off the final <paramref name="bytesConsumed"/> elements of
            the <paramref name="source"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.EncodeToUtf16(System.Span{System.Char})">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-16 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-16.</param>
            <returns>The number of <see cref="T:System.Char"/>s written to <paramref name="destination"/>.</returns>
            <exception cref="T:System.ArgumentException">
            If <paramref name="destination"/> is not large enough to hold the output.
            </exception>
        </member>
        <member name="M:System.Text.Rune.EncodeToUtf8(System.Span{System.Byte})">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-8 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-8.</param>
            <returns>The number of <see cref="T:System.Byte"/>s written to <paramref name="destination"/>.</returns>
            <exception cref="T:System.ArgumentException">
            If <paramref name="destination"/> is not large enough to hold the output.
            </exception>
        </member>
        <member name="M:System.Text.Rune.GetRuneAt(System.String,System.Int32)">
            <summary>
            Gets the <see cref="T:System.Text.Rune"/> which begins at index <paramref name="index"/> in
            string <paramref name="input"/>.
            </summary>
            <remarks>
            Throws if <paramref name="input"/> is null, if <paramref name="index"/> is out of range, or
            if <paramref name="index"/> does not reference the start of a valid scalar value within <paramref name="input"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.IsValid(System.Int32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Rune.IsValid(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Rune.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation of this <see cref="T:System.Text.Rune"/> instance.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Char,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Char,System.Char,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided UTF-16 surrogate pair.
            Returns <see langword="false"/> if the input values don't represent a well-formed UTF-16surrogate pair.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Int32,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.UInt32,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryEncodeToUtf16(System.Span{System.Char},System.Int32@)">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-16 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-16.</param>
            <param name="charsWritten">
            The number of <see cref="T:System.Char"/>s written to <paramref name="destination"/>,
            or 0 if the destination buffer is not large enough to contain the output.</param>
            <returns>True if the value was written to the buffer; otherwise, false.</returns>
            <remarks>
            The <see cref="P:System.Text.Rune.Utf16SequenceLength"/> property can be queried ahead of time to determine
            the required size of the <paramref name="destination"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.TryEncodeToUtf8(System.Span{System.Byte},System.Int32@)">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a destination buffer as UTF-8 bytes.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-8.</param>
            <param name="bytesWritten">
            The number of <see cref="T:System.Byte"/>s written to <paramref name="destination"/>,
            or 0 if the destination buffer is not large enough to contain the output.</param>
            <returns>True if the value was written to the buffer; otherwise, false.</returns>
            <remarks>
            The <see cref="P:System.Text.Rune.Utf8SequenceLength"/> property can be queried ahead of time to determine
            the required size of the <paramref name="destination"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.TryGetRuneAt(System.String,System.Int32,System.Text.Rune@)">
            <summary>
            Attempts to get the <see cref="T:System.Text.Rune"/> which begins at index <paramref name="index"/> in
            string <paramref name="input"/>.
            </summary>
            <returns><see langword="true"/> if a scalar value was successfully extracted from the specified index,
            <see langword="false"/> if a value could not be extracted due to invalid data.</returns>
            <remarks>
            Throws only if <paramref name="input"/> is null or <paramref name="index"/> is out of range.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.UnsafeCreate(System.UInt32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> without performing validation on the input.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeDebug.ToHexString(System.UInt32)">
            <summary>
            Formats a code point as the hex string "U+XXXX".
            </summary>
            <remarks>
            The input value doesn't have to be a real code point in the Unicode codespace. It can be any integer.
            </remarks>
        </member>
        <member name="F:System.Text.UnicodeUtility.ReplacementChar">
            <summary>
            The Unicode replacement character U+FFFD.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetPlane(System.UInt32)">
            <summary>
            Returns the Unicode plane (0 through 16, inclusive) which contains this code point.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetScalarFromUtf16SurrogatePair(System.UInt32,System.UInt32)">
            <summary>
            Returns a Unicode scalar value from two code points representing a UTF-16 surrogate pair.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf16SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-16 code units required to represent this value.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf16SurrogatesFromSupplementaryPlaneScalar(System.UInt32,System.Char@,System.Char@)">
            <summary>
            Decomposes an astral Unicode scalar into UTF-16 high and low surrogate code units.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf8SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-8 code units required to represent this value.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsAsciiCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is an ASCII
            character ([ U+0000..U+007F ]).
            </summary>
            <remarks>
            Per http://www.unicode.org/glossary/#ASCII, ASCII is only U+0000..U+007F.
            </remarks>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsBmpCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is in the
            Basic Multilingual Plane (BMP).
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsHighSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 high surrogate code point,
            i.e., is in [ U+D800..U+DBFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsInRangeInclusive(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsLowSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 low surrogate code point,
            i.e., is in [ U+DC00..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 surrogate code point,
            i.e., is in [ U+D800..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsValidCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="codePoint"/> is a valid Unicode code
            point, i.e., is in [ U+0000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsValidUnicodeScalar(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference">
            <summary>
            Get a pinnable reference to the builder.
            Does not ensure there is a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/>
            This overload is pattern matched in the C# 7.3+ compiler so you can omit
            the explicit method call, and write eg "fixed (char* c = builder)"
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference(System.Boolean)">
            <summary>
            Get a pinnable reference to the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="P:System.Text.ValueStringBuilder.RawChars">
            <summary>Returns the underlying storage of the builder.</summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AsSpan(System.Boolean)">
            <summary>
            Returns a span around the contents of the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Grow(System.Int32)">
            <summary>
            Resize the internal buffer either by doubling current buffer size or
            by adding <paramref name="additionalCapacityBeyondPos"/> to
            <see cref="F:System.Text.ValueStringBuilder._pos"/> whichever is greater.
            </summary>
            <param name="additionalCapacityBeyondPos">
            Number of chars requested beyond current position.
            </param>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.AllCharsInUInt32AreAscii(System.UInt32)">
            <summary>
            Returns true iff the UInt32 represents two ASCII UTF-16 characters in machine endianness.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.AllCharsInUInt64AreAscii(System.UInt64)">
            <summary>
            Returns true iff the UInt64 represents four ASCII UTF-16 characters in machine endianness.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.ConvertAllAsciiCharsInUInt32ToLowercase(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns the invariant
            lowercase representation of those characters. Requires the input value to contain
            two ASCII UTF-16 characters in machine endianness.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.ConvertAllAsciiCharsInUInt32ToUppercase(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns the invariant
            uppercase representation of those characters. Requires the input value to contain
            two ASCII UTF-16 characters in machine endianness.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32ContainsAnyLowercaseAsciiChar(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns true iff
            the input contains one or more lowercase ASCII characters.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32ContainsAnyUppercaseAsciiChar(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns true iff
            the input contains one or more uppercase ASCII characters.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32OrdinalIgnoreCaseAscii(System.UInt32,System.UInt32)">
            <summary>
            Given two UInt32s that represent two ASCII UTF-16 characters each, returns true iff
            the two inputs are equal using an ordinal case-insensitive comparison.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt64OrdinalIgnoreCaseAscii(System.UInt64,System.UInt64)">
            <summary>
            Given two UInt64s that represent four ASCII UTF-16 characters each, returns true iff
            the two inputs are equal using an ordinal case-insensitive comparison.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.GetPointerToFirstInvalidChar(System.Char*,System.Int32,System.Int64@,System.Int32@)">
            <summary>
            Given an input buffer <paramref name="pInputBuffer"/> of char length <paramref name="inputLength"/>,
            returns a pointer to where the first invalid data appears in <paramref name="pInputBuffer"/>.
            </summary>
            <remarks>
            Returns a pointer to the end of <paramref name="pInputBuffer"/> if the buffer is well-formed.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf8.FromUtf16(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean,System.Boolean)">
            <summary>
            Transcodes the UTF-16 <paramref name="source"/> buffer to <paramref name="destination"/> as UTF-8.
            </summary>
            <remarks>
            If <paramref name="replaceInvalidSequences"/> is <see langword="true"/>, invalid UTF-16 sequences
            in <paramref name="source"/> will be replaced with U+FFFD in <paramref name="destination"/>, and
            this method will not return <see cref="F:System.Buffers.OperationStatus.InvalidData"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf8.ToUtf16(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Int32@,System.Int32@,System.Boolean,System.Boolean)">
            <summary>
            Transcodes the UTF-8 <paramref name="source"/> buffer to <paramref name="destination"/> as UTF-16.
            </summary>
            <remarks>
            If <paramref name="replaceInvalidSequences"/> is <see langword="true"/>, invalid UTF-8 sequences
            in <paramref name="source"/> will be replaced with U+FFFD in <paramref name="destination"/>, and
            this method will not return <see cref="F:System.Buffers.OperationStatus.InvalidData"/>.
            </remarks>
        </member>
        <member name="F:System.Text.Unicode.Utf8Utility.MaxBytesPerScalar">
            <summary>
            The maximum number of bytes that can result from UTF-8 transcoding
            any Unicode scalar value.
            </summary>
        </member>
        <member name="P:System.Text.Unicode.Utf8Utility.ReplacementCharSequence">
            <summary>
            The UTF-8 representation of <see cref="F:System.Text.UnicodeUtility.ReplacementChar"/>.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.GetIndexOfFirstInvalidUtf8Sequence(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Returns the byte index in <paramref name="utf8Data"/> where the first invalid UTF-8 sequence begins,
            or -1 if the buffer contains no invalid sequences. Also outs the <paramref name="isAscii"/> parameter
            stating whether all data observed (up to the first invalid sequence or the end of the buffer, whichever
            comes first) is ASCII.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ExtractCharFromFirstThreeByteSequence(System.UInt32)">
            <summary>
            Given a machine-endian DWORD which four bytes of UTF-8 data, interprets the
            first three bytes as a three-byte UTF-8 subsequence and returns the UTF-16 representation.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ExtractCharFromFirstTwoByteSequence(System.UInt32)">
            <summary>
            Given a machine-endian DWORD which four bytes of UTF-8 data, interprets the
            first two bytes as a two-byte UTF-8 subsequence and returns the UTF-16 representation.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ExtractCharsFromFourByteSequence(System.UInt32)">
            <summary>
            Given a machine-endian DWORD which four bytes of UTF-8 data, interprets the input as a
            four-byte UTF-8 sequence and returns the machine-endian DWORD of the UTF-16 representation.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ExtractFourUtf8BytesFromSurrogatePair(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents a valid packed UTF-16 surrogate pair, all in machine-endian order,
            returns the packed 4-byte UTF-8 representation of this scalar value, also in machine-endian order.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ExtractTwoCharsPackedFromTwoAdjacentTwoByteSequences(System.UInt32)">
            <summary>
            Given a machine-endian DWORD which represents two adjacent UTF-8 two-byte sequences,
            returns the machine-endian DWORD representation of that same data as two adjacent
            UTF-16 byte sequences.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ExtractTwoUtf8TwoByteSequencesFromTwoPackedUtf16Chars(System.UInt32)">
            <summary>
            Given a machine-endian DWORD which represents two adjacent UTF-16 sequences,
            returns the machine-endian DWORD representation of that same data as two
            adjacent UTF-8 two-byte sequences.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ExtractUtf8TwoByteSequenceFromFirstUtf16Char(System.UInt32)">
            <summary>
            Given a machine-endian DWORD which represents two adjacent UTF-16 sequences,
            returns the machine-endian DWORD representation of the first UTF-16 char
            as a UTF-8 two-byte sequence packed into a WORD and zero-extended to DWORD.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsFirstCharAscii(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the first UTF-16 character is ASCII.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsFirstCharAtLeastThreeUtf8Bytes(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the first UTF-16 character requires *at least* 3 bytes to encode in UTF-8.
            This also returns true if the first UTF-16 character is a surrogate character (well-formedness is not validated).
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsFirstCharSurrogate(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the first UTF-16 character is a surrogate character (either high or low).
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsFirstCharTwoUtf8Bytes(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the first UTF-16 character would be encoded as exactly 2 bytes in UTF-8.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsLowByteUtf8ContinuationByte(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff the low byte of <paramref name="value"/>
            is a UTF-8 continuation byte.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsSecondCharAscii(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the second UTF-16 character is ASCII.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsSecondCharAtLeastThreeUtf8Bytes(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the second UTF-16 character requires *at least* 3 bytes to encode in UTF-8.
            This also returns true if the second UTF-16 character is a surrogate character (well-formedness is not validated).
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsSecondCharSurrogate(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the second UTF-16 character is a surrogate character (either high or low).
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsSecondCharTwoUtf8Bytes(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the second UTF-16 character would be encoded as exactly 2 bytes in UTF-8.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsUtf8ContinuationByte(System.Byte@)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-8 continuation byte;
            i.e., has binary representation 10xxxxxx, where x is any bit.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.IsWellFormedUtf16SurrogatePair(System.UInt32)">
            <summary>
            Given a 32-bit integer that represents two packed UTF-16 characters, all in machine-endian order,
            returns true iff the two characters represent a well-formed UTF-16 surrogate pair.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.ToLittleEndian(System.UInt32)">
            <summary>
            Converts a DWORD from machine-endian to little-endian.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32BeginsWithOverlongUtf8TwoByteSequence(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first two bytes of the buffer are
            an overlong representation of a sequence that should be represented as one byte.
            This method *does not* validate that the sequence matches the appropriate
            2-byte sequence mask (see <see cref="M:System.Text.Unicode.Utf8Utility.UInt32BeginsWithUtf8TwoByteMask(System.UInt32)"/>).
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32BeginsWithUtf8FourByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first four bytes of the buffer match
            the UTF-8 4-byte sequence mask [ 11110www 10zzzzzz 10yyyyyy 10xxxxxx ]. This
            method *does not* validate that the sequence is well-formed; the caller must
            still perform overlong form or out-of-range checking.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32BeginsWithUtf8ThreeByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first three bytes of the buffer match
            the UTF-8 3-byte sequence mask [ 1110zzzz 10yyyyyy 10xxxxxx ]. This method *does not*
            validate that the sequence is well-formed; the caller must still perform
            overlong form or surrogate checking.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32BeginsWithUtf8TwoByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first two bytes of the buffer match
            the UTF-8 2-byte sequence mask [ 110yyyyy 10xxxxxx ]. This method *does not*
            validate that the sequence is well-formed; the caller must still perform
            overlong form checking.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32EndsWithOverlongUtf8TwoByteSequence(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first two bytes of the buffer are
            an overlong representation of a sequence that should be represented as one byte.
            This method *does not* validate that the sequence matches the appropriate
            2-byte sequence mask (see <see cref="M:System.Text.Unicode.Utf8Utility.UInt32BeginsWithUtf8TwoByteMask(System.UInt32)"/>).
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32EndsWithUtf8TwoByteMask(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the last two bytes of the buffer match
            the UTF-8 2-byte sequence mask [ 110yyyyy 10xxxxxx ]. This method *does not*
            validate that the sequence is well-formed; the caller must still perform
            overlong form checking.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32BeginsWithValidUtf8TwoByteSequenceLittleEndian(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD on a little-endian machine,
            returns <see langword="true"/> iff the first two bytes of the buffer are a well-formed
            UTF-8 two-byte sequence. This wraps the mask check and the overlong check into a
            single operation. Returns <see langword="false"/> if running on a big-endian machine.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32EndsWithValidUtf8TwoByteSequenceLittleEndian(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD on a little-endian machine,
            returns <see langword="true"/> iff the last two bytes of the buffer are a well-formed
            UTF-8 two-byte sequence. This wraps the mask check and the overlong check into a
            single operation. Returns <see langword="false"/> if running on a big-endian machine.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32FirstByteIsAscii(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the first byte of the buffer is ASCII.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32FourthByteIsAscii(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the fourth byte of the buffer is ASCII.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32SecondByteIsAscii(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the second byte of the buffer is ASCII.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.UInt32ThirdByteIsAscii(System.UInt32)">
            <summary>
            Given a UTF-8 buffer which has been read into a DWORD in machine endianness,
            returns <see langword="true"/> iff the third byte of the buffer is ASCII.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.Widen4AsciiBytesToCharsAndWrite(System.Char@,System.UInt32)">
            <summary>
            Given a DWORD which represents a buffer of 4 ASCII bytes, widen each byte to a 16-bit WORD
            and writes the resulting QWORD into the destination with machine endianness.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.WriteTwoUtf16CharsAsTwoUtf8ThreeByteSequences(System.Byte@,System.UInt32)">
            <summary>
            Given a DWORD which represents a buffer of 2 packed UTF-16 values in machine endianess,
            converts those scalar values to their 3-byte UTF-8 representation and writes the
            resulting 6 bytes to the destination buffer.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.WriteFirstUtf16CharAsUtf8ThreeByteSequence(System.Byte@,System.UInt32)">
            <summary>
            Given a DWORD which represents a buffer of 2 packed UTF-16 values in machine endianess,
            converts the first UTF-16 value to its 3-byte UTF-8 representation and writes the
            resulting 3 bytes to the destination buffer.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf8Utility.GetPointerToFirstInvalidByte(System.Byte*,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Given an input buffer <paramref name="pInputBuffer"/> of byte length <paramref name="inputLength"/>,
            returns a pointer to where the first invalid data appears in <paramref name="pInputBuffer"/>.
            </summary>
            <remarks>
            Returns a pointer to the end of <paramref name="pInputBuffer"/> if the buffer is well-formed.
            </remarks>
        </member>
        <member name="T:System.Threading.ThreadPoolBoundHandle">
            <summary>
                Represents an I/O handle that is bound to the system thread pool and enables low-level
                components to receive notifications for asynchronous I/O operations.
            </summary>
        </member>
        <member name="P:System.Threading.ThreadPoolBoundHandle.Handle">
            <summary>
                Gets the bound operating system handle.
            </summary>
            <value>
                A <see cref="T:System.Runtime.InteropServices.SafeHandle"/> object that holds the bound operating system handle.
            </value>
        </member>
        <member name="M:System.Threading.ThreadPoolBoundHandle.BindHandle(System.Runtime.InteropServices.SafeHandle)">
            <summary>
                Returns a <see cref="T:System.Threading.ThreadPoolBoundHandle"/> for the specific handle, 
                which is bound to the system thread pool.
            </summary>
            <param name="handle">
                A <see cref="T:System.Runtime.InteropServices.SafeHandle"/> object that holds the operating system handle. The 
                handle must have been opened for overlapped I/O on the unmanaged side.
            </param>
            <returns>
                <see cref="T:System.Threading.ThreadPoolBoundHandle"/> for <paramref name="handle"/>, which 
                is bound to the system thread pool.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="handle"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="handle"/> has been disposed.
                <para>
                    -or-
                </para>
                <paramref name="handle"/> does not refer to a valid I/O handle.
                <para>
                    -or-
                </para>
                <paramref name="handle"/> refers to a handle that has not been opened 
                for overlapped I/O.
                <para>
                    -or-
                </para>
                <paramref name="handle"/> refers to a handle that has already been bound.
            </exception>
            <remarks>
                This method should be called once per handle.
                <para>
                    -or-
                </para>
                <see cref="T:System.Threading.ThreadPoolBoundHandle"/> does not take ownership of <paramref name="handle"/>, 
                it remains the responsibility of the caller to call <see cref="M:System.Runtime.InteropServices.SafeHandle.Dispose"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.IOCompletionCallback,System.Object,System.Object)">
            <summary>
                Returns an unmanaged pointer to a <see cref="T:System.Threading.NativeOverlapped"/> structure, specifying 
                a delegate that is invoked when the asynchronous I/O operation is complete, a user-provided 
                object providing context, and managed objects that serve as buffers.
            </summary>
            <param name="callback">
                An <see cref="T:System.Threading.IOCompletionCallback"/> delegate that represents the callback method 
                invoked when the asynchronous I/O operation completes.
            </param>
            <param name="state">
                A user-provided object that distinguishes this <see cref="T:System.Threading.NativeOverlapped"/> from other 
                <see cref="T:System.Threading.NativeOverlapped"/> instances. Can be <see langword="null"/>.
            </param>
            <param name="pinData">
                An object or array of objects representing the input or output buffer for the operation. Each 
                object represents a buffer, for example an array of bytes.  Can be <see langword="null"/>.
            </param>
            <returns>
                An unmanaged pointer to a <see cref="T:System.Threading.NativeOverlapped"/> structure.
            </returns>
            <remarks>
                <para>
                    The unmanaged pointer returned by this method can be passed to the operating system in 
                    overlapped I/O operations. The <see cref="T:System.Threading.NativeOverlapped"/> structure is fixed in 
                    physical memory until <see cref="M:System.Threading.ThreadPoolBoundHandle.FreeNativeOverlapped(System.Threading.NativeOverlapped*)"/> is called.
                </para>
                <para>
                    The buffer or buffers specified in <paramref name="pinData"/> must be the same as those passed 
                    to the unmanaged operating system function that performs the asynchronous I/O.
                </para>
                <note>
                    The buffers specified in <paramref name="pinData"/> are pinned for the duration of 
                    the I/O operation.
                </note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="callback"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
                This method was called after the <see cref="T:System.Threading.ThreadPoolBoundHandle"/> was disposed.
            </exception>
        </member>
        <member name="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.PreAllocatedOverlapped)">
            <summary>
                Returns an unmanaged pointer to a <see cref="T:System.Threading.NativeOverlapped"/> structure, using the callback,
                state, and buffers associated with the specified <see cref="T:System.Threading.PreAllocatedOverlapped"/> object.
            </summary>
            <param name="preAllocated">
                A <see cref="T:System.Threading.PreAllocatedOverlapped"/> object from which to create the NativeOverlapped pointer.
            </param>
            <returns>
                An unmanaged pointer to a <see cref="T:System.Threading.NativeOverlapped"/> structure.
            </returns>
            <remarks>
                <para>
                    The unmanaged pointer returned by this method can be passed to the operating system in 
                    overlapped I/O operations. The <see cref="T:System.Threading.NativeOverlapped"/> structure is fixed in 
                    physical memory until <see cref="M:System.Threading.ThreadPoolBoundHandle.FreeNativeOverlapped(System.Threading.NativeOverlapped*)"/> is called.
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="preAllocated"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="preAllocated"/> is currently in use for another I/O operation.  
            </exception>
            <exception cref="T:System.ObjectDisposedException">
                This method was called after the <see cref="T:System.Threading.ThreadPoolBoundHandle"/> was disposed, or 
                this method was called after <paramref name="preAllocated"/> was disposed.
            </exception>
            <seealso cref="T:System.Threading.PreAllocatedOverlapped"/>
        </member>
        <member name="M:System.Threading.ThreadPoolBoundHandle.FreeNativeOverlapped(System.Threading.NativeOverlapped*)">
            <summary>
                Frees the unmanaged memory associated with a <see cref="T:System.Threading.NativeOverlapped"/> structure 
                allocated by the <see cref="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.IOCompletionCallback,System.Object,System.Object)"/> method.
            </summary>
            <param name="overlapped">
                An unmanaged pointer to the <see cref="T:System.Threading.NativeOverlapped"/> structure to be freed.
            </param>
            <remarks>
                <note type="caution">
                    You must call the <see cref="M:System.Threading.ThreadPoolBoundHandle.FreeNativeOverlapped(System.Threading.NativeOverlapped*)"/> method exactly once 
                    on every <see cref="T:System.Threading.NativeOverlapped"/> unmanaged pointer allocated using the 
                    <see cref="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.IOCompletionCallback,System.Object,System.Object)"/> method. 
                    If you do not call the <see cref="M:System.Threading.ThreadPoolBoundHandle.FreeNativeOverlapped(System.Threading.NativeOverlapped*)"/> method, you will 
                    leak memory. If you call the <see cref="M:System.Threading.ThreadPoolBoundHandle.FreeNativeOverlapped(System.Threading.NativeOverlapped*)"/> method more 
                    than once on the same <see cref="T:System.Threading.NativeOverlapped"/> unmanaged pointer, memory will be corrupted.
                </note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="overlapped"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
                This method was called after the <see cref="T:System.Threading.ThreadPoolBoundHandle"/> was disposed.
            </exception>
        </member>
        <member name="M:System.Threading.ThreadPoolBoundHandle.GetNativeOverlappedState(System.Threading.NativeOverlapped*)">
            <summary>
                Returns the user-provided object specified when the <see cref="T:System.Threading.NativeOverlapped"/> instance was
                allocated using the <see cref="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.IOCompletionCallback,System.Object,System.Object)"/>.
            </summary>
            <param name="overlapped">
                An unmanaged pointer to the <see cref="T:System.Threading.NativeOverlapped"/> structure from which to return the 
                associated user-provided object.
            </param>
            <returns>
                A user-provided object that distinguishes this <see cref="T:System.Threading.NativeOverlapped"/> 
                from other <see cref="T:System.Threading.NativeOverlapped"/> instances, otherwise, <see langword="null"/> if one was 
                not specified when the instance was allocated using <see cref="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.IOCompletionCallback,System.Object,System.Object)"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="overlapped"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="T:System.Threading.ThreadPoolBoundHandleOverlapped">
            <summary>
            Overlapped subclass adding data needed by ThreadPoolBoundHandle.
            </summary>
        </member>
        <member name="T:System.Threading.PreAllocatedOverlapped">
            <summary>
            Represents pre-allocated state for native overlapped I/O operations.
            </summary>
            <seealso cref="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.PreAllocatedOverlapped)"/>
        </member>
        <member name="M:System.Threading.PreAllocatedOverlapped.#ctor(System.Threading.IOCompletionCallback,System.Object,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:System.Threading.PreAllocatedOverlapped"/> class, specifying 
                a delegate that is invoked when each asynchronous I/O operation is complete, a user-provided 
                object providing context, and managed objects that serve as buffers.
            </summary>
            <param name="callback">
                An <see cref="T:System.Threading.IOCompletionCallback"/> delegate that represents the callback method 
                invoked when each asynchronous I/O operation completes.
            </param>
            <param name="state">
                A user-provided object that distinguishes <see cref="T:System.Threading.NativeOverlapped"/> instance produced from this
                object from other <see cref="T:System.Threading.NativeOverlapped"/> instances. Can be <see langword="null"/>.
            </param>
            <param name="pinData">
                An object or array of objects representing the input or output buffer for the operations. Each 
                object represents a buffer, for example an array of bytes.  Can be <see langword="null"/>.
            </param>
            <remarks>
                The new <see cref="T:System.Threading.PreAllocatedOverlapped"/> instance can be passed to 
                <see cref="M:System.Threading.ThreadPoolBoundHandle.AllocateNativeOverlapped(System.Threading.PreAllocatedOverlapped)"/>, to produce
                a <see cref="T:System.Threading.NativeOverlapped"/> instance that can be passed to the operating system in overlapped
                I/O operations.  A single <see cref="T:System.Threading.PreAllocatedOverlapped"/> instance can only be used for 
                a single native I/O operation at a time.  However, the state stored in the <see cref="T:System.Threading.PreAllocatedOverlapped"/>
                instance can be reused for subsequent native operations.
                <note>
                    The buffers specified in <paramref name="pinData"/> are pinned until <see cref="M:System.Threading.PreAllocatedOverlapped.Dispose"/> is called.
                </note>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="callback"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
                This method was called after the <see cref="T:System.Threading.ThreadPoolBoundHandle"/> was disposed.
            </exception>
        </member>
        <member name="M:System.Threading.PreAllocatedOverlapped.Dispose">
            <summary>
            Frees the resources associated with this <see cref="T:System.Threading.PreAllocatedOverlapped"/> instance. 
            </summary>
        </member>
        <member name="T:System.Threading.Interlocked">
            <summary>
            After much discussion, we decided the Interlocked class doesn't need 
            any HPA's for synchronization or external threading.  They hurt C#'s 
            codegen for the yield keyword, and arguably they didn't protect much.  
            Instead, they penalized people (and compilers) for writing threadsafe 
            code.
            </summary>
        </member>
        <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
            <summary>
            Implemented: int, long
            </summary>
        </member>
        <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
            <summary>
            Implemented: int, long
            </summary>
        </member>
        <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
            <summary>
            Implemented: int, long, float, double, Object, IntPtr
            </summary>
        </member>
        <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
            <summary>
            Implemented: int, long, float, double, Object, IntPtr
            </summary>
        </member>
        <member name="M:System.Threading.Interlocked.ExchangeAdd(System.Int32@,System.Int32)">
            <summary>
            Implemented: int, long
            </summary>
        </member>
        <member name="P:System.Threading.Monitor.LockContentionCount">
            <summary>
            Gets the number of times there was contention upon trying to take a <see cref="T:System.Threading.Monitor"/>'s lock so far.
            </summary>
        </member>
        <member name="T:System.Threading.StackCrawlMark">
            <summary>
            declaring a local var of this enum type and passing it by ref into a function that needs to do a
            stack crawl will both prevent inlining of the callee and pass an ESP point to stack crawl to
            Declaring these in EH clauses is illegal; they must declared in the main method body
            </summary>
        </member>
        <member name="M:System.Threading.SynchronizationContext.OperationStarted">
            <summary>
                Optional override for subclasses, for responding to notification that operation is starting.
            </summary>
        </member>
        <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
            <summary>
                Optional override for subclasses, for responding to notification that operation has completed.
            </summary>
        </member>
        <member name="M:System.Threading.Thread.GetNativeHandle">
            <summary>Returns handle for interop with EE. The handle is guaranteed to be non-null.</summary>
        </member>
        <member name="M:System.Threading.Thread.Start(System.Object)">
            <summary>
            Spawns off a new thread which will begin executing at the ThreadStart
            method on the IThreadable interface passed in the constructor. Once the
            thread is dead, it cannot be restarted with another call to Start.
            </summary>
        </member>
        <member name="M:System.Threading.Thread.SleepInternal(System.Int32)">
            <summary>
            Suspends the current thread for timeout milliseconds. If timeout == 0,
            forces the thread to give up the remainder of its timeslice.  If timeout
            == Timeout.Infinite, no timeout will occur.
            </summary>
        </member>
        <member name="M:System.Threading.Thread.SpinWaitInternal(System.Int32)">
            <summary>
            Wait for a length of time proportional to 'iterations'.  Each iteration is should
            only take a few machine instructions.  Calling this API is preferable to coding
            a explicit busy loop because the hardware can be informed that it is busy waiting.
            </summary>
        </member>
        <member name="M:System.Threading.Thread.SetStart(System.Delegate,System.Int32)">
            <summary>Sets the IThreadable interface for the thread. Assumes that start != null.</summary>
        </member>
        <member name="M:System.Threading.Thread.Finalize">
            <summary>Clean up the thread when it goes away.</summary>
        </member>
        <member name="P:System.Threading.Thread.IsAlive">
            <summary>Returns true if the thread has been started and is not dead.</summary>
        </member>
        <member name="P:System.Threading.Thread.IsBackground">
            <summary>
            Return whether or not this thread is a background thread.  Background
            threads do not affect when the Execution Engine shuts down.
            </summary>
        </member>
        <member name="P:System.Threading.Thread.IsThreadPoolThread">
            <summary>Returns true if the thread is a threadpool thread.</summary>
        </member>
        <member name="P:System.Threading.Thread.Priority">
            <summary>Returns the priority of the thread.</summary>
        </member>
        <member name="P:System.Threading.Thread.CurrentOSThreadId">
            <summary>Returns the operating system identifier for the current thread.</summary>
        </member>
        <member name="P:System.Threading.Thread.ThreadState">
            <summary>
            Return the thread state as a consistent set of bits.  This is more
            general then IsAlive or IsBackground.
            </summary>
        </member>
        <member name="M:System.Threading.Thread.TrySetApartmentStateUnchecked(System.Threading.ApartmentState)">
            <summary>
            An unstarted thread can be marked to indicate that it will host a
            single-threaded or multi-threaded apartment.
            </summary>
        </member>
        <member name="M:System.Threading.Thread.Interrupt">
            <summary>
            Interrupts a thread that is inside a Wait(), Sleep() or Join().  If that
            thread is not currently blocked in that manner, it will be interrupted
            when it next begins to block.
            </summary>
        </member>
        <member name="M:System.Threading.Thread.Join(System.Int32)">
            <summary>
            Waits for the thread to die or for timeout milliseconds to elapse.
            </summary>
            <returns>
            Returns true if the thread died, or false if the wait timed out. If
            -1 is given as the parameter, no timeout will occur.
            </returns>
            <exception cref="T:System.ArgumentException">if timeout &lt; -1 (Timeout.Infinite)</exception>
            <exception cref="T:System.Threading.ThreadInterruptedException">if the thread is interrupted while waiting</exception>
            <exception cref="T:System.Threading.ThreadStateException">if the thread has not been started yet</exception>
        </member>
        <member name="P:System.Threading.Thread.OptimalMaxSpinWaitsPerSpinIteration">
            <summary>
            Max value to be passed into <see cref="M:System.Threading.Thread.SpinWait(System.Int32)"/> for optimal delaying. This value is normalized to be
            appropriate for the processor.
            </summary>
        </member>
        <member name="T:System.Threading.Thread.LocalDataStore">
            <summary>
            Manages functionality required to support members of <see cref="T:System.Threading.Thread"/> dealing with thread-local data
            </summary>
        </member>
        <member name="P:System.Threading.ThreadPool.ThreadCount">
            <summary>
            Gets the number of thread pool threads that currently exist.
            </summary>
            <remarks>
            For a thread pool implementation that may have different types of threads, the count includes all types.
            </remarks>
        </member>
        <member name="P:System.Threading.ThreadPool.CompletedWorkItemCount">
            <summary>
            Gets the number of work items that have been processed so far.
            </summary>
            <remarks>
            For a thread pool implementation that may have different types of work items, the count includes all types.
            </remarks>
        </member>
        <member name="P:System.Threading.ThreadPool.PendingWorkItemCount">
            <summary>
            Gets the number of work items that are currently queued to be processed.
            </summary>
            <remarks>
            For a thread pool implementation that may have different types of work items, the count includes all types that can
            be tracked, which may only be the user work items including tasks. Some implementations may also include queued
            timer and wait callbacks in the count. On Windows, the count is unlikely to include the number of pending IO
            completions, as they get posted directly to an IO completion port.
            </remarks>
        </member>
        <member name="M:System.Threading.WaitHandle.ObtainSafeWaitHandles(System.ReadOnlySpan{System.Threading.WaitHandle},System.Span{Microsoft.Win32.SafeHandles.SafeWaitHandle},System.Span{System.IntPtr})">
            <summary>
            Obtains all of the corresponding safe wait handles and adds a ref to each. Since the <see cref="P:System.Threading.WaitHandle.SafeWaitHandle"/>
            property is publically modifiable, this makes sure that we add and release refs one the same set of safe wait
            handles to keep them alive during a multi-wait operation.
            </summary>
        </member>
        <member name="T:System.Threading.CancellationToken">
            <summary>
            Propagates notification that operations should be canceled.
            </summary>
            <remarks>
            <para>
            A <see cref="T:System.Threading.CancellationToken"/> may be created directly in an unchangeable canceled or non-canceled state
            using the CancellationToken's constructors. However, to have a CancellationToken that can change 
            from a non-canceled to a canceled state, 
            <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> must be used.
            CancellationTokenSource exposes the associated CancellationToken that may be canceled by the source through its 
            <see cref="P:System.Threading.CancellationTokenSource.Token">Token</see> property. 
            </para>
            <para>
            Once canceled, a token may not transition to a non-canceled state, and a token whose 
            <see cref="P:System.Threading.CancellationToken.CanBeCanceled"/> is false will never change to one that can be canceled.
            </para>
            <para>
            All members of this struct are thread-safe and may be used concurrently from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="P:System.Threading.CancellationToken.None">
            <summary>
            Returns an empty CancellationToken value.
            </summary>
            <remarks>
            The <see cref="T:System.Threading.CancellationToken"/> value returned by this property will be non-cancelable by default.
            </remarks>
        </member>
        <member name="P:System.Threading.CancellationToken.IsCancellationRequested">
            <summary>
            Gets whether cancellation has been requested for this token.
            </summary>
            <value>Whether cancellation has been requested for this token.</value>
            <remarks>
            <para>
            This property indicates whether cancellation has been requested for this token, 
            either through the token initially being constructed in a canceled state, or through
            calling <see cref="M:System.Threading.CancellationTokenSource.Cancel">Cancel</see> 
            on the token's associated <see cref="T:System.Threading.CancellationTokenSource"/>.
            </para>
            <para>
            If this property is true, it only guarantees that cancellation has been requested.  
            It does not guarantee that every registered handler
            has finished executing, nor that cancellation requests have finished propagating
            to all registered handlers.  Additional synchronization may be required,
            particularly in situations where related objects are being canceled concurrently.
            </para>
            </remarks>
        </member>
        <member name="P:System.Threading.CancellationToken.CanBeCanceled">
            <summary>
            Gets whether this token is capable of being in the canceled state.
            </summary>
            <remarks>
            If CanBeCanceled returns false, it is guaranteed that the token will never transition
            into a canceled state, meaning that <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> will never
            return true.
            </remarks>
        </member>
        <member name="P:System.Threading.CancellationToken.WaitHandle">
            <summary>
            Gets a <see cref="T:System.Threading.WaitHandle"/> that is signaled when the token is canceled.</summary>
            <remarks>
            Accessing this property causes a <see cref="T:System.Threading.WaitHandle">WaitHandle</see>
            to be instantiated.  It is preferable to only use this property when necessary, and to then
            dispose the associated <see cref="T:System.Threading.CancellationTokenSource"/> instance at the earliest opportunity (disposing
            the source will dispose of this allocated handle).  The handle should not be closed or disposed directly.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The associated <see
            cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.#ctor(System.Threading.CancellationTokenSource)">
            <summary>
            Internal constructor only a CancellationTokenSource should create a CancellationToken
            </summary>
        </member>
        <member name="M:System.Threading.CancellationToken.#ctor(System.Boolean)">
            <summary>
            Initializes the <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
            <param name="canceled">
            The canceled state for the token.
            </param>
            <remarks>
            Tokens created with this constructor will remain in the canceled state specified
            by the <paramref name="canceled"/> parameter.  If <paramref name="canceled"/> is false,
            both <see cref="P:System.Threading.CancellationToken.CanBeCanceled"/> and <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> will be false.
            If <paramref name="canceled"/> is true,
            both <see cref="P:System.Threading.CancellationToken.CanBeCanceled"/> and <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> will be true. 
            </remarks>
        </member>
        <member name="M:System.Threading.CancellationToken.Register(System.Action)">
            <summary>
            Registers a delegate that will be called when this <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
            <remarks>
            <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propagated out of this method call.
            </para>
            <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, will be captured
            along with the delegate and will be used when executing it.
            </para>
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can 
            be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)">
            <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
            <remarks>
            <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propagated out of this method call.
            </para>
            <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, will be captured
            along with the delegate and will be used when executing it.
            </para>
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="useSynchronizationContext">A Boolean value that indicates whether to capture
            the current <see cref="T:System.Threading.SynchronizationContext">SynchronizationContext</see> and use it
            when invoking the <paramref name="callback"/>.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can 
            be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)">
            <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
            <remarks>
            <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propagated out of this method call.
            </para>
            <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, will be captured
            along with the delegate and will be used when executing it.
            </para>
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="state">The state to pass to the <paramref name="callback"/> when the delegate is invoked.  This may be null.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can 
            be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
            <remarks>
            <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propagated out of this method call.
            </para>
            <para>
            The current <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see>, if one exists, 
            will be captured along with the delegate and will be used when executing it.
            </para>
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="state">The state to pass to the <paramref name="callback"/> when the delegate is invoked.  This may be null.</param>
            <param name="useSynchronizationContext">A Boolean value that indicates whether to capture
            the current <see cref="T:System.Threading.SynchronizationContext">SynchronizationContext</see> and use it
            when invoking the <paramref name="callback"/>.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can 
            be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The associated <see
            cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.UnsafeRegister(System.Action{System.Object},System.Object)">
            <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
            <remarks>
            <para>
            If this token is already in the canceled state, the delegate will be run immediately and synchronously.
            Any exception the delegate generates will be propagated out of this method call.
            </para>
            <para>
            <see cref="T:System.Threading.ExecutionContext">ExecutionContext</see> is not captured nor flowed
            to the callback's invocation.
            </para>
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="state">The state to pass to the <paramref name="callback"/> when the delegate is invoked.  This may be null.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can 
            be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean,System.Boolean)">
            <summary>
            Registers a delegate that will be called when this 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.
            </summary>
            <remarks>
            <para>
            If this token is already in the canceled state, the
            delegate will be run immediately and synchronously. Any exception the delegate generates will be
            propagated out of this method call.
            </para>
            </remarks>
            <param name="callback">The delegate to be executed when the <see cref="T:System.Threading.CancellationToken">CancellationToken</see> is canceled.</param>
            <param name="state">The state to pass to the <paramref name="callback"/> when the delegate is invoked.  This may be null.</param>
            <param name="useSynchronizationContext">A Boolean value that indicates whether to capture
            the current <see cref="T:System.Threading.SynchronizationContext">SynchronizationContext</see> and use it
            when invoking the <paramref name="callback"/>.</param>
            <returns>The <see cref="T:System.Threading.CancellationTokenRegistration"/> instance that can 
            be used to unregister the callback.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="callback"/> is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The associated <see
            cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)">
            <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance is equal to the 
            specified token.
            </summary>
            <param name="other">The other <see cref="T:System.Threading.CancellationToken">CancellationToken</see> to which to compare this
            instance.</param>
            <returns>True if the instances are equal; otherwise, false. Two tokens are equal if they are associated
            with the same <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> or if they were both constructed 
            from public CancellationToken constructors and their <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> values are equal.</returns>
        </member>
        <member name="M:System.Threading.CancellationToken.Equals(System.Object)">
            <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance is equal to the 
            specified <see cref="T:System.Object"/>.
            </summary>
            <param name="other">The other object to which to compare this instance.</param>
            <returns>True if <paramref name="other"/> is a <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            and if the two instances are equal; otherwise, false. Two tokens are equal if they are associated
            with the same <see cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> or if they were both constructed 
            from public CancellationToken constructors and their <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> values are equal.</returns>
            <exception cref="T:System.ObjectDisposedException">An associated <see
            cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.GetHashCode">
            <summary>
            Serves as a hash function for a <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
            <returns>A hash code for the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance.</returns>
        </member>
        <member name="M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)">
            <summary>
            Determines whether two <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instances are equal.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True if the instances are equal; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">An associated <see
            cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)">
            <summary>
            Determines whether two <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instances are not equal.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True if the instances are not equal; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">An associated <see
            cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.CancellationToken.ThrowIfCancellationRequested">
            <summary>
            Throws a <see cref="T:System.OperationCanceledException">OperationCanceledException</see> if
            this token has had cancellation requested.
            </summary>
            <remarks>
            This method provides functionality equivalent to:
            <code>
            if (token.IsCancellationRequested) 
               throw new OperationCanceledException(token);
            </code>
            </remarks>
            <exception cref="T:System.OperationCanceledException">The token has had cancellation requested.</exception>
            <exception cref="T:System.ObjectDisposedException">The associated <see
            cref="T:System.Threading.CancellationTokenSource">CancellationTokenSource</see> has been disposed.</exception>
        </member>
        <member name="T:System.Threading.CancellationTokenRegistration">
            <summary>
            Represents a callback delegate that has been registered with a <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
            <remarks>
            To unregister a callback, dispose the corresponding Registration instance.
            </remarks>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.Dispose">
            <summary>
            Disposes of the registration and unregisters the target callback from the associated 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            If the target callback is currently executing, this method will wait until it completes, except
            in the degenerate cases where a callback method unregisters itself.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.DisposeAsync">
            <summary>
            Disposes of the registration and unregisters the target callback from the associated 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            The returned <see cref="T:System.Threading.Tasks.ValueTask"/> will complete once the associated callback
            is unregistered without having executed or once it's finished executing, except
            in the degenerate case where the callback itself is unregistering itself.
            </summary>
        </member>
        <member name="P:System.Threading.CancellationTokenRegistration.Token">
            <summary>
            Gets the <see cref="T:System.Threading.CancellationToken"/> with which this registration is associated.  If the
            registration isn't associated with a token (such as after the registration has been disposed),
            this will return a default token.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.Unregister">
            <summary>
            Disposes of the registration and unregisters the target callback from the associated 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.op_Equality(System.Threading.CancellationTokenRegistration,System.Threading.CancellationTokenRegistration)">
            <summary>
            Determines whether two <see
            cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see>
            instances are equal.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True if the instances are equal; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.op_Inequality(System.Threading.CancellationTokenRegistration,System.Threading.CancellationTokenRegistration)">
            <summary>
            Determines whether two <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instances are not equal.
            </summary>
            <param name="left">The first instance.</param>
            <param name="right">The second instance.</param>
            <returns>True if the instances are not equal; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.Equals(System.Object)">
            <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instance is equal to the 
            specified <see cref="T:System.Object"/>.
            </summary> 
            <param name="obj">The other object to which to compare this instance.</param>
            <returns>True, if both this and <paramref name="obj"/> are equal. False, otherwise.
            Two <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instances are equal if
            they both refer to the output of a single call to the same Register method of a 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>. 
            </returns>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.Equals(System.Threading.CancellationTokenRegistration)">
            <summary>
            Determines whether the current <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instance is equal to the 
            specified <see cref="T:System.Object"/>.
            </summary> 
            <param name="other">The other <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> to which to compare this instance.</param>
            <returns>True, if both this and <paramref name="other"/> are equal. False, otherwise.
            Two <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instances are equal if
            they both refer to the output of a single call to the same Register method of a 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>. 
            </returns>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.GetHashCode">
            <summary>
            Serves as a hash function for a <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration.</see>.
            </summary>
            <returns>A hash code for the current <see cref="T:System.Threading.CancellationTokenRegistration">CancellationTokenRegistration</see> instance.</returns>
        </member>
        <member name="T:System.Threading.CancellationTokenSource">
            <summary>Signals to a <see cref="T:System.Threading.CancellationToken"/> that it should be canceled.</summary>
            <remarks>
            <para>
            <see cref="T:System.Threading.CancellationTokenSource"/> is used to instantiate a <see cref="T:System.Threading.CancellationToken"/> (via
            the source's <see cref="P:System.Threading.CancellationTokenSource.Token">Token</see> property) that can be handed to operations that wish to be
            notified of cancellation or that can be used to register asynchronous operations for cancellation. That
            token may have cancellation requested by calling to the source's <see cref="M:System.Threading.CancellationTokenSource.Cancel"/> method.
            </para>
            <para>
            All members of this class, except <see cref="M:System.Threading.CancellationTokenSource.Dispose"/>, are thread-safe and may be used
            concurrently from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.s_canceledSource">
            <summary>A <see cref="T:System.Threading.CancellationTokenSource"/> that's already canceled.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.s_neverCanceledSource">
            <summary>A <see cref="T:System.Threading.CancellationTokenSource"/> that's never canceled.  This isn't enforced programmatically, only by usage.  Do not cancel!</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.s_timerCallback">
            <summary>Delegate used with <see cref="T:System.Threading.Timer"/> to trigger cancellation of a <see cref="T:System.Threading.CancellationTokenSource"/>.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.s_numPartitions">
            <summary>The number of callback partitions to use in a <see cref="T:System.Threading.CancellationTokenSource"/>. Must be a power of 2.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.s_numPartitionsMask">
            <summary><see cref="F:System.Threading.CancellationTokenSource.s_numPartitions"/> - 1, used to quickly mod into <see cref="F:System.Threading.CancellationTokenSource._callbackPartitions"/>.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource._state">
            <summary>The current state of the CancellationTokenSource.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource._threadIDExecutingCallbacks">
            <summary>The ID of the thread currently executing the main body of CTS.Cancel()</summary>
            <remarks>
            This helps us to know if a call to ctr.Dispose() is running 'within' a cancellation callback.
            This is updated as we move between the main thread calling cts.Cancel() and any syncContexts
            that are used to actually run the callbacks.
            </remarks>
        </member>
        <member name="F:System.Threading.CancellationTokenSource._executingCallbackId">
            <summary>Tracks the running callback to assist ctr.Dispose() to wait for the target callback to complete.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource._callbackPartitions">
            <summary>Partitions of callbacks.  Split into multiple partitions to help with scalability of registering/unregistering; each is protected by its own lock.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource._timer">
            <summary>TimerQueueTimer used by CancelAfter and Timer-related ctors. Used instead of Timer to avoid extra allocations and because the rooted behavior is desired.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource._kernelEvent">
            <summary><see cref="T:System.Threading.WaitHandle"/> lazily initialized and returned from <see cref="P:System.Threading.CancellationTokenSource.WaitHandle"/>.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource._disposed">
            <summary>Whether this <see cref="T:System.Threading.CancellationTokenSource"/> has been disposed.</summary>
        </member>
        <member name="P:System.Threading.CancellationTokenSource.IsCancellationRequested">
            <summary>Gets whether cancellation has been requested for this <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
            <value>Whether cancellation has been requested for this <see cref="T:System.Threading.CancellationTokenSource" />.</value>
            <remarks>
            <para>
            This property indicates whether cancellation has been requested for this token source, such as
            due to a call to its <see cref="M:System.Threading.CancellationTokenSource.Cancel"/> method.
            </para>
            <para>
            If this property returns true, it only guarantees that cancellation has been requested. It does not
            guarantee that every handler registered with the corresponding token has finished executing, nor
            that cancellation requests have finished propagating to all registered handlers. Additional
            synchronization may be required, particularly in situations where related objects are being
            canceled concurrently.
            </para>
            </remarks>
        </member>
        <member name="P:System.Threading.CancellationTokenSource.IsCancellationCompleted">
            <summary>A simple helper to determine whether cancellation has finished.</summary>
        </member>
        <member name="P:System.Threading.CancellationTokenSource.IsDisposed">
            <summary>A simple helper to determine whether disposal has occurred.</summary>
        </member>
        <member name="P:System.Threading.CancellationTokenSource.ThreadIDExecutingCallbacks">
            <summary>The ID of the thread that is running callbacks.</summary>
        </member>
        <member name="P:System.Threading.CancellationTokenSource.Token">
            <summary>Gets the <see cref="T:System.Threading.CancellationToken"/> associated with this <see cref="T:System.Threading.CancellationTokenSource"/>.</summary>
            <value>The <see cref="T:System.Threading.CancellationToken"/> associated with this <see cref="T:System.Threading.CancellationTokenSource"/>.</value>
            <exception cref="T:System.ObjectDisposedException">The token source has been disposed.</exception>
        </member>
        <member name="P:System.Threading.CancellationTokenSource.ExecutingCallback">
            <summary>Gets the ID of the currently executing callback.</summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.#ctor">
            <summary>Initializes the <see cref="T:System.Threading.CancellationTokenSource"/>.</summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.#ctor(System.TimeSpan)">
            <summary>
            Constructs a <see cref="T:System.Threading.CancellationTokenSource"/> that will be canceled after a specified time span.
            </summary>
            <param name="delay">The time span to wait before canceling this <see cref="T:System.Threading.CancellationTokenSource"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when <paramref name="delay"/> is less than -1 or greater than int.MaxValue.
            </exception>
            <remarks>
            <para>
            The countdown for the delay starts during the call to the constructor.  When the delay expires, 
            the constructed <see cref="T:System.Threading.CancellationTokenSource"/> is canceled, if it has
            not been canceled already.
            </para>
            <para>
            Subsequent calls to CancelAfter will reset the delay for the constructed 
            <see cref="T:System.Threading.CancellationTokenSource"/>, if it has not been
            canceled already.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.#ctor(System.Int32)">
            <summary>
            Constructs a <see cref="T:System.Threading.CancellationTokenSource"/> that will be canceled after a specified time span.
            </summary>
            <param name="millisecondsDelay">The time span to wait before canceling this <see cref="T:System.Threading.CancellationTokenSource"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when <paramref name="millisecondsDelay"/> is less than -1.
            </exception>
            <remarks>
            <para>
            The countdown for the millisecondsDelay starts during the call to the constructor.  When the millisecondsDelay expires, 
            the constructed <see cref="T:System.Threading.CancellationTokenSource"/> is canceled (if it has
            not been canceled already).
            </para>
            <para>
            Subsequent calls to CancelAfter will reset the millisecondsDelay for the constructed 
            <see cref="T:System.Threading.CancellationTokenSource"/>, if it has not been
            canceled already.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.InitializeWithTimer(System.Int32)">
            <summary>
            Common initialization logic when constructing a CTS with a delay parameter.
            A zero delay will result in immediate cancellation.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.Cancel">
            <summary>Communicates a request for cancellation.</summary>
            <remarks>
            <para>
            The associated <see cref="T:System.Threading.CancellationToken" /> will be notified of the cancellation
            and will transition to a state where <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> returns true. 
            Any callbacks or cancelable operations registered with the <see cref="T:System.Threading.CancellationToken"/>  will be executed.
            </para>
            <para>
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            However, this overload of Cancel will aggregate any exceptions thrown into a <see cref="T:System.AggregateException"/>,
            such that one callback throwing an exception will not prevent other registered callbacks from being executed.
            </para>
            <para>
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered
            will be reestablished when the callback is invoked.
            </para>
            </remarks>
            <exception cref="T:System.AggregateException">An aggregate exception containing all the exceptions thrown
            by the registered callbacks on the associated <see cref="T:System.Threading.CancellationToken"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">This <see cref="T:System.Threading.CancellationTokenSource"/> has been disposed.</exception> 
        </member>
        <member name="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)">
            <summary>Communicates a request for cancellation.</summary>
            <remarks>
            <para>
            The associated <see cref="T:System.Threading.CancellationToken" /> will be notified of the cancellation and will transition to a state where 
            <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> returns true. Any callbacks or cancelable operationsregistered
            with the <see cref="T:System.Threading.CancellationToken"/>  will be executed.
            </para>
            <para>
            Cancelable operations and callbacks registered with the token should not throw exceptions. 
            If <paramref name="throwOnFirstException"/> is true, an exception will immediately propagate out of the
            call to Cancel, preventing the remaining callbacks and cancelable operations from being processed.
            If <paramref name="throwOnFirstException"/> is false, this overload will aggregate any 
            exceptions thrown into a <see cref="T:System.AggregateException"/>,
            such that one callback throwing an exception will not prevent other registered callbacks from being executed.
            </para>
            <para>
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered
            will be reestablished when the callback is invoked.
            </para>
            </remarks>
            <param name="throwOnFirstException">Specifies whether exceptions should immediately propagate.</param>
            <exception cref="T:System.AggregateException">An aggregate exception containing all the exceptions thrown
            by the registered callbacks on the associated <see cref="T:System.Threading.CancellationToken"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">This <see cref="T:System.Threading.CancellationTokenSource"/> has been disposed.</exception> 
        </member>
        <member name="M:System.Threading.CancellationTokenSource.CancelAfter(System.TimeSpan)">
            <summary>Schedules a Cancel operation on this <see cref="T:System.Threading.CancellationTokenSource"/>.</summary>
            <param name="delay">The time span to wait before canceling this <see cref="T:System.Threading.CancellationTokenSource"/>.
            </param>
            <exception cref="T:System.ObjectDisposedException">The exception thrown when this <see
            cref="T:System.Threading.CancellationTokenSource"/> has been disposed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception thrown when <paramref name="delay"/> is less than -1 or 
            greater than int.MaxValue.
            </exception>
            <remarks>
            <para>
            The countdown for the delay starts during this call.  When the delay expires, 
            this <see cref="T:System.Threading.CancellationTokenSource"/> is canceled, if it has
            not been canceled already.
            </para>
            <para>
            Subsequent calls to CancelAfter will reset the delay for this  
            <see cref="T:System.Threading.CancellationTokenSource"/>, if it has not been canceled already.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.CancelAfter(System.Int32)">
            <summary>
            Schedules a Cancel operation on this <see cref="T:System.Threading.CancellationTokenSource"/>.
            </summary>
            <param name="millisecondsDelay">The time span to wait before canceling this <see
            cref="T:System.Threading.CancellationTokenSource"/>.
            </param>
            <exception cref="T:System.ObjectDisposedException">The exception thrown when this <see
            cref="T:System.Threading.CancellationTokenSource"/> has been disposed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception thrown when <paramref name="millisecondsDelay"/> is less than -1.
            </exception>
            <remarks>
            <para>
            The countdown for the millisecondsDelay starts during this call.  When the millisecondsDelay expires, 
            this <see cref="T:System.Threading.CancellationTokenSource"/> is canceled, if it has
            not been canceled already.
            </para>
            <para>
            Subsequent calls to CancelAfter will reset the millisecondsDelay for this  
            <see cref="T:System.Threading.CancellationTokenSource"/>, if it has not been
            canceled already.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.Dispose">
            <summary>Releases the resources used by this <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
            <remarks>This method is not thread-safe for any other concurrent calls.</remarks>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:System.Threading.CancellationTokenSource" /> class and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.ThrowIfDisposed">
            <summary>Throws an exception if the source has been disposed.</summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.ThrowObjectDisposedException">
            <summary>Throws an <see cref="T:System.ObjectDisposedException"/>.  Separated out from ThrowIfDisposed to help with inlining.</summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.InternalRegister(System.Action{System.Object},System.Object,System.Threading.SynchronizationContext,System.Threading.ExecutionContext)">
            <summary>
            Registers a callback object. If cancellation has already occurred, the
            callback will have been run by the time this method returns.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.ExecuteCallbackHandlers(System.Boolean)">
            <summary>Invoke all registered callbacks.</summary>
            <remarks>The handlers are invoked synchronously in LIFO order.</remarks>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.GetPartitionCount">
            <summary>Gets the number of callback partitions to use based on the number of cores.</summary>
            <returns>A power of 2 representing the number of partitions to use.</returns>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:System.Threading.CancellationTokenSource"/> that will be in the canceled state
            when any of the source tokens are in the canceled state.
            </summary>
            <param name="token1">The first <see cref="T:System.Threading.CancellationToken">CancellationToken</see> to observe.</param>
            <param name="token2">The second <see cref="T:System.Threading.CancellationToken">CancellationToken</see> to observe.</param>
            <returns>A <see cref="T:System.Threading.CancellationTokenSource"/> that is linked 
            to the source tokens.</returns>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:System.Threading.CancellationTokenSource"/> that will be in the canceled state
            when any of the source tokens are in the canceled state.
            </summary>
            <param name="token">The first <see cref="T:System.Threading.CancellationToken">CancellationToken</see> to observe.</param>
            <returns>A <see cref="T:System.Threading.CancellationTokenSource"/> that is linked to the source tokens.</returns>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken[])">
            <summary>
            Creates a <see cref="T:System.Threading.CancellationTokenSource"/> that will be in the canceled state
            when any of the source tokens are in the canceled state.
            </summary>
            <param name="tokens">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> instances to observe.</param>
            <returns>A <see cref="T:System.Threading.CancellationTokenSource"/> that is linked to the source tokens.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="tokens"/> is null.</exception>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.WaitForCallbackToComplete(System.Int64)">
            <summary>
            Wait for a single callback to complete (or, more specifically, to not be running).
            It is ok to call this method if the callback has already finished.
            Calling this method before the target callback has been selected for execution would be an error.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.WaitForCallbackToCompleteAsync(System.Int64)">
            <summary>
            Asynchronously wait for a single callback to complete (or, more specifically, to not be running).
            It is ok to call this method if the callback has already finished.
            Calling this method before the target callback has been selected for execution would be an error.
            </summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.CallbackPartition.Source">
            <summary>The associated source that owns this partition.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.CallbackPartition.Lock">
            <summary>Lock that protects all state in the partition.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.CallbackPartition.Callbacks">
            <summary>Doubly-linked list of callbacks registered with the partition. Callbacks are removed during unregistration and as they're invoked.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.CallbackPartition.FreeNodeList">
            <summary>Singly-linked list of free nodes that can be used for subsequent callback registrations.</summary>
        </member>
        <member name="F:System.Threading.CancellationTokenSource.CallbackPartition.NextAvailableId">
            <summary>Every callback is assigned a unique, never-reused ID.  This defines the next available ID.</summary>
        </member>
        <member name="T:System.Threading.CancellationTokenSource.CallbackNode">
            <summary>All of the state associated a registered callback, in a node that's part of a linked list of registered callbacks.</summary>
        </member>
        <member name="T:System.Threading.IDeferredDisposable">
            <summary>
            Provides callbacks to objects whose lifetime is managed by <see cref="T:System.Threading.DeferredDisposableLifetime`1"/>.
            </summary>
        </member>
        <member name="M:System.Threading.IDeferredDisposable.OnFinalRelease(System.Boolean)">
            <summary>
            Called when the object's refcount reaches zero.
            </summary>
            <param name="disposed">
            Indicates whether the object has been disposed.
            </param>
            <remarks>
            If the refcount reaches zero before the object is disposed, this method will be called with
            <paramref name="disposed"/> set to false.  If the object is then disposed, this method will be
            called again, with <paramref name="disposed"/> set to true.  If the refcount reaches zero
            after the object has already been disposed, this will be called a single time, with 
            <paramref name="disposed"/> set to true.
            </remarks>
        </member>
        <member name="T:System.Threading.DeferredDisposableLifetime`1">
            <summary>
            Manages the lifetime of an object which implements IDisposable, but which must defer the actual
            cleanup of state until all existing uses of the object are complete.
            </summary>
            <typeparam name="T">The type of object whose lifetime will be managed.</typeparam>
            <remarks>
            This type maintains a reference count, and tracks whether the object has been disposed.  When
            Callbacks are made to <see cref="M:System.Threading.IDeferredDisposable.OnFinalRelease(System.Boolean)"/> when the refcount
            reaches zero.  Objects that need to defer cleanup until they have been disposed *and* they have
            no more references can do so in <see cref="M:System.Threading.IDeferredDisposable.OnFinalRelease(System.Boolean)"/> when
            'disposed' is true.
            </remarks>
        </member>
        <member name="F:System.Threading.DeferredDisposableLifetime`1._count">
            <summary>_count is positive until Dispose is called, after which it's (-1 - refcount).</summary>
        </member>
        <member name="T:System.Threading.IThreadPoolWorkItem">
            <summary>Represents a work item that can be executed by the ThreadPool.</summary>
        </member>
        <member name="T:System.Threading.LazyInitializer">
            <summary>
            Provides lazy initialization routines.
            </summary>
            <remarks>
            These routines avoid needing to allocate a dedicated, lazy-initialization instance, instead using
            references to ensure targets have been initialized as they are accessed.
            </remarks>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
            <summary>
            Initializes a target reference type with the type's default constructor if the target has not
            already been initialized.
            </summary>
            <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
            <param name="target">A reference of type <typeparamref name="T"/> to initialize if it has not
            already been initialized.</param>
            <returns>The initialized reference of type <typeparamref name="T"/>.</returns>
            <exception cref="T:System.MissingMemberException">Type <typeparamref name="T"/> does not have a default
            constructor.</exception>
            <exception cref="T:System.MemberAccessException">
            Permissions to access the constructor of type <typeparamref name="T"/> were missing.
            </exception>
            <remarks>
            <para>
            This method may only be used on reference types. To ensure initialization of value
            types, see other overloads of EnsureInitialized.
            </para>
            <para>
            This method may be used concurrently by multiple threads to initialize <paramref name="target"/>.  
            In the event that multiple threads access this method concurrently, multiple instances of <typeparamref name="T"/>
            may be created, but only one will be stored into <paramref name="target"/>. In such an occurrence, this method will not dispose of the
            objects that were not stored.  If such objects must be disposed, it is up to the caller to determine 
            if an object was not used and to then dispose of the object appropriately.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@)">
            <summary>
            Initializes a target reference type with the type's default constructor (slow path)
            </summary>
            <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
            <param name="target">The variable that need to be initialized</param>
            <returns>The initialized variable</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
            <summary>
            Initializes a target reference type using the specified function if it has not already been
            initialized.
            </summary>
            <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
            <param name="target">The reference of type <typeparamref name="T"/> to initialize if it has not
            already been initialized.</param>
            <param name="valueFactory">The <see cref="T:System.Func{T}"/> invoked to initialize the
            reference.</param>
            <returns>The initialized reference of type <typeparamref name="T"/>.</returns>
            <exception cref="T:System.MissingMemberException">Type <typeparamref name="T"/> does not have a
            default constructor.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="valueFactory"/> returned
            null.</exception>
            <remarks>
            <para>
            This method may only be used on reference types, and <paramref name="valueFactory"/> may
            not return a null reference (Nothing in Visual Basic). To ensure initialization of value types or
            to allow null reference types, see other overloads of EnsureInitialized.
            </para>
            <para>
            This method may be used concurrently by multiple threads to initialize <paramref name="target"/>.  
            In the event that multiple threads access this method concurrently, multiple instances of <typeparamref name="T"/>
            may be created, but only one will be stored into <paramref name="target"/>. In such an occurrence, this method will not dispose of the
            objects that were not stored.  If such objects must be disposed, it is up to the caller to determine 
            if an object was not used and to then dispose of the object appropriately.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Func{``0})">
            <summary>
            Initialize the target using the given delegate (slow path).
            </summary>
            <typeparam name="T">The reference type of the reference to be initialized.</typeparam>
            <param name="target">The variable that need to be initialized</param>
            <param name="valueFactory">The delegate that will be executed to initialize the target</param>
            <returns>The initialized variable</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
            <summary>
            Initializes a target reference or value type with its default constructor if it has not already
            been initialized.
            </summary>
            <typeparam name="T">The type of the reference to be initialized.</typeparam>
            <param name="target">A reference or value of type <typeparamref name="T"/> to initialize if it
            has not already been initialized.</param>
            <param name="initialized">A reference to a boolean that determines whether the target has already
            been initialized.</param>
            <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing
            <paramref name="target"/>. If <paramref name="syncLock"/> is null, a new object will be instantiated.</param>
            <returns>The initialized value of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Boolean@,System.Object@)">
            <summary>
            Ensure the target is initialized and return the value (slow path). This overload permits nulls
            and also works for value type targets. Uses the type's default constructor to create the value.
            </summary>
            <typeparam name="T">The type of target.</typeparam>
            <param name="target">A reference to the target to be initialized.</param>
            <param name="initialized">A reference to a location tracking whether the target has been initialized.</param>
            <param name="syncLock">A reference to a location containing a mutual exclusive lock. If <paramref name="syncLock"/> is null, 
            a new object will be instantiated.
            </param>
            <returns>The initialized object.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
            <summary>
            Initializes a target reference or value type with a specified function if it has not already been
            initialized.
            </summary>
            <typeparam name="T">The type of the reference to be initialized.</typeparam>
            <param name="target">A reference or value of type <typeparamref name="T"/> to initialize if it
            has not already been initialized.</param>
            <param name="initialized">A reference to a boolean that determines whether the target has already
            been initialized.</param>
            <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing
            <paramref name="target"/>. If <paramref name="syncLock"/> is null, a new object will be instantiated.</param>
            <param name="valueFactory">The <see cref="T:System.Func{T}"/> invoked to initialize the
            reference or value.</param>
            <returns>The initialized value of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
            <summary>
            Ensure the target is initialized and return the value (slow path). This overload permits nulls
            and also works for value type targets. Uses the supplied function to create the value.
            </summary>
            <typeparam name="T">The type of target.</typeparam>
            <param name="target">A reference to the target to be initialized.</param>
            <param name="initialized">A reference to a location tracking whether the target has been initialized.</param>
            <param name="syncLock">A reference to a location containing a mutual exclusive lock. If <paramref name="syncLock"/> is null, 
            a new object will be instantiated.</param>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}"/> to invoke in order to produce the lazily-initialized value.
            </param>
            <returns>The initialized object.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
            <summary>
            Initializes a target reference type with a specified function if it has not already been initialized.
            </summary>
            <typeparam name="T">The type of the reference to be initialized. Has to be reference type.</typeparam>
            <param name="target">A reference of type <typeparamref name="T"/> to initialize if it has not already been initialized.</param>
            <param name="syncLock">A reference to an object used as the mutually exclusive lock for initializing
            <paramref name="target"/>. If <paramref name="syncLock"/> is null, a new object will be instantiated.</param>
            <param name="valueFactory">The <see cref="T:System.Func{T}"/> invoked to initialize the reference.</param>
            <returns>The initialized value of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureInitializedCore``1(``0@,System.Object@,System.Func{``0})">
            <summary>
            Ensure the target is initialized and return the value (slow path). This overload works only for reference type targets.
            Uses the supplied function to create the value.
            </summary>
            <typeparam name="T">The type of target. Has to be reference type.</typeparam>
            <param name="target">A reference to the target to be initialized.</param>
            <param name="syncLock">A reference to a location containing a mutual exclusive lock. If <paramref name="syncLock"/> is null, 
            a new object will be instantiated.</param>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}"/> to invoke in order to produce the lazily-initialized value.
            </param>
            <returns>The initialized object.</returns>
        </member>
        <member name="M:System.Threading.LazyInitializer.EnsureLockInitialized(System.Object@)">
            <summary>
            Ensure the lock object is initialized.
            </summary>
            <param name="syncLock">A reference to a location containing a mutual exclusive lock. If <paramref name="syncLock"/> is null,
            a new object will be instantiated.</param>
            <returns>Initialized lock object.</returns>
        </member>
        <member name="T:System.Threading.LazyThreadSafetyMode">
            <summary>
            Specifies how a <see cref="T:System.Threading.Lazy{T}"/> instance should synchronize access among multiple threads.
            </summary>
        </member>
        <member name="F:System.Threading.LazyThreadSafetyMode.None">
            <summary>
            This mode makes no guarantees around the thread-safety of the <see cref="T:System.Threading.Lazy{T}"/> instance.  If used from multiple threads, the behavior of the <see cref="T:System.Threading.Lazy{T}"/> is undefined.
            This mode should be used when a <see cref="T:System.Threading.Lazy{T}"/> is guaranteed to never be initialized from more than one thread simultaneously and high performance is crucial. 
            If valueFactory throws an exception when the <see cref="T:System.Threading.Lazy{T}"/> is initialized, the exception will be cached and returned on subsequent accesses to Value. Also, if valueFactory recursively
            accesses Value on this <see cref="T:System.Threading.Lazy{T}"/> instance, a <see cref="T:System.InvalidOperationException"/> will be thrown.
            </summary>
        </member>
        <member name="F:System.Threading.LazyThreadSafetyMode.PublicationOnly">
            <summary>
            When multiple threads attempt to simultaneously initialize a <see cref="T:System.Threading.Lazy{T}"/> instance, this mode allows each thread to execute the
            valueFactory but only the first thread to complete initialization will be allowed to set the final value of the  <see cref="T:System.Threading.Lazy{T}"/>.
            Once initialized successfully, any future calls to Value will return the cached result.  If valueFactory throws an exception on any thread, that exception will be
            propagated out of Value. If any thread executes valueFactory without throwing an exception and, therefore, successfully sets the value, that value will be returned on
            subsequent accesses to Value from any thread.  If no thread succeeds in setting the value, IsValueCreated will remain false and subsequent accesses to Value will result in
            the valueFactory delegate re-executing.  Also, if valueFactory recursively accesses Value on this  <see cref="T:System.Threading.Lazy{T}"/> instance, an exception will NOT be thrown.
            </summary>
        </member>
        <member name="F:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication">
            <summary>
            This mode uses locks to ensure that only a single thread can initialize a <see cref="T:System.Threading.Lazy{T}"/> instance in a thread-safe manner.  In general,
            taken if this mode is used in conjunction with a <see cref="T:System.Threading.Lazy{T}"/> valueFactory delegate that uses locks internally, a deadlock can occur if not
            handled carefully.  If valueFactory throws an exception when the<see cref="T:System.Threading.Lazy{T}"/> is initialized, the exception will be cached and returned on
            subsequent accesses to Value. Also, if valueFactory recursively accesses Value on this <see cref="T:System.Threading.Lazy{T}"/> instance, a  <see cref="T:System.InvalidOperationException"/> will be thrown.
            </summary>
        </member>
        <member name="T:System.Threading.ManualResetEventSlim">
            <summary>
            Provides a slimmed down version of <see cref="T:System.Threading.ManualResetEvent"/>.
            </summary>
            <remarks>
            All public and protected members of <see cref="T:System.Threading.ManualResetEventSlim"/> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.ManualResetEventSlim"/> have
            completed, and Reset, which should only be used when no other threads are
            accessing the event.
            </remarks>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
            <summary>
            Gets the underlying <see cref="T:System.Threading.WaitHandle"/> object for this <see
            cref="T:System.Threading.ManualResetEventSlim"/>.
            </summary>
            <value>The underlying <see cref="T:System.Threading.WaitHandle"/> event object fore this <see
            cref="T:System.Threading.ManualResetEventSlim"/>.</value>
            <remarks>
            Accessing this property forces initialization of an underlying event object if one hasn't
            already been created.  To simply wait on this <see cref="T:System.Threading.ManualResetEventSlim"/>, 
            the public Wait methods should be preferred.
            </remarks>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.IsSet">
            <summary>
            Gets whether the event is set.
            </summary>
            <value>true if the event has is set; otherwise, false.</value>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
            <summary>
            Gets the number of spin waits that will be occur before falling back to a true wait.
            </summary>
        </member>
        <member name="P:System.Threading.ManualResetEventSlim.Waiters">
            <summary>
            How many threads are waiting.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim"/>
            class with an initial state of nonsignaled.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim"/>
            class with a boolean value indicating whether to set the initial state to signaled.
            </summary>
            <param name="initialState">true to set the initial state signaled; false to set the initial state
            to nonsignaled.</param>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.ManualResetEventSlim"/>
            class with a Boolean value indicating whether to set the initial state to signaled and a specified
            spin count.
            </summary>
            <param name="initialState">true to set the initial state to signaled; false to set the initial state
            to nonsignaled.</param>
            <param name="spinCount">The number of spin waits that will occur before falling back to a true
            wait.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="spinCount"/> is less than
            0 or greater than the maximum allowed value.</exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Initialize(System.Boolean,System.Int32)">
            <summary>
            Initializes the internal state of the event.
            </summary>
            <param name="initialState">Whether the event is set initially or not.</param>
            <param name="spinCount">The spin count that decides when the event will block.</param>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.EnsureLockObjectCreated">
            <summary>
            Helper to ensure the lock object is created before first use.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.LazyInitializeEvent">
            <summary>
            This method lazily initializes the event object. It uses CAS to guarantee that
            many threads racing to call this at once don't result in more than one event
            being stored and used. The event will be signaled or unsignaled depending on
            the state of the thin-event itself, with synchronization taken into account.
            </summary>
            <returns>True if a new event was created and stored, false otherwise.</returns>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Set">
            <summary>
            Sets the state of the event to signaled, which allows one or more threads waiting on the event to
            proceed.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Set(System.Boolean)">
            <summary>
            Private helper to actually perform the Set.
            </summary>
            <param name="duringCancellation">Indicates whether we are calling Set() during cancellation.</param>
            <exception cref="T:System.OperationCanceledException">The object has been canceled.</exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Reset">
            <summary>
            Sets the state of the event to nonsignaled, which causes threads to block.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ManualResetEventSlim"/>, <see cref="M:System.Threading.ManualResetEventSlim.Reset"/> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim"/> is set.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
            <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim"/> receives a signal,
            while observing a <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to
            observe.</param>
            <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
            <exception cref="T:System.OperationCanceledExcepton"><paramref name="cancellationToken"/> was
            canceled.</exception>
            <remarks>
            The caller of this method blocks indefinitely until the current instance is set. The caller will
            return immediately if the event is currently in a set state.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim"/> is set, using a
            <see cref="T:System.TimeSpan"/> to measure the time interval.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim"/> was set; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim"/> is set, using a
            <see cref="T:System.TimeSpan"/> to measure the time interval, while observing a <see
            cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to
            observe.</param>
            <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim"/> was set; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.Threading.OperationCanceledException"><paramref
            name="cancellationToken"/> was canceled.</exception>
            <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim"/> is set, using a
            32-bit signed integer to measure the time interval.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/>(-1) to wait indefinitely.</param>
            <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim"/> was set; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until the current <see cref="T:System.Threading.ManualResetEventSlim"/> is set, using a
            32-bit signed integer to measure the time interval, while observing a <see
            cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/>(-1) to wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to
            observe.</param>
            <returns>true if the <see cref="T:System.Threading.ManualResetEventSlim"/> was set; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">
            The maximum number of waiters has been exceeded.
            </exception>
            <exception cref="T:System.Threading.OperationCanceledException"><paramref
            name="cancellationToken"/> was canceled.</exception>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Dispose">
            <summary>
            Releases all resources used by the current instance of <see cref="T:System.Threading.ManualResetEventSlim"/>.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ManualResetEventSlim"/>, <see cref="M:System.Threading.ManualResetEventSlim.Dispose"/> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
            <summary>
            When overridden in a derived class, releases the unmanaged resources used by the 
            <see cref="T:System.Threading.ManualResetEventSlim"/>, and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ManualResetEventSlim"/>, <see cref="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)"/> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.ThrowIfDisposed">
            <summary>
            Throw ObjectDisposedException if the MRES is disposed
            </summary>
        </member>
        <member name="F:System.Threading.ManualResetEventSlim.s_cancellationTokenCallback">
            <summary>
            Private helper method to wake up waiters when a cancellationToken gets canceled.
            </summary>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.UpdateStateAtomically(System.Int32,System.Int32)">
            <summary>
            Private helper method for updating parts of a bit-string state value.
            Mainly called from the IsSet and Waiters properties setters
            </summary>
            <remarks>
            Note: the parameter types must be int as CompareExchange cannot take a Uint
            </remarks>
            <param name="newBits">The new value</param>
            <param name="updateBitsMask">The mask used to set the bits</param>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.ExtractStatePortionAndShiftRight(System.Int32,System.Int32,System.Int32)">
            <summary>
            Private helper method - performs Mask and shift, particular helpful to extract a field from a packed word.
            eg ExtractStatePortionAndShiftRight(0x12345678, 0xFF000000, 24) => 0x12, ie extracting the top 8-bits as a simple integer 
            
            ?? is there a common place to put this rather than being private to MRES?
            </summary>
            <param name="state"></param>
            <param name="mask"></param>
            <param name="rightBitShiftCount"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.ManualResetEventSlim.ExtractStatePortion(System.Int32,System.Int32)">
            <summary>
            Performs a Mask operation, but does not perform the shift.
            This is acceptable for boolean values for which the shift is unnecessary
            eg (val &amp; Mask) != 0 is an appropriate way to extract a boolean rather than using
            ((val &amp; Mask) &gt;&gt; shiftAmount) == 1
            
            ?? is there a common place to put this rather than being private to MRES?
            </summary>
            <param name="state"></param>
            <param name="mask"></param>
        </member>
        <member name="T:System.Threading.Mutex">
            <summary>
            Synchronization primitive that can also be used for interprocess synchronization
            </summary>
            <summary>
            Synchronization primitive that can also be used for interprocess synchronization
            </summary>
        </member>
        <member name="T:System.Threading.ReaderWriterLockSlim">
            <summary>
            A reader-writer lock implementation that is intended to be simple, yet very
            efficient.  In particular only 1 interlocked operation is taken for any lock 
            operation (we use spin locks to achieve this).  The spin lock is never held
            for more than a few instructions (in particular, we never call event APIs
            or in fact any non-trivial API while holding the spin lock).   
            </summary>
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.GetThreadRWCount(System.Boolean)">
            <summary>
            This routine retrieves/sets the per-thread counts needed to enforce the
            various rules related to acquiring the lock. 
            
            DontAllocate is set to true if the caller just wants to get an existing
            entry for this thread, but doesn't want to add one if an existing one
            could not be found.
            </summary>
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.LazyCreateEvent(System.Threading.EventWaitHandle@,System.Threading.ReaderWriterLockSlim.EnterLockType)">
            <summary>
            A routine for lazily creating a event outside the lock (so if errors
            happen they are outside the lock and that we don't do much work
            while holding a spin lock).  If all goes well, reenter the lock and
            set 'waitEvent' 
            </summary>
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.WaitOnEvent(System.Threading.EventWaitHandle,System.UInt32@,System.Threading.ReaderWriterLockSlim.TimeoutTracker,System.Threading.ReaderWriterLockSlim.EnterLockType)">
            <summary>
            Waits on 'waitEvent' with a timeout  
            Before the wait 'numWaiters' is incremented and is restored before leaving this routine.
            </summary>
        </member>
        <member name="M:System.Threading.ReaderWriterLockSlim.ExitAndWakeUpAppropriateWaiters">
            <summary>
            Determines the appropriate events to set, leaves the locks, and sets the events. 
            </summary>
        </member>
        <member name="F:System.Threading.ReaderWriterLockSlim.SpinLock._enterDeprioritizationState">
            <summary>
            Used to deprioritize threads attempting to enter the lock when they would not make progress after doing so.
            <see cref="M:System.Threading.ReaderWriterLockSlim.SpinLock.EnterSpin(System.Threading.ReaderWriterLockSlim.EnterSpinLockReason)"/> avoids acquiring the lock as long as the operation for which it
            was called is deprioritized.
            
            Layout:
            - Low 16 bits: Number of threads that have deprioritized an enter-any-write operation
            - High 16 bits: Number of threads that have deprioritized an enter-any-read operation
            </summary>
        </member>
        <member name="T:System.Threading.SemaphoreSlim">
            <summary>
            Limits the number of threads that can access a resource or pool of resources concurrently.
            </summary>
            <remarks>
            <para>
            The <see cref="T:System.Threading.SemaphoreSlim"/> provides a lightweight semaphore class that doesn't
            use Windows kernel semaphores.
            </para>
            <para>
            All public and protected members of <see cref="T:System.Threading.SemaphoreSlim"/> are thread-safe and may be used
            concurrently from multiple threads, with the exception of Dispose, which
            must only be used when all other operations on the <see cref="T:System.Threading.SemaphoreSlim"/> have
            completed.
            </para>
            </remarks>
        </member>
        <member name="F:System.Threading.SemaphoreSlim.m_countOfWaitersPulsedToWake">
            <summary>
            This is used to help prevent waking more waiters than necessary. It's not perfect and sometimes more waiters than
            necessary may still be woken, see <see cref="M:System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(System.Int32,System.UInt32,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
            <summary>
            Gets the current count of the <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <value>The current count of the <see cref="T:System.Threading.SemaphoreSlim"/>.</value>
        </member>
        <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
            <summary>
            Returns a <see cref="T:System.Threading.WaitHandle"/> that can be used to wait on the semaphore.
            </summary>
            <value>A <see cref="T:System.Threading.WaitHandle"/> that can be used to wait on the
            semaphore.</value>
            <remarks>
            A successful wait on the <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle"/> does not imply a successful wait on
            the <see cref="T:System.Threading.SemaphoreSlim"/> itself, nor does it decrement the semaphore's
            count. <see cref="P:System.Threading.SemaphoreSlim.AvailableWaitHandle"/> exists to allow a thread to block waiting on multiple
            semaphores, but such a wait should be followed by a true wait on the target semaphore.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Threading.SemaphoreSlim"/> has been disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim"/> class, specifying
            the initial number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCount"/>
            is less than 0.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SemaphoreSlim"/> class, specifying
            the initial and maximum number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
            <param name="maxCount">The maximum number of requests for the semaphore that can be granted
            concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="initialCount"/>
            is less than 0. -or-
            <paramref name="initialCount"/> is greater than <paramref name="maxCount"/>. -or-
            <paramref name="maxCount"/> is less than 0.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> token to
            observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was
            canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>, using a <see
            cref="T:System.TimeSpan"/> to measure the time interval.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim"/>;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>, using a <see
            cref="T:System.TimeSpan"/> to measure the time interval, while observing a <see
            cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to
            observe.</param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim"/>;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>, using a 32-bit
            signed integer to measure the time interval.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/>(-1) to wait indefinitely.</param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim"/>;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>,
            using a 32-bit signed integer to measure the time interval, 
            while observing a <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/>(-1) to
            wait indefinitely.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>true if the current thread successfully entered the <see cref="T:System.Threading.SemaphoreSlim"/>; otherwise, false.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number other than -1,
            which represents an infinite time-out.</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was canceled.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitUntilCountOrTimeout(System.Int32,System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Local helper function, waits on the monitor until the monitor receives signal or the
            timeout is expired
            </summary>
            <param name="millisecondsTimeout">The maximum timeout</param>
            <param name="startTime">The start ticks to calculate the elapsed time</param>
            <param name="cancellationToken">The CancellationToken to observe.</param>
            <returns>true if the monitor received a signal, false if the timeout expired</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <returns>A task that will complete when the semaphore has been entered.</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/>, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <returns>A task that will complete when the semaphore has been entered.</returns>
            <param name="cancellationToken">
            The <see cref="T:System.Threading.CancellationToken"/> token to observe.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            The current instance has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/>,
            using a 32-bit signed integer to measure the time interval.
            </summary>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/>(-1) to wait indefinitely.
            </param>
            <returns>
            A task that will complete with a result of true if the current thread successfully entered 
            the <see cref="T:System.Threading.SemaphoreSlim"/>, otherwise with a result of false.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number other than -1,
            which represents an infinite time-out.
            </exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/>, using a <see
            cref="T:System.TimeSpan"/> to measure the time interval, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>
            A task that will complete with a result of true if the current thread successfully entered 
            the <see cref="T:System.Threading.SemaphoreSlim"/>, otherwise with a result of false.
            </returns>
            <exception cref="T:System.ObjectDisposedException">
            The current instance has already been disposed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="timeout"/> is a negative number other than -1 milliseconds, which represents 
            an infinite time-out -or- timeout is greater than <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/>, using a <see
            cref="T:System.TimeSpan"/> to measure the time interval.
            </summary>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="cancellationToken">
            The <see cref="T:System.Threading.CancellationToken"/> token to observe.
            </param>
            <returns>
            A task that will complete with a result of true if the current thread successfully entered 
            the <see cref="T:System.Threading.SemaphoreSlim"/>, otherwise with a result of false.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="timeout"/> is a negative number other than -1 milliseconds, which represents 
            an infinite time-out -or- timeout is greater than <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/>,
            using a 32-bit signed integer to measure the time interval, 
            while observing a <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/>(-1) to wait indefinitely.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to observe.</param>
            <returns>
            A task that will complete with a result of true if the current thread successfully entered 
            the <see cref="T:System.Threading.SemaphoreSlim"/>, otherwise with a result of false.
            </returns>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a negative number other than -1,
            which represents an infinite time-out.
            </exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.CreateAndAddAsyncWaiter">
            <summary>Creates a new task and stores it into the async waiters list.</summary>
            <returns>The created task.</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.RemoveAsyncWaiter(System.Threading.SemaphoreSlim.TaskNode)">
            <summary>Removes the waiter task from the linked list.</summary>
            <param name="task">The task to remove.</param>
            <returns>true if the waiter was in the list; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(System.Threading.SemaphoreSlim.TaskNode,System.Int32,System.Threading.CancellationToken)">
            <summary>Performs the asynchronous wait.</summary>
            <param name="asyncWaiter">The asynchronous waiter.</param>
            <param name="millisecondsTimeout">The timeout.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The task to return to the caller.</returns>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Release">
            <summary>
            Exits the <see cref="T:System.Threading.SemaphoreSlim"/> once.
            </summary>
            <returns>The previous count of the <see cref="T:System.Threading.SemaphoreSlim"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
            <summary>
            Exits the <see cref="T:System.Threading.SemaphoreSlim"/> a specified number of times.
            </summary>
            <param name="releaseCount">The number of times to exit the semaphore.</param>
            <returns>The previous count of the <see cref="T:System.Threading.SemaphoreSlim"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount"/> is less
            than 1.</exception>
            <exception cref="T:System.Threading.SemaphoreFullException">The <see cref="T:System.Threading.SemaphoreSlim"/> has
            already reached its maximum size.</exception>
            <exception cref="T:System.ObjectDisposedException">The current instance has already been
            disposed.</exception>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Dispose">
            <summary>
            Releases all resources used by the current instance of <see
            cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.SemaphoreSlim"/>, <see cref="M:System.Threading.SemaphoreSlim.Dispose"/> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
            <summary>
            When overridden in a derived class, releases the unmanaged resources used by the 
            <see cref="T:System.Threading.ManualResetEventSlim"/>, and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.SemaphoreSlim"/>, <see cref="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)"/> is not
            thread-safe and may not be used concurrently with other members of this instance.
            </remarks>
        </member>
        <member name="F:System.Threading.SemaphoreSlim.s_cancellationTokenCanceledEventHandler">
            <summary>
            Private helper method to wake up waiters when a cancellationToken gets canceled.
            </summary>
        </member>
        <member name="M:System.Threading.SemaphoreSlim.CheckDispose">
            <summary>
            Checks the dispose status by checking the lock object, if it is null means that object
            has been disposed and throw ObjectDisposedException
            </summary>
        </member>
        <member name="T:System.Threading.SpinLock">
            <summary>
            Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop
            repeatedly checking until the lock becomes available.
            </summary>
            <remarks>
            <para>
            Spin locks can be used for leaf-level locks where the object allocation implied by using a <see
            cref="T:System.Threading.Monitor"/>, in size or due to garbage collection pressure, is overly
            expensive. Avoiding blocking is another reason that a spin lock can be useful, however if you expect
            any significant amount of blocking, you are probably best not using spin locks due to excessive
            spinning. Spinning can be beneficial when locks are fine grained and large in number (for example, a
            lock per node in a linked list) as well as when lock hold times are always extremely short. In
            general, while holding a spin lock, one should avoid blocking, calling anything that itself may
            block, holding more than one spin lock at once, making dynamically dispatched calls (interface and
            virtuals), making statically dispatched calls into any code one doesn't own, or allocating memory.
            </para>
            <para>
            <see cref="T:System.Threading.SpinLock"/> should only be used when it's been determined that doing so will improve an
            application's performance. It's also important to note that <see cref="T:System.Threading.SpinLock"/> is a value type,
            for performance reasons. As such, one must be very careful not to accidentally copy a SpinLock
            instance, as the two instances (the original and the copy) would then be completely independent of
            one another, which would likely lead to erroneous behavior of the application. If a SpinLock instance
            must be passed around, it should be passed by reference rather than by value.
            </para>
            <para>
            Do not store <see cref="T:System.Threading.SpinLock"/> instances in readonly fields.
            </para>
            <para>
            All members of <see cref="T:System.Threading.SpinLock"/> are thread-safe and may be used from multiple threads
            concurrently.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock"/>
            structure with the option to track thread IDs to improve debugging.
            </summary>
            <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock"/> tracks thread ownership.
            </remarks>
            <param name="enableThreadOwnerTracking">Whether to capture and use thread IDs for debugging
            purposes.</param>
        </member>
        <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.SpinLock"/>
            structure with the option to track thread IDs to improve debugging.
            </summary>
            <remarks>
            The default constructor for <see cref="T:System.Threading.SpinLock"/> tracks thread ownership.
            </remarks>
            <summary>
            Acquires the lock in a reliable manner, such that even if an exception occurs within the method
            call, <paramref name="lockTaken"/> can be examined reliably to determine whether the lock was
            acquired.
            </summary>
            <remarks>
            <see cref="T:System.Threading.SpinLock"/> is a non-reentrant lock, meaning that if a thread holds the lock, it is
            not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's
            enabled is available through <see cref="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled"/>), an exception will be
            thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership
            tracking is disabled, attempting to enter a lock already held will result in deadlock.
            </remarks>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling Enter.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken"/> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>, TryEnter will not block waiting for the lock to be available. If the
            lock is not available when TryEnter is called, it will return immediately without any further
            spinning.
            </remarks>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling TryEnter.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken"/> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref
            name="timeout"/>
            has expired.
            </remarks>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling TryEnter.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative
            number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater
            than <see cref="F:System.Int32.MaxValue"/> milliseconds.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
            <summary>
            Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within
            the method call, <paramref name="lockTaken"/> can be examined reliably to determine whether the
            lock was acquired.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>, TryEnter will not block indefinitely waiting for the lock to be
            available. It will block until either the lock is available or until the <paramref
            name="millisecondsTimeout"/> has expired.
            </remarks>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="lockTaken">True if the lock is acquired; otherwise, false. <paramref
            name="lockTaken"/> must be initialized to false prior to calling this method.</param>
            <exception cref="T:System.Threading.LockRecursionException">
            Thread ownership tracking is enabled, and the current thread has already acquired this lock.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="lockTaken"/> argument must be initialized to false prior to calling TryEnter.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is
            a negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="M:System.Threading.SpinLock.ContinueTryEnter(System.Int32,System.Boolean@)">
            <summary>
            Try acquire the lock with long path, this is usually called after the first path in Enter and
            TryEnter failed The reason for short path is to make it inline in the run time which improves the
            performance. This method assumed that the parameter are validated in Enter or TryEnter method.
            </summary>
            <param name="millisecondsTimeout">The timeout milliseconds</param>
            <param name="lockTaken">The lockTaken param</param>
        </member>
        <member name="M:System.Threading.SpinLock.DecrementWaiters">
            <summary>
            decrements the waiters, in case of the timeout is expired
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.ContinueTryEnterWithThreadTracking(System.Int32,System.UInt32,System.Boolean@)">
            <summary>
            ContinueTryEnter for the thread tracking mode enabled
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.Exit">
            <summary>
            Releases the lock.
            </summary>
            <remarks>
            The default overload of <see cref="M:System.Threading.SpinLock.Exit"/> provides the same behavior as if calling <see
            cref="M:System.Threading.SpinLock.Exit(System.Boolean)"/> using true as the argument, but Exit() could be slightly faster than Exit(true).
            </remarks>
            <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
            <summary>
            Releases the lock.
            </summary>
            <param name="useMemoryBarrier">
            A Boolean value that indicates whether a memory fence should be issued in order to immediately
            publish the exit operation to other threads.
            </param>
            <remarks>
            Calling <see cref="M:System.Threading.SpinLock.Exit(System.Boolean)"/> with the <paramref name="useMemoryBarrier"/> argument set to
            true will improve the fairness of the lock at the expense of some performance. The default <see
            cref="M:System.Threading.SpinLock.Enter(System.Boolean@)"/>
            overload behaves as if specifying true for <paramref name="useMemoryBarrier"/>.
            </remarks>
            <exception cref="T:System.Threading.SynchronizationLockException">
            Thread ownership tracking is enabled, and the current thread is not the owner of this lock.
            </exception>
        </member>
        <member name="M:System.Threading.SpinLock.ExitSlowPath(System.Boolean)">
            <summary>
            The slow path for exit method if the fast path failed
            </summary>
            <param name="useMemoryBarrier">
            A Boolean value that indicates whether a memory fence should be issued in order to immediately
            publish the exit operation to other threads
            </param>
        </member>
        <member name="P:System.Threading.SpinLock.IsHeld">
            <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
            <summary>
            Gets whether the lock is currently held by any thread.
            </summary>
            <summary>
            Gets whether the lock is held by the current thread.
            </summary>
            <remarks>
            If the lock was initialized to track owner threads, this will return whether the lock is acquired
            by the current thread. It is invalid to use this property when the lock was initialized to not
            track thread ownership.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Thread ownership tracking is disabled.
            </exception>
        </member>
        <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
            <summary>Gets whether thread ownership tracking is enabled for this instance.</summary>
        </member>
        <member name="T:System.Threading.SpinLock.SystemThreading_SpinLockDebugView">
            <summary>
            Internal class used by debug type proxy attribute to display the owner thread ID 
            </summary>
        </member>
        <member name="M:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.#ctor(System.Threading.SpinLock)">
            <summary>
            SystemThreading_SpinLockDebugView constructor
            </summary>
            <param name="spinLock">The SpinLock to be proxied.</param>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeldByCurrentThread">
            <summary>
            Checks if the lock is held by the current thread or not
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.OwnerThreadID">
            <summary>
            Gets the current owner thread, zero if it is released
            </summary>
        </member>
        <member name="P:System.Threading.SpinLock.SystemThreading_SpinLockDebugView.IsHeld">
            <summary>
             Gets whether the lock is currently held by any thread or not.
            </summary>
        </member>
        <member name="T:System.Threading.SpinWait">
            <summary>
            Provides support for spin-based waiting.
            </summary>
            <remarks>
            <para>
            <see cref="T:System.Threading.SpinWait"/> encapsulates common spinning logic. On single-processor machines, yields are
            always used instead of busy waits, and on computers with Intel(R) processors employing Hyper-Threading
            technology, it helps to prevent hardware thread starvation. SpinWait encapsulates a good mixture of
            spinning and true yielding.
            </para>
            <para>
            <see cref="T:System.Threading.SpinWait"/> is a value type, which means that low-level code can utilize SpinWait without
            fear of unnecessary allocation overheads. SpinWait is not generally useful for ordinary applications.
            In most cases, you should use the synchronization classes provided by the .NET Framework, such as
            <see cref="T:System.Threading.Monitor"/>. For most purposes where spin waiting is required, however,
            the <see cref="T:System.Threading.SpinWait"/> type should be preferred over the <see
            cref="M:System.Threading.Thread.SpinWait(System.Int32)"/> method.
            </para>
            <para>
            While SpinWait is designed to be used in concurrent applications, it is not designed to be
            used from multiple threads concurrently.  SpinWait's members are not thread-safe.  If multiple
            threads must spin, each should use its own instance of SpinWait.
            </para>
            </remarks>
        </member>
        <member name="F:System.Threading.SpinWait.SpinCountforSpinBeforeWait">
            <summary>
            A suggested number of spin iterations before doing a proper wait, such as waiting on an event that becomes signaled
            when the resource becomes available.
            </summary>
            <remarks>
            These numbers were arrived at by experimenting with different numbers in various cases that currently use it. It's
            only a suggested value and typically works well when the proper wait is something like an event.
            
            Spinning less can lead to early waiting and more context switching, spinning more can decrease latency but may use
            up some CPU time unnecessarily. Depends on the situation too, for instance SemaphoreSlim uses more iterations
            because the waiting there is currently a lot more expensive (involves more spinning, taking a lock, etc.). It also
            depends on the likelihood of the spin being successful and how long the wait would be but those are not accounted
            for here.
            </remarks>
        </member>
        <member name="P:System.Threading.SpinWait.Count">
            <summary>
            Gets the number of times <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called on this instance.
            </summary>
        </member>
        <member name="P:System.Threading.SpinWait.NextSpinWillYield">
            <summary>
            Gets whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.
            </summary>
            <value>Whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.</value>
            <remarks>
            On a single-CPU machine, <see cref="M:System.Threading.SpinWait.SpinOnce"/> always yields the processor. On machines with
            multiple CPUs, <see cref="M:System.Threading.SpinWait.SpinOnce"/> may yield after an unspecified number of calls.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinOnce">
            <summary>
            Performs a single spin.
            </summary>
            <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinOnce(System.Int32)">
            <summary>
            Performs a single spin.
            </summary>
            <param name="sleep1Threshold">
            A minimum spin count after which <code>Thread.Sleep(1)</code> may be used. A value of <code>-1</code> may be used to
            disable the use of <code>Thread.Sleep(1)</code>.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="sleep1Threshold"/> is less than <code>-1</code>.
            </exception>
            <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.Reset">
            <summary>
            Resets the spin counter.
            </summary>
            <remarks>
            This makes <see cref="M:System.Threading.SpinWait.SpinOnce"/> and <see cref="P:System.Threading.SpinWait.NextSpinWillYield"/> behave as though no calls
            to <see cref="M:System.Threading.SpinWait.SpinOnce"/> had been issued on this instance. If a <see cref="T:System.Threading.SpinWait"/> instance
            is reused many times, it may be useful to reset it to avoid yielding too soon.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
            <summary>
            Spins until the specified condition is satisfied.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, 
            or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="T:System.Threading.PlatformHelper">
            <summary>
            A helper class to get the number of processors, it updates the numbers of processors every sampling interval.
            </summary>
        </member>
        <member name="P:System.Threading.PlatformHelper.ProcessorCount">
            <summary>
            Gets the number of available processors
            </summary>
        </member>
        <member name="F:System.Threading.PlatformHelper.IsSingleProcessor">
            <summary>
            Gets whether the current machine has only a single processor.
            </summary>
            <remarks>This typically does not change on a machine, so it's checked only once.</remarks>
        </member>
        <member name="T:System.Threading.ThreadLocal`1">
            <summary>
            Provides thread-local storage of data.
            </summary>
            <typeparam name="T">Specifies the type of data stored per-thread.</typeparam>
            <remarks>
            <para>
            With the exception of <see cref="M:System.Threading.ThreadLocal`1.Dispose"/>, all public and protected members of 
            <see cref="T:System.Threading.ThreadLocal`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance.
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance.
            </summary>
            <param name="trackAllValues">Whether to track all values set on the instance and expose them through the Values property.</param>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance with the
            specified <paramref name="valueFactory"/> function.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}"/> invoked to produce a lazily-initialized value when 
            an attempt is made to retrieve <see cref="P:System.Threading.ThreadLocal`1.Value"/> without it having been previously initialized.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="valueFactory"/> is a null reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
            <summary>
            Initializes the <see cref="T:System.Threading.ThreadLocal`1"/> instance with the
            specified <paramref name="valueFactory"/> function.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}"/> invoked to produce a lazily-initialized value when 
            an attempt is made to retrieve <see cref="P:System.Threading.ThreadLocal`1.Value"/> without it having been previously initialized.
            </param>
            <param name="trackAllValues">Whether to track all values set on the instance and expose them via the Values property.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="valueFactory"/> is a null reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Finalize">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Dispose">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal{T}"/>, this method is not thread-safe.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
            <summary>
            Releases the resources used by this <see cref="T:System.Threading.ThreadLocal{T}" /> instance.
            </summary>
            <param name="disposing">
            A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.ThreadLocal`1.Dispose"/>.
            </param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.ThreadLocal{T}"/>, this method is not thread-safe.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.ToString">
            <summary>Creates and returns a string representation of this instance for the current thread.</summary>
            <returns>The result of calling <see cref="M:System.Object.ToString"/> on the <see cref="P:System.Threading.ThreadLocal`1.Value"/>.</returns>
            <exception cref="T:System.NullReferenceException">
            The <see cref="P:System.Threading.ThreadLocal`1.Value"/> for the current thread is a null reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value"/> in an improper manner.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
            <remarks>
            Calling this method forces initialization for the current thread, as is the
            case with accessing <see cref="P:System.Threading.ThreadLocal`1.Value"/> directly.
            </remarks>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.Value">
            <summary>
            Gets or sets the value of this instance for the current thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The initialization function referenced <see cref="P:System.Threading.ThreadLocal`1.Value"/> in an improper manner.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
            <remarks>
            If this instance was not previously initialized for the current thread,
            accessing <see cref="P:System.Threading.ThreadLocal`1.Value"/> will attempt to initialize it. If an initialization function was 
            supplied during the construction, that initialization will happen by invoking the function 
            to retrieve the initial value for <see cref="P:System.Threading.ThreadLocal`1.Value"/>.  Otherwise, the default value of 
            <typeparamref name="T"/> will be used.
            </remarks>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.CreateLinkedSlot(System.Threading.ThreadLocal{`0}.LinkedSlotVolatile[],System.Int32,`0)">
            <summary>
            Creates a LinkedSlot and inserts it into the linked list for this ThreadLocal instance.
            </summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.Values">
            <summary>
            Gets a list for all of the values currently stored by all of the threads that have accessed this instance.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.GetValuesAsList">
            <summary>Gets all of the threads' values in a list.</summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.ValuesCountForDebugDisplay">
            <summary>Gets the number of threads that have data in this instance.</summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
            <summary>
            Gets whether <see cref="P:System.Threading.ThreadLocal`1.Value"/> is initialized on the current thread.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.ThreadLocal`1"/> instance has been disposed.
            </exception>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.ValueForDebugDisplay">
            <summary>Gets the value of the ThreadLocal&lt;T&gt; for debugging display purposes. It takes care of getting
            the value for the current thread in the ThreadLocal mode.</summary>
        </member>
        <member name="P:System.Threading.ThreadLocal`1.ValuesForDebugDisplay">
            <summary>Gets the values of all threads that accessed the ThreadLocal&lt;T&gt;.</summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.GrowTable(System.Threading.ThreadLocal{`0}.LinkedSlotVolatile[]@,System.Int32)">
            <summary>
            Resizes a table to a certain length (or larger).
            </summary>
        </member>
        <member name="M:System.Threading.ThreadLocal`1.GetNewTableSize(System.Int32)">
            <summary>
            Chooses the next larger table size
            </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.LinkedSlotVolatile">
            <summary>
            A wrapper struct used as LinkedSlotVolatile[] - an array of LinkedSlot instances, but with volatile semantics
            on array accesses.
            </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.LinkedSlot">
            <summary>
            A node in the doubly-linked list stored in the ThreadLocal instance.
            
            The value is stored in one of two places:
            
                1. If SlotArray is not null, the value is in SlotArray.Table[id]
                2. If SlotArray is null, the value is in FinalValue.
            </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.IdManager">
            <summary>
            A manager class that assigns IDs to ThreadLocal instances
            </summary>
        </member>
        <member name="T:System.Threading.ThreadLocal`1.FinalizationHelper">
            <summary>
            A class that facilitates ThreadLocal cleanup after a thread exits.
            
            After a thread with an associated thread-local table has exited, the FinalizationHelper 
            is responsible for removing back-references to the table. Since an instance of FinalizationHelper 
            is only referenced from a single thread-local slot, the FinalizationHelper will be GC'd once
            the thread has exited.
            
            The FinalizationHelper then locates all LinkedSlot instances with back-references to the table
            (all those LinkedSlot instances can be found by following references from the table slots) and
            releases the table so that it can get GC'd.
            </summary>
        </member>
        <member name="T:System.Threading.SystemThreading_ThreadLocalDebugView`1">
            <summary>A debugger view of the ThreadLocal&lt;T&gt; to surface additional debugging properties and 
            to ensure that the ThreadLocal&lt;T&gt; does not become initialized if it was not already.</summary>
        </member>
        <member name="M:System.Threading.SystemThreading_ThreadLocalDebugView`1.#ctor(System.Threading.ThreadLocal{`0})">
            <summary>Constructs a new debugger view object for the provided ThreadLocal object.</summary>
            <param name="tlocal">A ThreadLocal object to browse in the debugger.</param>
        </member>
        <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.IsValueCreated">
            <summary>Returns whether the ThreadLocal object is initialized or not.</summary>
        </member>
        <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.Value">
            <summary>Returns the value of the ThreadLocal object.</summary>
        </member>
        <member name="P:System.Threading.SystemThreading_ThreadLocalDebugView`1.Values">
            <summary>Return all values for all threads that have accessed this instance.</summary>
        </member>
        <member name="T:System.Threading.Volatile">
            <summary>Methods for accessing memory with volatile semantics.</summary>
        </member>
        <member name="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair">
            <summary>
            Provides concurrent and exclusive task schedulers that coordinate to execute
            tasks while ensuring that concurrent tasks may run concurrently and exclusive tasks never do.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_threadProcessingMode">
            <summary>A processing mode to denote what kinds of tasks are currently being processed on this thread.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_concurrentTaskScheduler">
            <summary>The scheduler used to queue and execute "concurrent" tasks that may run concurrently with other concurrent tasks.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_exclusiveTaskScheduler">
            <summary>The scheduler used to queue and execute "exclusive" tasks that must run exclusively while no other tasks for this pair are running.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_underlyingTaskScheduler">
            <summary>The underlying task scheduler to which all work should be scheduled.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_maxConcurrencyLevel">
            <summary>
            The maximum number of tasks allowed to run concurrently.  This only applies to concurrent tasks, 
            since exclusive tasks are inherently limited to 1.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_maxItemsPerTask">
            <summary>The maximum number of tasks we can process before recycling our runner tasks.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_processingCount">
            <summary>
            If positive, it represents the number of concurrently running concurrent tasks.
            If negative, it means an exclusive task has been scheduled.
            If 0, nothing has been scheduled.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_completionState">
            <summary>Completion state for a task representing the completion of this pair.</summary>
            <remarks>Lazily-initialized only if the scheduler pair is shutting down or if the Completion is requested.</remarks>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.m_threadPoolWorkItem">
            <summary>Lazily-initialized work item for processing when targeting the default scheduler.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.UNLIMITED_PROCESSING">
            <summary>A constant value used to signal unlimited processing.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.EXCLUSIVE_PROCESSING_SENTINEL">
            <summary>Constant used for m_processingCount to indicate that an exclusive task is being processed.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DEFAULT_MAXITEMSPERTASK">
            <summary>Default MaxItemsPerTask to use for processing if none is specified.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DefaultMaxConcurrencyLevel">
            <summary>Default MaxConcurrencyLevel is the processor count if not otherwise specified.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ValueLock">
            <summary>Gets the sync obj used to protect all state on this instance.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor">
            <summary>
            Initializes the ConcurrentExclusiveSchedulerPair.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Initializes the ConcurrentExclusiveSchedulerPair to target the specified scheduler.
            </summary>
            <param name="taskScheduler">The target scheduler on which this pair should execute.</param>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32)">
            <summary>
            Initializes the ConcurrentExclusiveSchedulerPair to target the specified scheduler with a maximum concurrency level.
            </summary>
            <param name="taskScheduler">The target scheduler on which this pair should execute.</param>
            <param name="maxConcurrencyLevel">The maximum number of tasks to run concurrently.</param>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32,System.Int32)">
            <summary>
            Initializes the ConcurrentExclusiveSchedulerPair to target the specified scheduler with a maximum 
            concurrency level and a maximum number of scheduled tasks that may be processed as a unit.
            </summary>
            <param name="taskScheduler">The target scheduler on which this pair should execute.</param>
            <param name="maxConcurrencyLevel">The maximum number of tasks to run concurrently.</param>
            <param name="maxItemsPerTask">The maximum number of tasks to process for each underlying scheduled task used by the pair.</param>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Complete">
            <summary>Informs the scheduler pair that it should not accept any more tasks.</summary>
            <remarks>
            Calling <see cref="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Complete"/> is optional, and it's only necessary if the <see cref="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Completion"/>
            will be relied on for notification of all processing being completed.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.Completion">
            <summary>Gets a <see cref="T:System.Threading.Tasks.Task"/> that will complete when the scheduler has completed processing.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.EnsureCompletionStateInitialized">
            <summary>Gets the lazily-initialized completion state.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionRequested">
            <summary>Gets whether completion has been requested.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.RequestCompletion">
            <summary>Sets that completion has been requested.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CleanupStateIfCompletingAndQuiesced">
            <summary>
            Cleans up state if and only if there's no processing currently happening
            and no more to be done later.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ReadyToComplete">
            <summary>Gets whether the pair is ready to complete.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompleteTaskAsync">
            <summary>Completes the completion task asynchronously.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.FaultWithTask(System.Threading.Tasks.Task)">
            <summary>Initiates scheduler shutdown due to a worker task faulting.</summary>
            <param name="faultedTask">The faulted worker task that's initiating the shutdown.</param>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentScheduler">
            <summary>
            Gets a TaskScheduler that can be used to schedule tasks to this pair
            that may run concurrently with other tasks on this pair.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ExclusiveScheduler">
            <summary>
            Gets a TaskScheduler that can be used to schedule tasks to this pair
            that must run exclusively with regards to other tasks on this pair.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentTaskCountForDebugger">
            <summary>Gets the number of tasks waiting to run concurrently.</summary>
            <remarks>This does not take the necessary lock, as it's only called from under the debugger.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ExclusiveTaskCountForDebugger">
            <summary>Gets the number of tasks waiting to run exclusively.</summary>
            <remarks>This does not take the necessary lock, as it's only called from under the debugger.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessAsyncIfNecessary(System.Boolean)">
            <summary>Notifies the pair that new work has arrived to be processed.</summary>
            <param name="fairly">Whether tasks should be scheduled fairly with regards to other tasks.</param>
            <remarks>Must only be called while holding the lock.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.TryQueueThreadPoolWorkItem(System.Boolean)">
            <summary>Queues concurrent or exclusive task processing to the ThreadPool if the underlying scheduler is the default.</summary>
            <param name="fairly">Whether tasks should be scheduled fairly with regards to other tasks.</param>
            <returns>true if we're targeting the thread pool such that a worker could be queued; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessExclusiveTasks">
            <summary>
            Processes exclusive tasks serially until either there are no more to process
            or we've reached our user-specified maximum limit.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessConcurrentTasks">
            <summary>
            Processes concurrent tasks serially until either there are no more to process,
            we've reached our user-specified maximum limit, or exclusive tasks have arrived.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState">
            <summary>
            Holder for lazily-initialized state about the completion of a scheduler pair.
            Completion is only triggered either by rare exceptional conditions or by
            the user calling Complete, and as such we only lazily initialize this
            state in one of those conditions or if the user explicitly asks for
            the Completion.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState.m_completionRequested">
            <summary>Whether the scheduler has had completion requested.</summary>
            <remarks>This variable is not volatile, so to gurantee safe reading reads, Volatile.Read is used in TryExecuteTaskInline.</remarks>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState.m_completionQueued">
            <summary>Whether completion processing has been queued.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState.m_exceptions">
            <summary>Unrecoverable exceptions incurred while processing.</summary>
        </member>
        <member name="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.SchedulerWorkItem">
            <summary>Reusable immutable work item that can be scheduled to the thread pool to run processing.</summary>
        </member>
        <member name="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler">
            <summary>
            A scheduler shim used to queue tasks to the pair and execute those tasks on request of the pair.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.s_tryExecuteTaskShim">
            <summary>Cached delegate for invoking TryExecuteTaskShim.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.m_pair">
            <summary>The parent pair.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.m_maxConcurrencyLevel">
            <summary>The maximum concurrency level for the scheduler.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.m_processingMode">
            <summary>The processing mode of this scheduler, exclusive or concurrent.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.m_tasks">
            <summary>Gets the queue of tasks for this scheduler.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.#ctor(System.Threading.Tasks.ConcurrentExclusiveSchedulerPair,System.Int32,System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode)">
            <summary>Initializes the scheduler.</summary>
            <param name="pair">The parent pair.</param>
            <param name="maxConcurrencyLevel">The maximum degree of concurrency this scheduler may use.</param>
            <param name="processingMode">The processing mode of this scheduler.</param>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level this scheduler is able to support.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.ExecuteTask(System.Threading.Tasks.Task)">
            <summary>Executes a task on this scheduler.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute the task synchronously on this scheduler.</summary>
            <param name="task">The task to execute.</param>
            <param name="taskWasPreviouslyQueued">Whether the task was previously queued to the scheduler.</param>
            <returns>true if the task could be executed; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.TryExecuteTaskInlineOnTargetScheduler(System.Threading.Tasks.Task)">
            <summary>
            Implements a reasonable approximation for TryExecuteTaskInline on the underlying scheduler, 
            which we can't call directly on the underlying scheduler.
            </summary>
            <param name="task">The task to execute inline if possible.</param>
            <returns>true if the task was inlined successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.TryExecuteTaskShim(System.Object)">
            <summary>Shim used to invoke this.TryExecuteTask(task).</summary>
            <param name="state">A tuple of the ConcurrentExclusiveTaskScheduler and the task to execute.</param>
            <returns>true if the task was successfully inlined; otherwise, false.</returns>
            <remarks>
            This method is separated out not because of performance reasons but so that
            the SecuritySafeCritical attribute may be employed.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.GetScheduledTasks">
            <summary>Gets for debugging purposes the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of the tasks queued.</returns>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.CountForDebugger">
            <summary>Gets the number of tasks queued to this scheduler.</summary>
        </member>
        <member name="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.DebugView">
            <summary>Provides a debug view for ConcurrentExclusiveTaskScheduler.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.DebugView.m_taskScheduler">
            <summary>The scheduler being debugged.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.DebugView.#ctor(System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler)">
            <summary>Initializes the debug view.</summary>
            <param name="scheduler">The scheduler being debugged.</param>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.DebugView.MaximumConcurrencyLevel">
            <summary>Gets this pair's maximum allowed concurrency level.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.DebugView.ScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler.DebugView.SchedulerPair">
            <summary>Gets the scheduler pair with which this scheduler is associated.</summary>
        </member>
        <member name="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView">
            <summary>Provides a debug view for ConcurrentExclusiveSchedulerPair.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView.m_pair">
            <summary>The pair being debugged.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView.#ctor(System.Threading.Tasks.ConcurrentExclusiveSchedulerPair)">
            <summary>Initializes the debug view.</summary>
            <param name="pair">The pair being debugged.</param>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView.Mode">
            <summary>Gets a representation of the execution state of the pair.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView.ScheduledExclusive">
            <summary>Gets the number of tasks waiting to run exclusively.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView.ScheduledConcurrent">
            <summary>Gets the number of tasks waiting to run concurrently.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView.CurrentlyExecutingTaskCount">
            <summary>Gets the number of tasks currently being executed.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.DebugView.TargetScheduler">
            <summary>Gets the underlying task scheduler that actually executes the tasks.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ModeForDebugger">
            <summary>Gets an enumeration for debugging that represents the current state of the scheduler pair.</summary>
            <remarks>This is only for debugging.  It does not take the necessary locks to be useful for runtime usage.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ContractAssertMonitorStatus(System.Object,System.Boolean)">
            <summary>Asserts that a given synchronization object is either held or not held.</summary>
            <param name="syncObj">The monitor to check.</param>
            <param name="held">Whether we want to assert that it's currently held or not held.</param>
        </member>
        <member name="M:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.GetCreationOptionsForTask(System.Boolean)">
            <summary>Gets the options to use for tasks.</summary>
            <param name="isReplacementReplica">If this task is being created to replace another.</param>
            <remarks>
            These options should be used for all tasks that have the potential to run user code or
            that are repeatedly spawned and thus need a modicum of fair treatment.
            </remarks>
            <returns>The options to use.</returns>
        </member>
        <member name="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode">
            <summary>Provides an enumeration that represents the current state of the scheduler pair.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode.NotCurrentlyProcessing">
            <summary>The scheduler pair is currently dormant, with no work scheduled.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode.ProcessingExclusiveTask">
            <summary>The scheduler pair has queued processing for exclusive tasks.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode.ProcessingConcurrentTasks">
            <summary>The scheduler pair has queued processing for concurrent tasks.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode.Completing">
            <summary>Completion has been requested.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode.Completed">
            <summary>The scheduler pair is finished processing.</summary>
        </member>
        <member name="T:System.Threading.Tasks.Task`1">
            <summary>
            Represents an asynchronous operation that produces a result at some time in the future.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by this <see cref="T:System.Threading.Tasks.Task`1"/>.
            </typeparam>
            <remarks>
            <para>
            <see cref="T:System.Threading.Tasks.Task`1"/> instances may be created in a variety of ways. The most common approach is by
            using the task's <see cref="P:System.Threading.Tasks.Task`1.Factory"/> property to retrieve a <see
            cref="T:System.Threading.Tasks.TaskFactory`1"/> instance that can be used to create tasks for several
            purposes. For example, to create a <see cref="T:System.Threading.Tasks.Task`1"/> that runs a function, the factory's StartNew
            method may be used:
            <code>
            // C# 
            var t = Task&lt;int&gt;.Factory.StartNew(() => GenerateResult());
            - or -
            var t = Task.Factory.StartNew(() => GenerateResult());
            
            ' Visual Basic 
            Dim t = Task&lt;int&gt;.Factory.StartNew(Function() GenerateResult())
            - or -
            Dim t = Task.Factory.StartNew(Function() GenerateResult())
            </code>
            </para>
            <para>
            The <see cref="T:System.Threading.Tasks.Task`1"/> class also provides constructors that initialize the task but that do not
            schedule it for execution. For performance reasons, the StartNew method should be the
            preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation
            and scheduling must be separated, the constructors may be used, and the task's 
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see>
            method may then be used to schedule the task for execution at a later time.
            </para>
            <para>
            All members of <see cref="T:System.Threading.Tasks.Task`1"/>, except for 
            <see cref="M:System.Threading.Tasks.Task.Dispose">Dispose</see>, are thread-safe
            and may be used from multiple threads concurrently.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified function.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified function.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to be assigned to this task.</param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified function and creation options.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified function and creation options.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified function and state.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <param name="state">An object representing data to be used by the action.</param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified action, state, and options.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <param name="state">An object representing data to be used by the function.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to be assigned to the new task.</param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified action, state, and options.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <param name="state">An object representing data to be used by the function.</param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task`1"/> with the specified action, state, and options.
            </summary>
            <param name="function">
            The delegate that represents the code to execute in the task. When the function has completed,
            the task's <see cref="P:System.Threading.Tasks.Task`1.Result"/> property will be set to return the result value of the function.
            </param>
            <param name="state">An object representing data to be used by the function.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to be assigned to the new task.</param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the task's behavior.
            </param>
            <exception cref="T:System.ArgumentException">
            The <paramref name="function"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.Task,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a new future object.
            </summary>
            <param name="parent">The parent task for this future.</param>
            <param name="valueSelector">A function that yields the future value.</param>
            <param name="scheduler">The task scheduler which will be used to execute the future.</param>
            <param name="cancellationToken">The CancellationToken for the task.</param>
            <param name="creationOptions">Options to control the future's behavior.</param>
            <param name="internalOptions">Internal options to control the future's behavior.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.#ctor(System.Delegate,System.Object,System.Threading.Tasks.Task,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a new future object.
            </summary>
            <param name="parent">The parent task for this future.</param>
            <param name="state">An object containing data to be used by the action; may be null.</param>
            <param name="valueSelector">A function that yields the future value.</param>
            <param name="cancellationToken">The CancellationToken for the task.</param>
            <param name="scheduler">The task scheduler which will be used to execute the future.</param>
            <param name="creationOptions">Options to control the future's behavior.</param>
            <param name="internalOptions">Internal options to control the future's behavior.</param>
        </member>
        <member name="P:System.Threading.Tasks.Task`1.Result">
            <summary>
            Gets the result value of this <see cref="T:System.Threading.Tasks.Task`1"/>.
            </summary>
            <remarks>
            The get accessor for this property ensures that the asynchronous operation is complete before
            returning. Once the result of the computation is available, it is stored and will be returned
            immediately on later calls to <see cref="P:System.Threading.Tasks.Task`1.Result"/>.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task`1.ResultOnSuccess">
            <summary>
            Gets the result value of this <see cref="T:System.Threading.Tasks.Task`1"/> once the task has completed successfully.
            </summary>
            <remarks>
            This version of Result should only be used if the task completed successfully and if there's
            no debugger wait notification enabled for this task.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task`1.Factory">
            <summary>
            Provides access to factory methods for creating <see cref="T:System.Threading.Tasks.Task`1"/> instances.
            </summary>
            <remarks>
            The factory returned from <see cref="P:System.Threading.Tasks.Task`1.Factory"/> is a default instance
            of <see cref="T:System.Threading.Tasks.TaskFactory`1"/>, as would result from using
            the default constructor on the factory type.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.InnerInvoke">
            <summary>
            Evaluates the value selector of the Task which is passed in as an object and stores the result.
            </summary>        
        </member>
        <member name="M:System.Threading.Tasks.Task`1.GetAwaiter">
            <summary>Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <returns>An awaiter instance.</returns>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)">
            <summary>Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured; otherwise, false.
            </param>
            <returns>An object used to await this task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref
            name="continuationOptions"/> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions"/> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref
            name="continuationOptions"/> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions"/> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes.  When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            <para>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </para>
            <para>
            The <paramref name="continuationFunction"/>, when executed, should return a <see
            cref="T:System.Threading.Tasks.Task`1"/>. This task's completion state will be transferred to the task returned
            from the ContinueWith call.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be passed as
            an argument this completed task.
            </param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            <para>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </para>
            <para>
            The <paramref name="continuationFunction"/>, when executed, should return a <see cref="T:System.Threading.Tasks.Task`1"/>.
            This task's completion state will be transferred to the task returned from the
            ContinueWith call.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes.  When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            <para>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current
            task has completed, whether it completes due to running to completion successfully, faulting due
            to an unhandled exception, or exiting out early due to being canceled.
            </para>
            <para>
            The <paramref name="continuationFunction"/>, when executed, should return a <see
            cref="T:System.Threading.Tasks.Task`1"/>. This task's completion state will be transferred to the task returned
            from the ContinueWith call.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task`1"/> completes.
            </summary>
            <typeparam name="TNewResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task`1"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            <para>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </para>
            <para>
            The <paramref name="continuationFunction"/>, when executed, should return a <see cref="T:System.Threading.Tasks.Task`1"/>.
            This task's completion state will be transferred to the task returned from the
            ContinueWith call.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="T:System.Threading.Tasks.TaskFactory`1">
            <summary>
            Provides support for creating and scheduling
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task{TResult}</see> objects.
            </summary>
            <typeparam name="TResult">The type of the results that are available though 
            the <see cref="T:System.Threading.Tasks.Task{TResult}">Task{TResult}</see> objects that are associated with 
            the methods in this class.</typeparam>
            <remarks>
            <para>
            There are many common patterns for which tasks are relevant. The <see cref="T:System.Threading.Tasks.TaskFactory`1"/>
            class encodes some of these patterns into methods that pick up default settings, which are
            configurable through its constructors.
            </para>
            <para>
            A default instance of <see cref="T:System.Threading.Tasks.TaskFactory`1"/> is available through the
            <see cref="P:System.Threading.Tasks.Task`1.Factory">Task{TResult}.Factory</see> property.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1"/> instance with the default configuration.
            </summary>
            <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory`1"/> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1"/> instance with the default configuration.
            </summary>
            <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken"/> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory"/> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
            <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory`1"/> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1"/> instance with the specified configuration.
            </summary>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any tasks created with this TaskFactory{TResult}. A null value
            indicates that the current TaskScheduler should be used.
            </param>
            <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to <paramref name="scheduler"/>, unless it's null, in which case the property is
            initialized to the current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1"/> instance with the specified configuration.
            </summary>
            <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory{TResult}.
            </param>
            <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory{TResult}.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions"/> argument or the <paramref name="continuationOptions"/>
            argument specifies an invalid value.
            </exception>
            <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to <paramref name="creationOptions"/>,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <paramref
            name="continuationOptions"/>, and the <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to the
            current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory`1"/> instance with the specified configuration.
            </summary>
            <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken"/> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory"/> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
            <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory{TResult}.
            </param>
            <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory{TResult}.
            </param>
            <param name="scheduler">
            The default <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any Tasks created with this TaskFactory{TResult}. A null value
            indicates that TaskScheduler.Current should be used.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions"/> argument or the <paramref name="continuationOptions"/>
            argumentspecifies an invalid value.
            </exception>
            <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to <paramref name="creationOptions"/>,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <paramref
            name="continuationOptions"/>, and the <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to
            <paramref name="scheduler"/>, unless it's null, in which case the property is initialized to the
            current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory`1.CancellationToken">
            <summary>
            Gets the default <see cref="T:System.Threading.CancellationToken">CancellationToken</see> of this
            TaskFactory.
            </summary>
            <remarks>
            This property returns the default <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken"/> that will be assigned to all 
            tasks created by this factory unless another CancellationToken value is explicitly specified 
            during the call to the factory methods.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory`1.Scheduler">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> of this
            TaskFactory{TResult}.
            </summary>
            <remarks>
            This property returns the default scheduler for this factory.  It will be used to schedule all 
            tasks unless another scheduler is explicitly specified during calls to this factory's methods.  
            If null, <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see> 
            will be used.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory`1.CreationOptions">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions
            </see> value of this TaskFactory{TResult}.
            </summary>
            <remarks>
            This property returns the default creation options for this factory.  They will be used to create all 
            tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory`1.ContinuationOptions">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskContinuationOptions
            </see> value of this TaskFactory{TResult}.
            </summary>
            <remarks>
            This property returns the default continuation options for this factory.  They will be used to create 
            all continuation tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken"/> that will be assigned to the new task.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="scheduler">The <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="scheduler"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken"/> that will be assigned to the new task.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory`1.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="scheduler">The <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="scheduler"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The function delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The function delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The function delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the task that executes the end method.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg3">The third argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg3">The third argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsyncTrim``2(``0,``1,System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{``0,System.IAsyncResult,`0})">
            <summary>
            Special internal-only FromAsync support used by System.IO to wrap
            APM implementations with minimal overhead, avoiding unnecessary closure
            and delegate allocations.
            </summary>
            <typeparam name="TInstance">Specifies the type of the instance on which the APM implementation lives.</typeparam>
            <typeparam name="TArgs">Specifies the type containing the arguments.</typeparam>
            <param name="thisRef">The instance from which the begin and end methods are invoked.</param>
            <param name="beginMethod">The begin method.</param>
            <param name="endMethod">The end method.</param>
            <param name="args">The arguments.</param>
            <returns>A task representing the asynchronous operation.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1">
            <summary>
            A specialized task used by FromAsyncTrim.  Stores relevant information as instance
            state so that we can avoid unnecessary closure/delegate allocations.
            </summary>
            <typeparam name="TInstance">Specifies the type of the instance on which the APM implementation lives.</typeparam>
        </member>
        <member name="F:System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1.s_completeFromAsyncResult">
            <summary>A cached delegate used as the callback for the BeginXx method.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1.m_thisRef">
            <summary>A reference to the object on which the begin/end methods are invoked.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1.m_endMethod">
            <summary>The end method.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1.#ctor(`1,System.Func{`1,System.IAsyncResult,`0})">
            <summary>Initializes the promise.</summary>
            <param name="thisRef">A reference to the object on which the begin/end methods are invoked.</param>
            <param name="endMethod">The end method.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1.CompleteFromAsyncResult(System.IAsyncResult)">
            <summary>
            Completes the asynchronous operation using information in the IAsyncResult.  
            IAsyncResult.AsyncState needs to be the FromAsyncTrimPromise to complete.
            </summary>
            <param name="asyncResult">The IAsyncResult for the async operation.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.FromAsyncTrimPromise`1.Complete(`1,System.Func{`1,System.IAsyncResult,`0},System.IAsyncResult,System.Boolean)">
            <summary>Completes the promise.</summary>
            <param name="thisRef">The target instance on which the end method should be called.</param>
            <param name="endMethod">The end method to call to retrieve the result.</param>
            <param name="asyncResult">The IAsyncResult for the async operation.</param>
            <param name="requiresSynchronization">
            Whether completing the task requires synchronization.  This should be true
            unless absolutely sure that the task has not yet been handed out to any consumers.
            </param>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in 
            the <paramref name="tasks"/> array have completed.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in 
            the <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the <paramref
            name="tasks"/> array have completed.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the <paramref
            name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="T:System.Threading.Tasks.IProducerConsumerQueue`1">
            <summary>Represents a producer/consumer queue used internally by dataflow blocks.</summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.IProducerConsumerQueue`1.Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
            <remarks>This method is meant to be thread-safe subject to the particular nature of the implementation.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.IProducerConsumerQueue`1.TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
            <remarks>This method is meant to be thread-safe subject to the particular nature of the implementation.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.IProducerConsumerQueue`1.IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
            <remarks>This method may or may not be thread-safe.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.IProducerConsumerQueue`1.Count">
            <summary>Gets the number of items in the collection.</summary>
            <remarks>In many implementations, this method will not be thread-safe.</remarks>
        </member>
        <member name="T:System.Threading.Tasks.MultiProducerMultiConsumerQueue`1">
            <summary>
            Provides a producer/consumer queue safe to be used by any number of producers and consumers concurrently.
            </summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.MultiProducerMultiConsumerQueue`1.System#Threading#Tasks#IProducerConsumerQueue{T}#Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:System.Threading.Tasks.MultiProducerMultiConsumerQueue`1.System#Threading#Tasks#IProducerConsumerQueue{T}#TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="P:System.Threading.Tasks.MultiProducerMultiConsumerQueue`1.System#Threading#Tasks#IProducerConsumerQueue{T}#IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
        </member>
        <member name="P:System.Threading.Tasks.MultiProducerMultiConsumerQueue`1.System#Threading#Tasks#IProducerConsumerQueue{T}#Count">
            <summary>Gets the number of items in the collection.</summary>
        </member>
        <member name="T:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1">
            <summary>
            Provides a producer/consumer queue safe to be used by only one producer and one consumer concurrently.
            </summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.INIT_SEGMENT_SIZE">
            <summary>The initial size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.MAX_SEGMENT_SIZE">
            <summary>The maximum size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.m_head">
            <summary>The head of the linked list of segments.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.m_tail">
            <summary>The tail of the linked list of segments.</summary>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.#ctor">
            <summary>Initializes the queue.</summary>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.EnqueueSlow(`0,System.Threading.Tasks.SingleProducerSingleConsumerQueue{`0}.Segment@)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
            <param name="segment">The segment in which to first attempt to store the item.</param>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.TryDequeueSlow(System.Threading.Tasks.SingleProducerSingleConsumerQueue{`0}.Segment@,`0[]@,`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="array">The array from which the item was dequeued.</param>
            <param name="segment">The segment from which the item was dequeued.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="P:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
            <remarks>WARNING: This should not be used concurrently without further vetting.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.GetEnumerator">
            <summary>Gets an enumerable for the collection.</summary>
            <remarks>WARNING: This should only be used for debugging purposes.  It is not safe to be used concurrently.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerable for the collection.</summary>
            <remarks>WARNING: This should only be used for debugging purposes.  It is not safe to be used concurrently.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.Count">
            <summary>Gets the number of items in the collection.</summary>
            <remarks>WARNING: This should only be used for debugging purposes.  It is not meant to be used concurrently.</remarks>
        </member>
        <member name="T:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.Segment">
            <summary>A segment in the queue containing one or more items.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.Segment.m_next">
            <summary>The next segment in the linked list of segments.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.Segment.m_array">
            <summary>The data stored in this segment.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.Segment.m_state">
            <summary>Details about the segment.</summary>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.Segment.#ctor(System.Int32)">
            <summary>Initializes the segment.</summary>
            <param name="size">The size to use for this segment.</param>
        </member>
        <member name="T:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState">
            <summary>Stores information about a segment.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState.m_pad0">
            <summary>Padding to reduce false sharing between the segment's array and m_first.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState.m_first">
            <summary>The index of the current head in the segment.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState.m_lastCopy">
            <summary>A copy of the current tail index.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState.m_pad1">
            <summary>Padding to reduce false sharing between the first and last.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState.m_firstCopy">
            <summary>A copy of the current head index.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState.m_last">
            <summary>The index of the current tail in the segment.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SegmentState.m_pad2">
            <summary>Padding to reduce false sharing with the last and what's after the segment.</summary>
        </member>
        <member name="T:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView">
            <summary>Debugger type proxy for a SingleProducerSingleConsumerQueue of T.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.m_queue">
            <summary>The queue being visualized.</summary>
        </member>
        <member name="M:System.Threading.Tasks.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.#ctor(System.Threading.Tasks.SingleProducerSingleConsumerQueue{`0})">
            <summary>Initializes the debug view.</summary>
            <param name="queue">The queue being debugged.</param>
        </member>
        <member name="T:System.Threading.Tasks.TaskStatus">
            <summary>
            Represents the current stage in the lifecycle of a <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.Created">
            <summary> 
            The task has been initialized but has not yet been scheduled.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.WaitingForActivation">
            <summary> 
            The task is waiting to be activated and scheduled internally by the .NET Framework infrastructure.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.WaitingToRun">
            <summary>
            The task has been scheduled for execution but has not yet begun executing.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.Running">
            <summary>
            The task is running but has not yet completed.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.WaitingForChildrenToComplete">
            <summary>
            The task has finished executing and is implicitly waiting for
            attached child tasks to complete.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.RanToCompletion">
            <summary>
            The task completed execution successfully.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.Canceled">
            <summary>
            The task acknowledged cancellation by throwing an OperationCanceledException with its own CancellationToken
            while the token was in signaled state, or the task's CancellationToken was already signaled before the
            task started executing.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskStatus.Faulted">
            <summary>
            The task completed due to an unhandled exception.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Task">
            <summary>
            Represents an asynchronous operation.
            </summary>
            <remarks>
            <para>
            <see cref="T:System.Threading.Tasks.Task"/> instances may be created in a variety of ways. The most common approach is by
            using the Task type's <see cref="P:System.Threading.Tasks.Task.Factory"/> property to retrieve a <see
            cref="T:System.Threading.Tasks.TaskFactory"/> instance that can be used to create tasks for several
            purposes. For example, to create a <see cref="T:System.Threading.Tasks.Task"/> that runs an action, the factory's StartNew
            method may be used:
            <code>
            // C# 
            var t = Task.Factory.StartNew(() => DoAction());
            
            ' Visual Basic 
            Dim t = Task.Factory.StartNew(Function() DoAction())
            </code>
            </para>
            <para>
            The <see cref="T:System.Threading.Tasks.Task"/> class also provides constructors that initialize the Task but that do not
            schedule it for execution. For performance reasons, TaskFactory's StartNew method should be the
            preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation
            and scheduling must be separated, the constructors may be used, and the task's <see cref="M:System.Threading.Tasks.Task.Start"/>
            method may then be used to schedule the task for execution at a later time.
            </para>
            <para>
            All members of <see cref="T:System.Threading.Tasks.Task"/>, except for <see cref="M:System.Threading.Tasks.Task.Dispose"/>, are thread-safe
            and may be used from multiple threads concurrently.
            </para>
            <para>
            For operations that return values, the <see cref="T:System.Threading.Tasks.Task`1"/> class
            should be used.
            </para>
            <para>
            For developers implementing custom debuggers, several internal and private members of Task may be
            useful (these may change from release to release). The Int32 m_taskId field serves as the backing
            store for the <see cref="P:System.Threading.Tasks.Task.Id"/> property, however accessing this field directly from a debugger may be
            more efficient than accessing the same value through the property's getter method (the
            s_taskIdCounter Int32 counter is used to retrieve the next available ID for a Task). Similarly, the
            Int32 m_stateFlags field stores information about the current lifecycle stage of the Task,
            information also accessible through the <see cref="P:System.Threading.Tasks.Task.Status"/> property. The m_action System.Object
            field stores a reference to the Task's delegate, and the m_stateObject System.Object field stores the
            async state passed to the Task by the developer. Finally, for debuggers that parse stack frames, the
            InternalWait method serves a potential marker for when a Task is entering a wait operation.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContingentProperties.SetCompleted">
            <summary>
            Sets the internal completion event.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContingentProperties.UnregisterCancellationCallback">
            <summary>
            Checks if we registered a CT callback during construction, and unregisters it.
            This should be called when we know the registration isn't useful anymore. Specifically from Finish() if the task has completed
            successfully or with an exception.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor">
            <summary>Constructor for use with promise-style tasks that aren't configurable.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action.
            </summary>
            <param name="action">The delegate that represents the code to execute in the Task.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action and <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </summary>
            <param name="action">The delegate that represents the code to execute in the Task.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            that will be assigned to the new Task.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="action"/> argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action and creation options.
            </summary>
            <param name="action">The delegate that represents the code to execute in the task.</param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action and creation options.
            </summary>
            <param name="action">The delegate that represents the code to execute in the task.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action and state.
            </summary>
            <param name="action">The delegate that represents the code to execute in the task.</param>
            <param name="state">An object representing data to be used by the action.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action, state, and options.
            </summary>
            <param name="action">The delegate that represents the code to execute in the task.</param>
            <param name="state">An object representing data to be used by the action.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new task.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action, state, and options.
            </summary>
            <param name="action">The delegate that represents the code to execute in the task.</param>
            <param name="state">An object representing data to be used by the action.</param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new <see cref="T:System.Threading.Tasks.Task"/> with the specified action, state, and options.
            </summary>
            <param name="action">The delegate that represents the code to execute in the task.</param>
            <param name="state">An object representing data to be used by the action.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="creationOptions">
            The <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used to
            customize the Task's behavior.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskCreationOptions"/>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.#ctor(System.Delegate,System.Object,System.Threading.Tasks.Task,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            An internal constructor used by the factory methods on task and its descendent(s).
            </summary>
            <param name="action">An action to execute.</param>
            <param name="state">Optional state to pass to the action.</param>
            <param name="parent">Parent of Task.</param>
            <param name="cancellationToken">A CancellationToken for the task.</param>
            <param name="scheduler">A task scheduler under which the task will run.</param>
            <param name="creationOptions">Options to control its execution.</param>
            <param name="internalOptions">Internal options to control its execution</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.TaskConstructorCore(System.Delegate,System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.InternalTaskOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Common logic used by the following internal ctors:
                Task()
                Task(object action, object state, Task parent, TaskCreationOptions options, TaskScheduler taskScheduler)
            </summary>
            <param name="action">Action for task to execute.</param>
            <param name="state">Object to which to pass to action (may be null)</param>
            <param name="scheduler">Task scheduler on which to run thread (only used by continuation tasks).</param>
            <param name="cancellationToken">A CancellationToken for the Task.</param>
            <param name="creationOptions">Options to customize behavior of Task.</param>
            <param name="internalOptions">Internal options to customize behavior of Task.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.AssignCancellationToken(System.Threading.CancellationToken,System.Threading.Tasks.Task,System.Threading.Tasks.TaskContinuation)">
            <summary>
            Handles everything needed for associating a CancellationToken with a task which is being constructed.
            This method is meant to be called either from the TaskConstructorCore or from ContinueWithCore.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.SetNotificationForWaitCompletion(System.Boolean)">
            <summary>
            Sets or clears the TASK_STATE_WAIT_COMPLETION_NOTIFICATION state bit.
            The debugger sets this bit to aid it in "stepping out" of an async method body.
            If enabled is true, this must only be called on a task that has not yet been completed.
            If enabled is false, this may be called on completed tasks.
            Either way, it should only be used for promise-style tasks.
            </summary>
            <param name="enabled">true to set the bit; false to unset the bit.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.NotifyDebuggerOfWaitCompletionIfNecessary">
            <summary>
            Calls the debugger notification method if the right bit is set and if
            the task itself allows for the notification to proceed.
            </summary>
            <returns>true if the debugger was notified; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.AnyTaskRequiresNotifyDebuggerOfWaitCompletion(System.Threading.Tasks.Task[])">
            <summary>Returns true if any of the supplied tasks require wait notification.</summary>
            <param name="tasks">The tasks to check.</param>
            <returns>true if any of the tasks require notification; otherwise, false.</returns>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsWaitNotificationEnabledOrNotRanToCompletion">
            <summary>Gets whether either the end await bit is set or (not xor) the task has not completed successfully.</summary>
            <returns>(DebuggerBitSet || !RanToCompletion)</returns>
        </member>
        <member name="P:System.Threading.Tasks.Task.ShouldNotifyDebuggerOfWaitCompletion">
            <summary>
            Determines whether we should inform the debugger that we're ending a join with a task.  
            This should only be called if the debugger notification bit is set, as it is has some cost,
            namely it is a virtual call (however calling it if the bit is not set is not functionally 
            harmful).  Derived implementations may choose to only conditionally call down to this base 
            implementation.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsWaitNotificationEnabled">
            <summary>Gets whether the task's debugger notification for wait completion bit is set.</summary>
            <returns>true if the bit is set; false if it's not set.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.NotifyDebuggerOfWaitCompletion">
            <summary>Placeholder method used as a breakpoint target by the debugger.  Must not be inlined or optimized.</summary>
            <remarks>All joins with a task should end up calling this if their debugger notification bit is set.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddNewChild">
            <summary>
            Internal function that will be called by a new child task to add itself to 
            the children list of the parent (this).
            
            Since a child task can only be created from the thread executing the action delegate
            of this task, reentrancy is neither required nor supported. This should not be called from
            anywhere other than the task construction/initialization codepaths.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Start">
            <summary>
            Starts the <see cref="T:System.Threading.Tasks.Task"/>, scheduling it for execution to the current <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </summary>
            <remarks>
            A task may only be started and run only once.  Any attempts to schedule a task a second time
            will result in an exception.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task"/> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Starts the <see cref="T:System.Threading.Tasks.Task"/>, scheduling it for execution to the specified <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </summary>
            <remarks>
            A task may only be started and run only once. Any attempts to schedule a task a second time will
            result in an exception.
            </remarks>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> with which to associate
            and execute this task.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task"/> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.RunSynchronously">
            <summary>
            Runs the <see cref="T:System.Threading.Tasks.Task"/> synchronously on the current <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </summary>
            <remarks>
            <para>
            A task may only be started and run only once. Any attempts to schedule a task a second time will
            result in an exception.
            </para>
            <para>
            Tasks executed with <see cref="M:System.Threading.Tasks.Task.RunSynchronously"/> will be associated with the current <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>.
            </para>
            <para>
            If the target scheduler does not support running this Task on the current thread, the Task will
            be scheduled for execution on the scheduler, and the current thread will block until the
            Task has completed execution.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task"/> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Runs the <see cref="T:System.Threading.Tasks.Task"/> synchronously on the <see
            cref="T:System.Threading.Tasks.TaskScheduler">scheduler</see> provided.
            </summary>
            <remarks>
            <para>
            A task may only be started and run only once. Any attempts to schedule a task a second time will
            result in an exception.
            </para>
            <para>
            If the target scheduler does not support running this Task on the current thread, the Task will
            be scheduled for execution on the scheduler, and the current thread will block until the
            Task has completed execution.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Tasks.Task"/> is not in a valid state to be started. It may have already been started,
            executed, or canceled, or it may have been created in a manner that doesn't support direct
            scheduling.
            </exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="scheduler"/> parameter
            is null.</exception>
            <param name="scheduler">The scheduler on which to attempt to run this task inline.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.NewId">
            <summary>
            Gets a unique ID for a <see cref="T:System.Threading.Tasks.Task">Task</see> or task continuation instance.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.Id">
            <summary>
            Gets a unique ID for this <see cref="T:System.Threading.Tasks.Task">Task</see> instance.
            </summary>
            <remarks>
            Task IDs are assigned on-demand and do not necessarily represent the order in the which Task
            instances were created.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.CurrentId">
            <summary>
            Returns the unique ID of the currently executing <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.InternalCurrent">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.Task">Task</see> instance currently executing, or
            null if none exists.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.InternalCurrentIfAttached(System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Gets the Task instance currently executing if the specified creation options
            contain AttachedToParent.
            </summary>
            <param name="creationOptions">The options to check.</param>
            <returns>The current task if there is one and if AttachToParent is in the options; otherwise, null.</returns>
        </member>
        <member name="P:System.Threading.Tasks.Task.Exception">
            <summary>
            Gets the <see cref="T:System.AggregateException">Exception</see> that caused the <see
            cref="T:System.Threading.Tasks.Task">Task</see> to end prematurely. If the <see
            cref="T:System.Threading.Tasks.Task">Task</see> completed successfully or has not yet thrown any
            exceptions, this will return null.
            </summary>
            <remarks>
            Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a
            <see cref="T:System.AggregateException"/> in calls to <see cref="M:System.Threading.Tasks.Task.Wait">Wait</see>
            or in accesses to the <see cref="P:System.Threading.Tasks.Task.Exception"/> property.  Any exceptions not observed by the time
            the Task instance is garbage collected will be propagated on the finalizer thread.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.Status">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> of this Task. 
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCanceled">
            <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task">Task</see> instance has completed
            execution due to being canceled.
            </summary>
            <remarks>
            A <see cref="T:System.Threading.Tasks.Task">Task</see> will complete in Canceled state either if its <see cref="P:System.Threading.Tasks.Task.CancellationToken">CancellationToken</see> 
            was marked for cancellation before the task started executing, or if the task acknowledged the cancellation request on 
            its already signaled CancellationToken by throwing an 
            <see cref="T:System.OperationCanceledException">OperationCanceledException</see> that bears the same 
            <see cref="T:System.Threading.CancellationToken">CancellationToken</see>.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCancellationRequested">
            <summary>
            Returns true if this task has a cancellation token and it was signaled.
            To be used internally in execute entry codepaths.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.EnsureContingentPropertiesInitialized">
            <summary>
            Ensures that the contingent properties field has been initialized.
            ASSUMES THAT m_stateFlags IS ALREADY SET!
            </summary>
            <returns>The initialized contingent properties object.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.EnsureContingentPropertiesInitializedUnsafe">
            <summary>
            Without synchronization, ensures that the contingent properties field has been initialized.
            ASSUMES THAT m_stateFlags IS ALREADY SET!
            </summary>
            <returns>The initialized contingent properties object.</returns>
        </member>
        <member name="P:System.Threading.Tasks.Task.CancellationToken">
            <summary>
            This internal property provides access to the CancellationToken that was set on the task 
            when it was constructed.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCancellationAcknowledged">
            <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task"/> threw an OperationCanceledException while its CancellationToken was signaled.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCompleted">
            <summary>
            Gets whether this <see cref="T:System.Threading.Tasks.Task">Task</see> has completed.
            </summary>
            <remarks>
            <see cref="P:System.Threading.Tasks.Task.IsCompleted"/> will return true when the Task is in one of the three
            final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>,
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.CreationOptions">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions</see> used
            to create this task.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
            <summary>
            Gets a <see cref="T:System.Threading.WaitHandle"/> that can be used to wait for the task to
            complete.
            </summary>
            <remarks>
            Using the wait functionality provided by <see cref="M:System.Threading.Tasks.Task.Wait"/>
            should be preferred over using <see cref="P:System.IAsyncResult.AsyncWaitHandle"/> for similar
            functionality.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.Threading.Tasks.Task"/> has been disposed.
            </exception>
        </member>
        <member name="P:System.Threading.Tasks.Task.AsyncState">
            <summary>
            Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task">Task</see> was created,
            or null if none was supplied.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
            <summary>
            Gets an indication of whether the asynchronous operation completed synchronously.
            </summary>
            <value>true if the asynchronous operation completed synchronously; otherwise, false.</value>
        </member>
        <member name="P:System.Threading.Tasks.Task.ExecutingTaskScheduler">
            <summary>
            Provides access to the TaskScheduler responsible for executing this Task.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.Factory">
            <summary>
            Provides access to factory methods for creating <see cref="T:System.Threading.Tasks.Task"/> and <see cref="T:System.Threading.Tasks.Task`1"/> instances.
            </summary>
            <remarks>
            The factory returned from <see cref="P:System.Threading.Tasks.Task.Factory"/> is a default instance
            of <see cref="T:System.Threading.Tasks.TaskFactory"/>, as would result from using
            the default constructor on TaskFactory.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.CompletedTask">
            <summary>Gets a task that's already been completed successfully.</summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.CompletedEvent">
            <summary>
            Provides an event that can be used to wait for completion.
            Only called by IAsyncResult.AsyncWaitHandle, which means that we really do need to instantiate a completion event.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.ExceptionRecorded">
            <summary>
            Whether an exception has been stored into the task.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsFaulted">
            <summary>
            Gets whether the <see cref="T:System.Threading.Tasks.Task"/> completed due to an unhandled exception.
            </summary>
            <remarks>
            If <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> is true, the Task's <see cref="P:System.Threading.Tasks.Task.Status"/> will be equal to
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">TaskStatus.Faulted</see>, and its
            <see cref="P:System.Threading.Tasks.Task.Exception"/> property will be non-null.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.Task.CapturedContext">
            <summary>
            The captured execution context for the current task to run inside
            If the TASK_STATE_EXECUTIONCONTEXT_IS_NULL flag is set, this means ExecutionContext.Capture returned null, otherwise
            If the captured context is the default, nothing is saved, otherwise the m_contingentProperties inflates to save the context
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Dispose">
            <summary>
            Disposes the <see cref="T:System.Threading.Tasks.Task"/>, releasing all of its unmanaged resources.  
            </summary>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Tasks.Task"/>, this method is not thread-safe.
            Also, <see cref="M:System.Threading.Tasks.Task.Dispose"/> may only be called on a <see cref="T:System.Threading.Tasks.Task"/> that is in one of
            the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>,
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The exception that is thrown if the <see cref="T:System.Threading.Tasks.Task"/> is not in 
            one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>,
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>        
        </member>
        <member name="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
            <summary>
            Disposes the <see cref="T:System.Threading.Tasks.Task"/>, releasing all of its unmanaged resources.  
            </summary>
            <param name="disposing">
            A Boolean value that indicates whether this method is being called due to a call to <see
            cref="M:System.Threading.Tasks.Task.Dispose"/>.
            </param>
            <remarks>
            Unlike most of the members of <see cref="T:System.Threading.Tasks.Task"/>, this method is not thread-safe.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task.ScheduleAndStart(System.Boolean)">
            <summary>
            Schedules the task for execution.
            </summary>
            <param name="needsProtection">If true, TASK_STATE_STARTED bit is turned on in
            an atomic fashion, making sure that TASK_STATE_CANCELED does not get set
            underneath us.  If false, TASK_STATE_STARTED bit is OR-ed right in.  This
            allows us to streamline things a bit for StartNew(), where competing cancellations
            are not a problem.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddException(System.Object)">
            <summary>
            Adds an exception to the list of exceptions this task has thrown.
            </summary>
            <param name="exceptionObject">An object representing either an Exception or a collection of Exceptions.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddException(System.Object,System.Boolean)">
            <summary>
            Adds an exception to the list of exceptions this task has thrown.
            </summary>
            <param name="exceptionObject">An object representing either an Exception or a collection of Exceptions.</param>
            <param name="representsCancellation">Whether the exceptionObject is an OperationCanceledException representing cancellation.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.GetExceptions(System.Boolean)">
            <summary>
            Returns a list of exceptions by aggregating the holder's contents. Or null if
            no exceptions have been thrown.
            </summary>
            <param name="includeTaskCanceledExceptions">Whether to include a TCE if cancelled.</param>
            <returns>An aggregate exception, or null if no exceptions have been caught.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.GetExceptionDispatchInfos">
            <summary>Gets the exception dispatch infos once the task has faulted.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.GetCancellationExceptionDispatchInfo">
            <summary>Gets the ExceptionDispatchInfo containing the OperationCanceledException for this task.</summary>
            <returns>The ExceptionDispatchInfo.  May be null if no OCE was stored for the task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.ThrowIfExceptional(System.Boolean)">
            <summary>
            Throws an aggregate exception if the task contains exceptions. 
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ThrowAsync(System.Exception,System.Threading.SynchronizationContext)">
            <summary>Throws the exception on the ThreadPool.</summary>
            <param name="exception">The exception to propagate.</param>
            <param name="targetContext">The target context on which to propagate the exception.  Null to use the ThreadPool.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.UpdateExceptionObservedStatus">
            <summary>
            Checks whether this is an attached task, and whether we are being called by the parent task.
            And sets the TASK_STATE_EXCEPTIONOBSERVEDBYPARENT status flag based on that.
            
            This is meant to be used internally when throwing an exception, and when WaitAll is gathering 
            exceptions for tasks it waited on. If this flag gets set, the implicit wait on children 
            will skip exceptions to prevent duplication.
            
            This should only be called when this task has completed with an exception
            
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsExceptionObservedByParent">
            <summary>
            Checks whether the TASK_STATE_EXCEPTIONOBSERVEDBYPARENT status flag is set,
            This will only be used by the implicit wait to prevent double throws
            
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsDelegateInvoked">
            <summary>
            Checks whether the body was ever invoked. Used by task scheduler code to verify custom schedulers actually ran the task.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Finish(System.Boolean)">
             <summary>
             Signals completion of this particular task.
            
             The userDelegateExecute parameter indicates whether this Finish() call comes following the
             full execution of the user delegate. 
             
             If userDelegateExecute is false, it mean user delegate wasn't invoked at all (either due to
             a cancellation request, or because this task is a promise style Task). In this case, the steps
             involving child tasks (i.e. WaitForChildren) will be skipped.
             
             </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.FinishStageTwo">
            <summary>
            FinishStageTwo is to be executed as soon as we known there are no more children to complete. 
            It can happen i) either on the thread that originally executed this task (if no children were spawned, or they all completed by the time this task's delegate quit)
                         ii) or on the thread that executed the last child.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.FinishStageThree">
            <summary>
            Final stage of the task completion code path. Notifies the parent (if any) that another of its children are done, and runs continuations.
            This function is only separated out from FinishStageTwo because these two operations are also needed to be called from CancellationCleanupLogic()
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task)">
            <summary>
            This is called by children of this task when they are completed.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddExceptionsFromChildren(System.Threading.Tasks.Task.ContingentProperties)">
            <summary>
            This is to be called just before the task does its final state transition. 
            It traverses the list of exceptional children, and appends their aggregate exceptions into this one's exception list
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ExecuteEntry">
            <summary>
            Outermost entry function to execute this task. Handles all aspects of executing a task on the caller thread.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ExecuteFromThreadPool(System.Threading.Thread)">
            <summary>
            ThreadPool's entry point into the Task.  The base behavior is simply to
            use the entry point that's not protected from double-invoke; derived internal tasks
            can override to customize their behavior, which is usually done by promises
            that want to reuse the same object as a queued work item.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.InnerInvoke">
            <summary>
            The actual code which invokes the body of the task. This can be overridden in derived types.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.HandleException(System.Exception)">
            <summary>
            Performs whatever handling is necessary for an unhandled exception. Normally
            this just entails adding the exception to the holder object. 
            </summary>
            <param name="unhandledException">The exception that went unhandled.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.GetAwaiter">
            <summary>Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task"/>.</summary>
            <returns>An awaiter instance.</returns>
            <remarks>This method is intended for compiler user rather than use directly in code.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
            <summary>Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task"/>.</summary>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured; otherwise, false.
            </param>
            <returns>An object used to await this task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.SetContinuationForAwait(System.Action,System.Boolean,System.Boolean)">
            <summary>
            Sets a continuation onto the <see cref="T:System.Threading.Tasks.Task"/>.
            The continuation is scheduled to run in the current synchronization context is one exists, 
            otherwise in the current task scheduler.
            </summary>
            <param name="continuationAction">The action to invoke when the <see cref="T:System.Threading.Tasks.Task"/> has completed.</param>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured; otherwise, false.
            </param>
            <param name="flowExecutionContext">Whether to flow ExecutionContext across the await.</param>
            <exception cref="T:System.InvalidOperationException">The awaiter was not properly initialized.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.UnsafeSetContinuationForAwait(System.Runtime.CompilerServices.IAsyncStateMachineBox,System.Boolean)">
            <summary>
            Sets a continuation onto the <see cref="T:System.Threading.Tasks.Task"/>.
            The continuation is scheduled to run in the current synchronization context is one exists, 
            otherwise in the current task scheduler.
            </summary>
            <param name="stateMachineBox">The action to invoke when the <see cref="T:System.Threading.Tasks.Task"/> has completed.</param>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the original context captured; otherwise, false.
            </param>
            <exception cref="T:System.InvalidOperationException">The awaiter was not properly initialized.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Yield">
            <summary>Creates an awaitable that asynchronously yields back to the current context when awaited.</summary>
            <returns>
            A context that, when awaited, will asynchronously transition back into the current context at the 
            time of the await. If the current SynchronizationContext is non-null, that is treated as the current context.
            Otherwise, TaskScheduler.Current is treated as the current context.
            </returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown during
            the execution of the <see cref="T:System.Threading.Tasks.Task"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a <see
            cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>
            true if the <see cref="T:System.Threading.Tasks.Task"/> completed execution within the allotted time; otherwise, false.
            </returns>
            <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown during the execution of the <see
            cref="T:System.Threading.Tasks.Task"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="timeout"/> is a negative number other than -1 milliseconds, which represents an
            infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> to observe while waiting for the task to complete.
            </param>
            <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken"/> was canceled.
            </exception>
            <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown during the execution of the <see
            cref="T:System.Threading.Tasks.Task"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait(System.Int32)">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to
            wait indefinitely.</param>
            <returns>true if the <see cref="T:System.Threading.Tasks.Task"/> completed execution within the allotted time; otherwise,
            false.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
            <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown during the execution of the <see
            cref="T:System.Threading.Tasks.Task"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Waits for the <see cref="T:System.Threading.Tasks.Task"/> to complete execution.
            </summary>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to
            wait indefinitely.
            </param>
            <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> to observe while waiting for the task to complete.
            </param>
            <returns>
            true if the <see cref="T:System.Threading.Tasks.Task"/> completed execution within the allotted time; otherwise, false.
            </returns>
            <exception cref="T:System.AggregateException">
            The <see cref="T:System.Threading.Tasks.Task"/> was canceled -or- an exception was thrown during the execution of the <see
            cref="T:System.Threading.Tasks.Task"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken"/> was canceled.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.InternalWait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            The core wait function, which is only accessible internally. It's meant to be used in places in TPL code where 
            the current context is known or cached.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.SpinThenBlockingWait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Waits for the task to complete, for a timeout to occur, or for cancellation to be requested.
            The method first spins and then falls back to blocking on a new event.
            </summary>
            <param name="millisecondsTimeout">The timeout.</param>
            <param name="cancellationToken">The token.</param>
            <returns>true if the task is completed; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.SpinWait(System.Int32)">
            <summary>
            Spins briefly while checking IsCompleted
            </summary>
            <param name="millisecondsTimeout">The timeout.</param>
            <returns>true if the task is completed; otherwise, false.</returns>
            <exception cref="T:System.OperationCanceledException">The wait was canceled.</exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.InternalCancel(System.Boolean)">
            <summary>
            Cancels the <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <param name="bCancelNonExecutingOnly"> 
            Indicates whether we should only cancel non-invoked tasks.
            For the default scheduler this option will only be serviced through TryDequeue.
            For custom schedulers we also attempt an atomic state transition.
            </param>
            <returns>true if the task was successfully canceled; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.SetCancellationAcknowledged">
            <summary>
            Sets the task's cancellation acknowledged flag.
            </summary>    
        </member>
        <member name="M:System.Threading.Tasks.Task.TrySetResult">
            <summary>Completes a promise task as RanToCompletion.</summary>
            <remarks>If this is a Task{T}, default(T) is the implied result.</remarks>
            <returns>true if the task was transitioned to ran to completion; false if it was already completed.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FinishContinuations">
            <summary>
            Runs all of the continuations, as appropriate.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="cancellationToken"> The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes.  When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref
            name="continuationOptions"/> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions"/> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="cancellationToken"> The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes.  When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref
            name="continuationOptions"/> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <param name="continuationAction">
            An action to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation action.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task"/> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions"/> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationAction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes.  When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref
            name="continuationOptions"/> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task as an argument.
            </param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions"/> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes.  When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed, whether it completes due to running to completion successfully, faulting due to an
            unhandled exception, or exiting out early due to being canceled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed. If the continuation criteria specified through the <paramref
            name="continuationOptions"/> parameter are not met, the continuation task will be canceled
            instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation that executes when the target <see cref="T:System.Threading.Tasks.Task"/> completes.
            </summary>
            <typeparam name="TResult">
            The type of the result produced by the continuation.
            </typeparam>
            <param name="continuationFunction">
            A function to run when the <see cref="T:System.Threading.Tasks.Task"/> completes. When run, the delegate will be
            passed the completed task and the caller-supplied state object as arguments.
            </param>
            <param name="state">An object representing data to be used by the continuation function.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">
            Options for when the continuation is scheduled and how it behaves. This includes criteria, such
            as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">OnlyOnCanceled</see>, as
            well as execution options, such as <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">ExecuteSynchronously</see>.
            </param>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> to associate with the continuation task and to use for its
            execution.
            </param>
            <returns>A new continuation <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
            <remarks>
            The returned <see cref="T:System.Threading.Tasks.Task`1"/> will not be scheduled for execution until the current task has
            completed. If the criteria specified through the <paramref name="continuationOptions"/> parameter
            are not met, the continuation task will be canceled instead of scheduled.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="continuationFunction"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="continuationOptions"/> argument specifies an invalid value for <see
            cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="scheduler"/> argument is null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.CreationOptionsFromContinuationOptions(System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskCreationOptions@,System.Threading.Tasks.InternalTaskOptions@)">
            <summary>
            Converts TaskContinuationOptions to TaskCreationOptions, and also does
            some validity checking along the way.
            </summary>
            <param name="continuationOptions">Incoming TaskContinuationOptions</param>
            <param name="creationOptions">Outgoing TaskCreationOptions</param>
            <param name="internalOptions">Outgoing InternalTaskOptions</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWithCore(System.Threading.Tasks.Task,System.Threading.Tasks.TaskScheduler,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Registers the continuation and possibly runs it (if the task is already finished).
            </summary>
            <param name="continuationTask">The continuation task itself.</param>
            <param name="scheduler">TaskScheduler with which to associate continuation task.</param>
            <param name="options">Restrictions on when the continuation becomes active.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task"/> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a <see
            cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="timeout"/> is a negative number other than -1 milliseconds, which represents an
            infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task"/> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to
            wait indefinitely.</param>
            <param name="tasks">An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task"/> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> to observe while waiting for the tasks to complete.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken"/> was canceled.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            Waits for all of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <returns>
            true if all of the <see cref="T:System.Threading.Tasks.Task"/> instances completed execution within the allotted time;
            otherwise, false.
            </returns>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to
            wait indefinitely.
            </param>
            <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> to observe while waiting for the tasks to complete.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.AggregateException">
            At least one of the <see cref="T:System.Threading.Tasks.Task"/> instances was canceled -or- an exception was thrown during
            the execution of at least one of the <see cref="T:System.Threading.Tasks.Task"/> instances.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken"/> was canceled.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddToList``1(``0,System.Collections.Generic.List{``0}@,System.Int32)">
            <summary>Adds an element to the list, initializing the list if it's null.</summary>
            <typeparam name="T">Specifies the type of data stored in the list.</typeparam>
            <param name="item">The item to add.</param>
            <param name="list">The list.</param>
            <param name="initSize">The size to which to initialize the list if the list is null.</param>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAllBlockingCore(System.Collections.Generic.List{System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>Performs a blocking WaitAll on the vetted list of tasks.</summary>
            <param name="tasks">The tasks, which have already been checked and filtered for completion.</param>
            <param name="millisecondsTimeout">The timeout.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>true if all of the tasks completed; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.AddExceptionsForCompletedTask(System.Collections.Generic.List{System.Exception}@,System.Threading.Tasks.Task)">
            <summary>
            This internal function is only meant to be called by WaitAll()
            If the completed task is canceled or it has other exceptions, here we will add those
            into the passed in exception list (which will be lazily initialized here).
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <returns>The index of the completed task in the <paramref name="tasks"/> array argument.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, or a <see
            cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>
            The index of the completed task in the <paramref name="tasks"/> array argument, or -1 if the
            timeout occurred.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="timeout"/> is a negative number other than -1 milliseconds, which represents an
            infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> to observe while waiting for a task to complete.
            </param>
            <returns>
            The index of the completed task in the <paramref name="tasks"/> array argument.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken"/> was canceled.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to
            wait indefinitely.
            </param>
            <returns>
            The index of the completed task in the <paramref name="tasks"/> array argument, or -1 if the
            timeout occurred.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
            <summary>
            Waits for any of the provided <see cref="T:System.Threading.Tasks.Task"/> objects to complete execution.
            </summary>
            <param name="tasks">
            An array of <see cref="T:System.Threading.Tasks.Task"/> instances on which to wait.
            </param>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to
            wait indefinitely.
            </param>
            <param name="cancellationToken">
            A <see cref="P:System.Threading.Tasks.Task.CancellationToken"/> to observe while waiting for a task to complete.
            </param>
            <returns>
            The index of the completed task in the <paramref name="tasks"/> array argument, or -1 if the
            timeout occurred.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> argument contains a null element.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="millisecondsTimeout"/> is a negative number other than -1, which represents an
            infinite time-out.
            </exception>
            <exception cref="T:System.OperationCanceledException">
            The <paramref name="cancellationToken"/> was canceled.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromResult``1(``0)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task`1"/> that's completed successfully with the specified result.</summary>
            <typeparam name="TResult">The type of the result returned by the task.</typeparam>
            <param name="result">The result to store into the completed task.</param>
            <returns>The successfully completed task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromException(System.Exception)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task`1"/> that's completed exceptionally with the specified exception.</summary>
            <param name="exception">The exception with which to complete the task.</param>
            <returns>The faulted task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task`1"/> that's completed exceptionally with the specified exception.</summary>
            <typeparam name="TResult">The type of the result returned by the task.</typeparam>
            <param name="exception">The exception with which to complete the task.</param>
            <returns>The faulted task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task"/> that's completed due to cancellation with the specified token.</summary>
            <param name="cancellationToken">The token with which to complete the task.</param>
            <returns>The canceled task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task`1"/> that's completed due to cancellation with the specified token.</summary>
            <typeparam name="TResult">The type of the result returned by the task.</typeparam>
            <param name="cancellationToken">The token with which to complete the task.</param>
            <returns>The canceled task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromCanceled(System.OperationCanceledException)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task"/> that's completed due to cancellation with the specified exception.</summary>
            <param name="exception">The exception with which to complete the task.</param>
            <returns>The canceled task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromCanceled``1(System.OperationCanceledException)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task`1"/> that's completed due to cancellation with the specified exception.</summary>
            <typeparam name="TResult">The type of the result returned by the task.</typeparam>
            <param name="exception">The exception with which to complete the task.</param>
            <returns>The canceled task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run(System.Action)">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a Task handle for that work.
            </summary>
            <param name="action">The work to execute asynchronously</param>
            <returns>A Task that represents the work queued to execute in the ThreadPool.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> parameter was null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a Task handle for that work.
            </summary>
            <param name="action">The work to execute asynchronously</param>
            <param name="cancellationToken">A cancellation token that should be used to cancel the work</param>
            <returns>A Task that represents the work queued to execute in the ThreadPool.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="action"/> parameter was null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.CancellationTokenSource"/> associated with <paramref name="cancellationToken"/> was disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a Task(TResult) handle for that work.
            </summary>
            <param name="function">The work to execute asynchronously</param>
            <returns>A Task(TResult) that represents the work queued to execute in the ThreadPool.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="function"/> parameter was null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a Task(TResult) handle for that work.
            </summary>
            <param name="function">The work to execute asynchronously</param>
            <param name="cancellationToken">A cancellation token that should be used to cancel the work</param>
            <returns>A Task(TResult) that represents the work queued to execute in the ThreadPool.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="function"/> parameter was null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.CancellationTokenSource"/> associated with <paramref name="cancellationToken"/> was disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a proxy for the
            Task returned by <paramref name="function"/>.
            </summary>
            <param name="function">The work to execute asynchronously</param>
            <returns>A Task that represents a proxy for the Task returned by <paramref name="function"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="function"/> parameter was null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a proxy for the
            Task returned by <paramref name="function"/>.
            </summary>
            <param name="function">The work to execute asynchronously</param>
            <param name="cancellationToken">A cancellation token that should be used to cancel the work</param>
            <returns>A Task that represents a proxy for the Task returned by <paramref name="function"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="function"/> parameter was null.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The <see cref="T:System.CancellationTokenSource"/> associated with <paramref name="cancellationToken"/> was disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a proxy for the
            Task(TResult) returned by <paramref name="function"/>.
            </summary>
            <typeparam name="TResult">The type of the result returned by the proxy Task.</typeparam>
            <param name="function">The work to execute asynchronously</param>
            <returns>A Task(TResult) that represents a proxy for the Task(TResult) returned by <paramref name="function"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="function"/> parameter was null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Queues the specified work to run on the ThreadPool and returns a proxy for the
            Task(TResult) returned by <paramref name="function"/>.
            </summary>
            <typeparam name="TResult">The type of the result returned by the proxy Task.</typeparam>
            <param name="function">The work to execute asynchronously</param>
            <param name="cancellationToken">A cancellation token that should be used to cancel the work</param>
            <returns>A Task(TResult) that represents a proxy for the Task(TResult) returned by <paramref name="function"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="function"/> parameter was null.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
            <summary>
            Creates a Task that will complete after a time delay.
            </summary>
            <param name="delay">The time span to wait before completing the returned Task</param>
            <returns>A Task that represents the time delay</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="delay"/> is less than -1 or greater than int.MaxValue.
            </exception>
            <remarks>
            After the specified time delay, the Task is completed in RanToCompletion state.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Creates a Task that will complete after a time delay.
            </summary>
            <param name="delay">The time span to wait before completing the returned Task</param>
            <param name="cancellationToken">The cancellation token that will be checked prior to completing the returned Task</param>
            <returns>A Task that represents the time delay</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="delay"/> is less than -1 or greater than int.MaxValue.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The provided <paramref name="cancellationToken"/> has already been disposed.
            </exception>        
            <remarks>
            If the cancellation token is signaled before the specified time delay, then the Task is completed in
            Canceled state.  Otherwise, the Task is completed in RanToCompletion state once the specified time
            delay has expired.
            </remarks>        
        </member>
        <member name="M:System.Threading.Tasks.Task.Delay(System.Int32)">
            <summary>
            Creates a Task that will complete after a time delay.
            </summary>
            <param name="millisecondsDelay">The number of milliseconds to wait before completing the returned Task</param>
            <returns>A Task that represents the time delay</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="millisecondsDelay"/> is less than -1.
            </exception>
            <remarks>
            After the specified time delay, the Task is completed in RanToCompletion state.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Creates a Task that will complete after a time delay.
            </summary>
            <param name="millisecondsDelay">The number of milliseconds to wait before completing the returned Task</param>
            <param name="cancellationToken">The cancellation token that will be checked prior to completing the returned Task</param>
            <returns>A Task that represents the time delay</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="millisecondsDelay"/> is less than -1.
            </exception>
            <exception cref="T:System.ObjectDisposedException">
            The provided <paramref name="cancellationToken"/> has already been disposed.
            </exception>        
            <remarks>
            If the cancellation token is signaled before the specified time delay, then the Task is completed in
            Canceled state.  Otherwise, the Task is completed in RanToCompletion state once the specified time
            delay has expired.
            </remarks>        
        </member>
        <member name="T:System.Threading.Tasks.Task.DelayPromise">
            <summary>Task that also stores the completion closure and logic for Task.Delay implementation.</summary>
        </member>
        <member name="T:System.Threading.Tasks.Task.DelayPromiseWithCancellation">
            <summary>DelayPromise that also supports cancellation.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            Creates a task that will complete when all of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of all of the supplied tasks.</returns>
            <remarks>
            <para>
            If any of the supplied tasks completes in a faulted state, the returned task will also complete in a Faulted state, 
            where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.  
            </para>
            <para>
            If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the Canceled state.
            </para>
            <para>
            If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the RanToCompletion state.   
            </para>
            <para>
            If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a RanToCompletion 
            state before it's returned to the caller.  
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> collection contained a null task.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
            <summary>
            Creates a task that will complete when all of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of all of the supplied tasks.</returns>
            <remarks>
            <para>
            If any of the supplied tasks completes in a faulted state, the returned task will also complete in a Faulted state, 
            where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.  
            </para>
            <para>
            If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the Canceled state.
            </para>
            <para>
            If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the RanToCompletion state.   
            </para>
            <para>
            If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a RanToCompletion 
            state before it's returned to the caller.  
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> array contained a null task.
            </exception>
        </member>
        <member name="F:System.Threading.Tasks.Task.WhenAllPromise.m_tasks">
            <summary>
            Stores all of the constituent tasks.  Tasks clear themselves out of this
            array as they complete, but only if they don't have their wait notification bit set.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.Task.WhenAllPromise.m_count">
            <summary>The number of tasks remaining to complete.</summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.WhenAllPromise.ShouldNotifyDebuggerOfWaitCompletion">
            <summary>
            Returns whether we should notify the debugger of a wait completion.  This returns 
            true iff at least one constituent task has its bit set.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <summary>
            Creates a task that will complete when all of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of all of the supplied tasks.</returns>
            <remarks>
            <para>
            If any of the supplied tasks completes in a faulted state, the returned task will also complete in a Faulted state, 
            where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.  
            </para>
            <para>
            If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the Canceled state.
            </para>
            <para>
            If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the RanToCompletion state.  
            The Result of the returned task will be set to an array containing all of the results of the 
            supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output 
            task's Result will return an TResult[] where arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result). 
            </para>
            <para>
            If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a RanToCompletion 
            state before it's returned to the caller.  The returned TResult[] will be an array of 0 elements.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> collection contained a null task.
            </exception>       
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
            <summary>
            Creates a task that will complete when all of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of all of the supplied tasks.</returns>
            <remarks>
            <para>
            If any of the supplied tasks completes in a faulted state, the returned task will also complete in a Faulted state, 
            where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.  
            </para>
            <para>
            If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the Canceled state.
            </para>
            <para>
            If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the RanToCompletion state.  
            The Result of the returned task will be set to an array containing all of the results of the 
            supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output 
            task's Result will return an TResult[] where arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result). 
            </para>
            <para>
            If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a RanToCompletion 
            state before it's returned to the caller.  The returned TResult[] will be an array of 0 elements.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> array contained a null task.
            </exception>
        </member>
        <member name="F:System.Threading.Tasks.Task.WhenAllPromise`1.m_tasks">
            <summary>
            Stores all of the constituent tasks.  Tasks clear themselves out of this
            array as they complete, but only if they don't have their wait notification bit set.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.Task.WhenAllPromise`1.m_count">
            <summary>The number of tasks remaining to complete.</summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.WhenAllPromise`1.ShouldNotifyDebuggerOfWaitCompletion">
            <summary>
            Returns whether we should notify the debugger of a wait completion.  This returns true
            iff at least one constituent task has its bit set.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
            <summary>
            Creates a task that will complete when any of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of one of the supplied tasks.  The return Task's Result is the task that completed.</returns>
            <remarks>
            The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the RanToCompletion state 
            with its Result set to the first task to complete.  This is true even if the first task to complete ended in the Canceled or Faulted state.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> array contained a null task, or was empty.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            Creates a task that will complete when any of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of one of the supplied tasks.  The return Task's Result is the task that completed.</returns>
            <remarks>
            The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the RanToCompletion state 
            with its Result set to the first task to complete.  This is true even if the first task to complete ended in the Canceled or Faulted state.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> collection contained a null task, or was empty.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
            <summary>
            Creates a task that will complete when any of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of one of the supplied tasks.  The return Task's Result is the task that completed.</returns>
            <remarks>
            The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the RanToCompletion state 
            with its Result set to the first task to complete.  This is true even if the first task to complete ended in the Canceled or Faulted state.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> array contained a null task, or was empty.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <summary>
            Creates a task that will complete when any of the supplied tasks have completed.
            </summary>
            <param name="tasks">The tasks to wait on for completion.</param>
            <returns>A task that represents the completion of one of the supplied tasks.  The return Task's Result is the task that completed.</returns>
            <remarks>
            The returned task will complete when any of the supplied tasks has completed.  The returned task will always end in the RanToCompletion state 
            with its Result set to the first task to complete.  This is true even if the first task to complete ended in the Canceled or Faulted state.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="tasks"/> argument was null.
            </exception>
            <exception cref="T:System.ArgumentException">
            The <paramref name="tasks"/> collection contained a null task, or was empty.
            </exception>
        </member>
        <member name="T:System.Threading.Tasks.TaskCreationOptions">
            <summary>
            Specifies flags that control optional behavior for the creation and execution of tasks.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.None">
            <summary>
            Specifies that the default behavior should be used.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.PreferFairness">
            <summary>
            A hint to a <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> to schedule a
            task in as fair a manner as possible, meaning that tasks scheduled sooner will be more likely to
            be run sooner, and tasks scheduled later will be more likely to be run later.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.LongRunning">
            <summary>
            Specifies that a task will be a long-running, course-grained operation. It provides a hint to the
            <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> that oversubscription may be
            warranted. 
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.AttachedToParent">
            <summary>
            Specifies that a task is attached to a parent in the task hierarchy.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach">
            <summary>
            Specifies that an InvalidOperationException will be thrown if an attempt is made to attach a child task to the created task.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.HideScheduler">
            <summary>
            Prevents the ambient scheduler from being seen as the current scheduler in the created task.  This means that operations
            like StartNew or ContinueWith that are performed in the created task will see TaskScheduler.Default as the current scheduler.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskCreationOptions.RunContinuationsAsynchronously">
            <summary>
            Forces continuations added to the current task to be executed asynchronously.
            This option has precedence over TaskContinuationOptions.ExecuteSynchronously
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.InternalTaskOptions">
            <summary>
            Task creation flags which are only used internally.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.InternalTaskOptions.None">
            <summary> Specifies "No internal task options" </summary>
        </member>
        <member name="F:System.Threading.Tasks.InternalTaskOptions.InternalOptionsMask">
            <summary>Used to filter out internal vs. public task creation options.</summary>
        </member>
        <member name="F:System.Threading.Tasks.InternalTaskOptions.LazyCancellation">
            <summary>
            Store the presence of TaskContinuationOptions.LazyCancellation, since it does not directly
            translate into any TaskCreationOptions.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.InternalTaskOptions.QueuedByRuntime">
            <summary>Specifies that the task will be queued by the runtime before handing it over to the user. 
            This flag will be used to skip the cancellationtoken registration step, which is only meant for unstarted tasks.</summary>
        </member>
        <member name="F:System.Threading.Tasks.InternalTaskOptions.DoNotDispose">
            <summary>
            Denotes that Dispose should be a complete nop for a Task.  Used when constructing tasks that are meant to be cached/reused.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskContinuationOptions">
            <summary>
            Specifies flags that control optional behavior for the creation and execution of continuation tasks.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.None">
            <summary>
            Default = "Continue on any, no task options, run asynchronously"
            Specifies that the default behavior should be used.  Continuations, by default, will
            be scheduled when the antecedent task completes, regardless of the task's final <see
            cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see>.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.PreferFairness">
            <summary>
            A hint to a <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> to schedule a
            task in as fair a manner as possible, meaning that tasks scheduled sooner will be more likely to
            be run sooner, and tasks scheduled later will be more likely to be run later.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.LongRunning">
            <summary>
            Specifies that a task will be a long-running, course-grained operation.  It provides
            a hint to the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> that
            oversubscription may be warranted.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent">
            <summary>
            Specifies that a task is attached to a parent in the task hierarchy.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.DenyChildAttach">
            <summary>
            Specifies that an InvalidOperationException will be thrown if an attempt is made to attach a child task to the created task.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.HideScheduler">
            <summary>
            Prevents the ambient scheduler from being seen as the current scheduler in the created task.  This means that operations
            like StartNew or ContinueWith that are performed in the created task will see TaskScheduler.Default as the current scheduler.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.LazyCancellation">
            <summary>
            In the case of continuation cancellation, prevents completion of the continuation until the antecedent has completed.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.NotOnRanToCompletion">
            <summary>
            Specifies that the continuation task should not be scheduled if its antecedent ran to completion.
            This option is not valid for multi-task continuations.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted">
            <summary>
            Specifies that the continuation task should not be scheduled if its antecedent threw an unhandled
            exception. This option is not valid for multi-task continuations.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled">
            <summary>
            Specifies that the continuation task should not be scheduled if its antecedent was canceled. This
            option is not valid for multi-task continuations.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion">
            <summary>
            Specifies that the continuation task should be scheduled only if its antecedent ran to
            completion. This option is not valid for multi-task continuations.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted">
            <summary>
            Specifies that the continuation task should be scheduled only if its antecedent threw an
            unhandled exception. This option is not valid for multi-task continuations.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled">
            <summary>
            Specifies that the continuation task should be scheduled only if its antecedent was canceled.
            This option is not valid for multi-task continuations.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously">
            <summary>
            Specifies that the continuation task should be executed synchronously. With this option
            specified, the continuation will be run on the same thread that causes the antecedent task to
            transition into its final state. If the antecedent is already complete when the continuation is
            created, the continuation will run on the thread creating the continuation.  Only very
            short-running continuations should be executed synchronously.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.ITaskCompletionAction.Invoke(System.Threading.Tasks.Task)">
            <summary>Invoked to run the completion action.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ITaskCompletionAction.InvokeMayRunArbitraryCode">
            <summary>
            Some completion actions are considered internal implementation details of tasks,
            using the continuation mechanism only for performance reasons.  Such actions perform
            known quantities and types of work, and can be invoked safely as a continuation even
            if the system wants to prevent arbitrary continuations from running synchronously.
            This should only return false for a limited set of implementations where a small amount
            of work is guaranteed to be performed, e.g. setting a ManualResetEventSlim.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.UnwrapPromise`1.InvokeCore(System.Threading.Tasks.Task)">
            <summary>
            Processes the completed task. InvokeCore could be called twice:
            once for the outer task, once for the inner task.
            </summary>
            <param name="completingTask">The completing outer or inner task.</param>
        </member>
        <member name="M:System.Threading.Tasks.UnwrapPromise`1.ProcessCompletedOuterTask(System.Threading.Tasks.Task)">
            <summary>Processes the outer task once it's completed.</summary>
            <param name="task">The now-completed outer task.</param>
        </member>
        <member name="M:System.Threading.Tasks.UnwrapPromise`1.TrySetFromTask(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Transfer the completion status from "task" to ourself.</summary>
            <param name="task">The source task whose results should be transfered to this.</param>
            <param name="lookForOce">Whether or not to look for OperationCanceledExceptions in task's exceptions if it faults.</param>
            <returns>true if the transfer was successful; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.UnwrapPromise`1.ProcessInnerTask(System.Threading.Tasks.Task)">
            <summary>
            Processes the inner task of a Task{Task} or Task{Task{TResult}}, 
            transferring the appropriate results to ourself.
            </summary>
            <param name="task">The inner task returned by the task provided by the user.</param>
        </member>
        <member name="T:System.Threading.Tasks.TaskAsyncEnumerableExtensions">
            <summary>Provides a set of static methods for configuring <see cref="T:System.Threading.Tasks.Task"/>-related behaviors on asynchronous enumerables and disposables.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait(System.IAsyncDisposable,System.Boolean)">
            <summary>Configures how awaits on the tasks returned from an async disposable will be performed.</summary>
            <param name="source">The source async disposable.</param>
            <param name="continueOnCapturedContext">Whether to capture and marshal back to the current context.</param>
            <returns>The configured async disposable.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean)">
            <summary>Configures how awaits on the tasks returned from an async iteration will be performed.</summary>
            <typeparam name="T">The type of the objects being iterated.</typeparam>
            <param name="source">The source enumerable being iterated.</param>
            <param name="continueOnCapturedContext">Whether to capture and marshal back to the current context.</param>
            <returns>The configured enumerable.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Sets the <see cref="T:System.Threading.CancellationToken"/> to be passed to <see cref="M:System.Collections.Generic.IAsyncEnumerable`1.GetAsyncEnumerator(System.Threading.CancellationToken)"/> when iterating.</summary>
            <typeparam name="T">The type of the objects being iterated.</typeparam>
            <param name="source">The source enumerable being iterated.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to use.</param>
            <returns>The configured enumerable.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskCanceledException">
            <summary>
            Represents an exception used to communicate task cancellation.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/> class.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/>
            class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/>
            class with a specified error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.String,System.Exception,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/>
            class with a specified error message, a reference to the inner exception that is the cause of
            this exception, and the <see cref="T:System.Threading.CancellationToken"/> that triggered the cancellation.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            <param name="token">The <see cref="T:System.Threading.CancellationToken"/> that triggered the cancellation.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/> class
            with a reference to the <see cref="T:System.Threading.Tasks.Task"/> that has been canceled.
            </summary>
            <param name="task">A task that has been canceled.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCanceledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskCanceledException"/>
            class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param>
        </member>
        <member name="P:System.Threading.Tasks.TaskCanceledException.Task">
            <summary>
            Gets the task associated with this exception.
            </summary>
            <remarks>
            It is permissible for no Task to be associated with a 
            <see cref="T:System.Threading.Tasks.TaskCanceledException"/>, in which case
            this property will return null.
            </remarks>
        </member>
        <member name="T:System.Threading.Tasks.TaskCompletionSource`1">
            <summary>
            Represents the producer side of a <see cref="T:System.Threading.Tasks.Task{TResult}"/> unbound to a
            delegate, providing access to the consumer side through the <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> property.
            </summary>
            <remarks>
            <para>
            It is often the case that a <see cref="T:System.Threading.Tasks.Task{TResult}"/> is desired to
            represent another asynchronous operation.
            <see cref="T:System.Threading.Tasks.TaskCompletionSource`1">TaskCompletionSource</see> is provided for this purpose. It enables
            the creation of a task that can be handed out to consumers, and those consumers can use the members
            of the task as they would any other. However, unlike most tasks, the state of a task created by a
            TaskCompletionSource is controlled explicitly by the methods on TaskCompletionSource. This enables the
            completion of the external asynchronous operation to be propagated to the underlying Task. The
            separation also ensures that consumers are not able to transition the state without access to the
            corresponding TaskCompletionSource.
            </para>
            <para>
            All members of <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> are thread-safe
            and may be used from multiple threads concurrently.
            </para>
            </remarks>
            <typeparam name="TResult">The type of the result value associated with this <see
            cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>
            with the specified options.
            </summary>
            <remarks>
            The <see cref="T:System.Threading.Tasks.Task{TResult}"/> created
            by this instance and accessible through its <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> property
            will be instantiated using the specified <paramref name="creationOptions"/>.
            </remarks>
            <param name="creationOptions">The options to use when creating the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> represent options invalid for use
            with a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>
            with the specified state.
            </summary>
            <param name="state">The state to use as the underlying 
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>'s AsyncState.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> with
            the specified state and options.
            </summary>
            <param name="creationOptions">The options to use when creating the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">The state to use as the underlying 
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>'s AsyncState.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> represent options invalid for use
            with a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.
            </exception>
        </member>
        <member name="P:System.Threading.Tasks.TaskCompletionSource`1.Task">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.Task{TResult}"/> created
            by this <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.
            </summary>
            <remarks>
            This property enables a consumer access to the <see
            cref="T:System.Threading.Tasks.Task{TResult}"/> that is controlled by this instance.
            The <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)"/>, <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)"/>,
            <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})"/>, and <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled"/>
            methods (and their "Try" variants) on this instance all result in the relevant state
            transitions on this underlying Task.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SpinUntilCompleted">
            <summary>Spins until the underlying task is completed.</summary>
            <remarks>This should only be called if the task is in the process of being completed by another thread.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)">
            <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
            <param name="exception">The exception to bind to this <see 
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="exception"/> argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
            <param name="exceptions">The collection of exceptions to bind to this <see 
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The <paramref name="exceptions"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">There are one or more null elements in <paramref name="exceptions"/>.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="exceptions"/> collection is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)">
            <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
            <param name="exception">The exception to bind to this <see 
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="exception"/> argument is null.</exception>
            <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>
            state.
            </summary>
            <param name="exceptions">The collection of exceptions to bind to this <see 
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="exceptions"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">There are one or more null elements in <paramref name="exceptions"/>.</exception>
            <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)">
            <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>
            state.
            </summary>
            <param name="result">The result value to bind to this <see 
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)">
            <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>
            state.
            </summary>
            <param name="result">The result value to bind to this <see 
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled">
            <summary>
            Attempts to transition the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>
            state.
            </summary>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <remarks>This operation will return false if the 
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled">
            <summary>
            Transitions the underlying
            <see cref="T:System.Threading.Tasks.Task{TResult}"/> into the 
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>
            state.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The underlying <see cref="T:System.Threading.Tasks.Task{TResult}"/> is already in one
            of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion">RanToCompletion</see>, 
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted">Faulted</see>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled">Canceled</see>.
            </exception>
            <exception cref="T:System.ObjectDisposedException">The <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> was disposed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.ContinuationTaskFromTask.InnerInvoke">
            <summary>
            Evaluates the value selector of the Task which is passed in as an object and stores the result.
            </summary>        
        </member>
        <member name="M:System.Threading.Tasks.ContinuationResultTaskFromTask`1.InnerInvoke">
            <summary>
            Evaluates the value selector of the Task which is passed in as an object and stores the result.
            </summary>        
        </member>
        <member name="M:System.Threading.Tasks.ContinuationTaskFromResultTask`1.InnerInvoke">
            <summary>
            Evaluates the value selector of the Task which is passed in as an object and stores the result.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.ContinuationResultTaskFromResultTask`2.InnerInvoke">
            <summary>
            Evaluates the value selector of the Task which is passed in as an object and stores the result.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskContinuation">
            <summary>Represents a continuation.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskContinuation.Run(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Inlines or schedules the continuation.</summary>
            <param name="completedTask">The antecedent task that has completed.</param>
            <param name="canInlineContinuationTask">true if inlining is permitted; otherwise, false.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskContinuation.InlineIfPossibleOrElseQueue(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to run the task on the current thread, if possible; otherwise, schedules it.</summary>
            <param name="task">The task to run</param>
            <param name="needsProtection">
            true if we need to protect against multiple threads racing to start/cancel the task; otherwise, false.
            </param>
        </member>
        <member name="T:System.Threading.Tasks.StandardTaskContinuation">
            <summary>Provides the standard implementation of a task continuation.</summary>
        </member>
        <member name="F:System.Threading.Tasks.StandardTaskContinuation.m_task">
            <summary>The unstarted continuation task.</summary>
        </member>
        <member name="F:System.Threading.Tasks.StandardTaskContinuation.m_options">
            <summary>The options to use with the continuation task.</summary>
        </member>
        <member name="F:System.Threading.Tasks.StandardTaskContinuation.m_taskScheduler">
            <summary>The task scheduler with which to run the continuation task.</summary>
        </member>
        <member name="M:System.Threading.Tasks.StandardTaskContinuation.#ctor(System.Threading.Tasks.Task,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>Initializes a new continuation.</summary>
            <param name="task">The task to be activated.</param>
            <param name="options">The continuation options.</param>
            <param name="scheduler">The scheduler to use for the continuation.</param>
        </member>
        <member name="M:System.Threading.Tasks.StandardTaskContinuation.Run(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Invokes the continuation for the target completion task.</summary>
            <param name="completedTask">The completed task.</param>
            <param name="canInlineContinuationTask">Whether the continuation can be inlined.</param>
        </member>
        <member name="T:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation">
            <summary>Task continuation for awaiting with a current synchronization context.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.s_postCallback">
            <summary>SendOrPostCallback delegate to invoke the action.</summary>
        </member>
        <member name="F:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.s_postActionCallback">
            <summary>Cached delegate for PostAction</summary>
        </member>
        <member name="F:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.m_syncContext">
            <summary>The context with which to run the action.</summary>
        </member>
        <member name="M:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.#ctor(System.Threading.SynchronizationContext,System.Action,System.Boolean)">
            <summary>Initializes the SynchronizationContextAwaitTaskContinuation.</summary>
            <param name="context">The synchronization context with which to invoke the action.  Must not be null.</param>
            <param name="action">The action to invoke. Must not be null.</param>
            <param name="flowExecutionContext">Whether to capture and restore ExecutionContext.</param>
        </member>
        <member name="M:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.Run(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Inlines or schedules the continuation.</summary>
            <param name="task">The antecedent task, which is ignored.</param>
            <param name="canInlineContinuationTask">true if inlining is permitted; otherwise, false.</param>
        </member>
        <member name="M:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.PostAction(System.Object)">
            <summary>Calls InvokeOrPostAction(false) on the supplied SynchronizationContextAwaitTaskContinuation.</summary>
            <param name="state">The SynchronizationContextAwaitTaskContinuation.</param>
        </member>
        <member name="M:System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.GetPostActionCallback">
            <summary>Gets a cached delegate for the PostAction method.</summary>
            <returns>
            A delegate for PostAction, which expects a SynchronizationContextAwaitTaskContinuation 
            to be passed as state.
            </returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation">
            <summary>Task continuation for awaiting with a task scheduler.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation.m_scheduler">
            <summary>The scheduler on which to run the action.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation.#ctor(System.Threading.Tasks.TaskScheduler,System.Action,System.Boolean)">
            <summary>Initializes the TaskSchedulerAwaitTaskContinuation.</summary>
            <param name="scheduler">The task scheduler with which to invoke the action.  Must not be null.</param>
            <param name="action">The action to invoke. Must not be null.</param>
            <param name="flowExecutionContext">Whether to capture and restore ExecutionContext.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation.Run(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Inlines or schedules the continuation.</summary>
            <param name="ignored">The antecedent task, which is ignored.</param>
            <param name="canInlineContinuationTask">true if inlining is permitted; otherwise, false.</param>
        </member>
        <member name="T:System.Threading.Tasks.AwaitTaskContinuation">
            <summary>Base task continuation class used for await continuations.</summary>
        </member>
        <member name="F:System.Threading.Tasks.AwaitTaskContinuation.m_capturedContext">
            <summary>The ExecutionContext with which to run the continuation.</summary>
        </member>
        <member name="F:System.Threading.Tasks.AwaitTaskContinuation.m_action">
            <summary>The action to invoke.</summary>
        </member>
        <member name="M:System.Threading.Tasks.AwaitTaskContinuation.#ctor(System.Action,System.Boolean)">
            <summary>Initializes the continuation.</summary>
            <param name="action">The action to invoke. Must not be null.</param>
            <param name="flowExecutionContext">Whether to capture and restore ExecutionContext.</param>
        </member>
        <member name="M:System.Threading.Tasks.AwaitTaskContinuation.CreateTask(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
            <summary>Creates a task to run the action with the specified state on the specified scheduler.</summary>
            <param name="action">The action to run. Must not be null.</param>
            <param name="state">The state to pass to the action. Must not be null.</param>
            <param name="scheduler">The scheduler to target.</param>
            <returns>The created task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.AwaitTaskContinuation.Run(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Inlines or schedules the continuation onto the default scheduler.</summary>
            <param name="task">The antecedent task, which is ignored.</param>
            <param name="canInlineContinuationTask">true if inlining is permitted; otherwise, false.</param>
        </member>
        <member name="P:System.Threading.Tasks.AwaitTaskContinuation.IsValidLocationForInlining">
            <summary>
            Gets whether the current thread is an appropriate location to inline a continuation's execution.
            </summary>
            <remarks>
            Returns whether SynchronizationContext is null and we're in the default scheduler.
            If the await had a SynchronizationContext/TaskScheduler where it began and the 
            default/ConfigureAwait(true) was used, then we won't be on this path.  If, however, 
            ConfigureAwait(false) was used, or the SynchronizationContext and TaskScheduler were 
            naturally null/Default, then we might end up here.  If we do, we need to make sure
            that we don't execute continuations in a place that isn't set up to handle them, e.g.
            running arbitrary amounts of code on the UI thread.  It would be "correct", but very
            expensive, to always run the continuations asynchronously, incurring lots of context
            switches and allocations and locks and the like.  As such, we employ the heuristic
            that if the current thread has a non-null SynchronizationContext or a non-default
            scheduler, then we better not run arbitrary continuations here.
            </remarks>
        </member>
        <member name="F:System.Threading.Tasks.AwaitTaskContinuation.s_invokeContextCallback">
            <summary>Cached delegate that invokes an Action passed as an object parameter.</summary>
        </member>
        <member name="M:System.Threading.Tasks.AwaitTaskContinuation.RunCallback(System.Threading.ContextCallback,System.Object,System.Threading.Tasks.Task@)">
            <summary>Runs the callback synchronously with the provided state.</summary>
            <param name="callback">The callback to run.</param>
            <param name="state">The state to pass to the callback.</param>
            <param name="currentTask">A reference to Task.t_currentTask.</param>
        </member>
        <member name="M:System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action,System.Boolean)">
            <summary>Invokes or schedules the action to be executed.</summary>
            <param name="action">The action to invoke or queue.</param>
            <param name="allowInlining">
            true to allow inlining, or false to force the action to run asynchronously.
            </param>
            <remarks>
            No ExecutionContext work is performed used.  This method is only used in the
            case where a raw Action continuation delegate was stored into the Task, which
            only happens in Task.SetContinuationForAwait if execution context flow was disabled
            via using TaskAwaiter.UnsafeOnCompleted or a similar path.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Runtime.CompilerServices.IAsyncStateMachineBox,System.Boolean)">
            <summary>Invokes or schedules the action to be executed.</summary>
            <param name="box">The <see cref="T:System.Runtime.CompilerServices.IAsyncStateMachineBox"/> that needs to be invoked or queued.</param>
            <param name="allowInlining">
            true to allow inlining, or false to force the box's action to run asynchronously.
            </param>
        </member>
        <member name="M:System.Threading.Tasks.AwaitTaskContinuation.UnsafeScheduleAction(System.Action,System.Threading.Tasks.Task)">
            <summary>Schedules the action to be executed.  No ExecutionContext work is performed used.</summary>
            <param name="action">The action to invoke or queue.</param>
            <param name="task">The task scheduling the action.</param>
        </member>
        <member name="T:System.Threading.Tasks.TaskExceptionHolder">
            <summary>
            An exception holder manages a list of exceptions for one particular task.
            It offers the ability to aggregate, but more importantly, also offers intrinsic
            support for propagating unhandled exceptions that are never observed. It does
            this by aggregating and calling UnobservedTaskException event event if the holder 
            is ever GC'd without the holder's contents ever having been requested 
            (e.g. by a Task.Wait, Task.get_Exception, etc).
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskExceptionHolder.m_task">
            <summary>The task with which this holder is associated.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskExceptionHolder.m_faultExceptions">
            <summary>
            The lazily-initialized list of faulting exceptions.  Volatile
            so that it may be read to determine whether any exceptions were stored.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskExceptionHolder.m_cancellationException">
            <summary>An exception that triggered the task to cancel.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskExceptionHolder.m_isHandled">
            <summary>Whether the holder was "observed" and thus doesn't cause finalization behavior.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Creates a new holder; it will be registered for finalization.
            </summary>
            <param name="task">The task this holder belongs to.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.Finalize">
            <summary>
            A finalizer that repropagates unhandled exceptions.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskExceptionHolder.ContainsFaultList">
            <summary>Gets whether the exception holder is currently storing any exceptions for faults.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.Add(System.Object,System.Boolean)">
            <summary>
            Add an exception to the holder.  This will ensure the holder is
            in the proper state (handled/unhandled) depending on the list's contents.
            </summary>
            <param name="representsCancellation">
            Whether the exception represents a cancellation request (true) or a fault (false).
            </param>
            <param name="exceptionObject">
            An exception object (either an Exception, an ExceptionDispatchInfo,
            an IEnumerable{Exception}, or an IEnumerable{ExceptionDispatchInfo}) 
            to add to the list.
            </param>
            <remarks>
            Must be called under lock.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.SetCancellationException(System.Object)">
            <summary>Sets the cancellation exception.</summary>
            <param name="exceptionObject">The cancellation exception.</param>
            <remarks>
            Must be called under lock.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.AddFaultException(System.Object)">
            <summary>Adds the exception to the fault list.</summary>
            <param name="exceptionObject">The exception to store.</param>
            <remarks>
            Must be called under lock.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.MarkAsUnhandled">
            <summary>
            A private helper method that ensures the holder is considered
            unhandled, i.e. it is registered for finalization.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.MarkAsHandled(System.Boolean)">
            <summary>
            A private helper method that ensures the holder is considered
            handled, i.e. it is not registered for finalization.
            </summary>
            <param name="calledFromFinalizer">Whether this is called from the finalizer thread.</param> 
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.CreateExceptionObject(System.Boolean,System.Exception)">
            <summary>
            Allocates a new aggregate exception and adds the contents of the list to
            it. By calling this method, the holder assumes exceptions to have been
            "observed", such that the finalization check will be subsequently skipped.
            </summary>
            <param name="calledFromFinalizer">Whether this is being called from a finalizer.</param>
            <param name="includeThisException">An extra exception to be included (optionally).</param>
            <returns>The aggregate exception to throw.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.GetExceptionDispatchInfos">
            <summary>
            Wraps the exception dispatch infos into a new read-only collection. By calling this method, 
            the holder assumes exceptions to have been "observed", such that the finalization 
            check will be subsequently skipped.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskExceptionHolder.GetCancellationExceptionDispatchInfo">
            <summary>
            Gets the ExceptionDispatchInfo representing the singular exception 
            that was the cause of the task's cancellation.
            </summary>
            <returns>
            The ExceptionDispatchInfo for the cancellation exception.  May be null.
            </returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskExtensions">
            <summary>Provides a set of static methods for working with specific kinds of <see cref="T:System.Threading.Tasks.Task"/> instances.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})">
            <summary>Creates a proxy <see cref="T:System.Threading.Tasks.Task"/> that represents the asynchronous operation of a <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task`1"/> to unwrap.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> that represents the asynchronous operation of the provided <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})">
            <summary>Creates a proxy <see cref="T:System.Threading.Tasks.Task`1"/> that represents the asynchronous operation of a wrapped <see cref="T:System.Threading.Tasks.Task`1"/>.</summary>
            <param name="task">The wrapped <see cref="T:System.Threading.Tasks.Task`1"/> to unwrap.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> that represents the asynchronous operation of the provided wrapped <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskFactory">
            <summary>
            Provides support for creating and scheduling
            <see cref="T:System.Threading.Tasks.Task">Tasks</see>.
            </summary>
            <remarks>
            <para>
            There are many common patterns for which tasks are relevant. The <see cref="T:System.Threading.Tasks.TaskFactory"/>
            class encodes some of these patterns into methods that pick up default settings, which are
            configurable through its constructors.
            </para>
            <para>
            A default instance of <see cref="T:System.Threading.Tasks.TaskFactory"/> is available through the
            <see cref="P:System.Threading.Tasks.Task.Factory">Task.Factory</see> property.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.#ctor">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory"/> instance with the default configuration.
            </summary>
            <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory"/> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory"/> instance with the specified configuration.
            </summary>
            <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory"/> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
            <remarks>
            This constructor creates a <see cref="T:System.Threading.Tasks.TaskFactory"/> instance with a default configuration. The
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to the current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory"/> instance with the specified configuration.
            </summary>
            <param name="scheduler">
            The <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any tasks created with this TaskFactory. A null value
            indicates that the current TaskScheduler should be used.
            </param>
            <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to
            <see cref="F:System.Threading.Tasks.TaskCreationOptions.None">TaskCreationOptions.None</see>, the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <see
            cref="F:System.Threading.Tasks.TaskContinuationOptions.None">TaskContinuationOptions.None</see>,
            and the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is
            initialized to <paramref name="scheduler"/>, unless it's null, in which case the property is
            initialized to the current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory"/> instance with the specified configuration.
            </summary>
            <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory.
            </param>
            <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions"/> argument or the <paramref name="continuationOptions"/>
            argument specifies an invalid value.
            </exception>
            <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to <paramref name="creationOptions"/>,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <paramref
            name="continuationOptions"/>, and the <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to the
            current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Initializes a <see cref="T:System.Threading.Tasks.TaskFactory"/> instance with the specified configuration.
            </summary>
            <param name="cancellationToken">The default <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned 
            to tasks created by this <see cref="T:System.Threading.Tasks.TaskFactory"/> unless another CancellationToken is explicitly specified 
            while calling the factory methods.</param>
            <param name="creationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions">
            TaskCreationOptions</see> to use when creating tasks with this TaskFactory.
            </param>
            <param name="continuationOptions">
            The default <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> to use when creating continuation tasks with this TaskFactory.
            </param>
            <param name="scheduler">
            The default <see cref="T:System.Threading.Tasks.TaskScheduler">
            TaskScheduler</see> to use to schedule any Tasks created with this TaskFactory. A null value
            indicates that TaskScheduler.Current should be used.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The exception that is thrown when the
            <paramref name="creationOptions"/> argument or the <paramref name="continuationOptions"/>
            argumentspecifies an invalid value.
            </exception>
            <remarks>
            With this constructor, the
            <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> property is initialized to <paramref name="creationOptions"/>,
            the
            <see cref="T:System.Threading.Tasks.TaskContinuationOptions"/> property is initialized to <paramref
            name="continuationOptions"/>, and the <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> property is initialized to
            <paramref name="scheduler"/>, unless it's null, in which case the property is initialized to the
            current scheduler (see <see
            cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see>).
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory.CancellationToken">
            <summary>
            Gets the default <see cref="T:System.Threading.CancellationToken">CancellationToken</see> of this
            TaskFactory.
            </summary>
            <remarks>
            This property returns the default <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to all 
            tasks created by this factory unless another CancellationToken value is explicitly specified 
            during the call to the factory methods.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory.Scheduler">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> of this
            TaskFactory.
            </summary>
            <remarks>
            This property returns the default scheduler for this factory.  It will be used to schedule all 
            tasks unless another scheduler is explicitly specified during calls to this factory's methods.  
            If null, <see cref="P:System.Threading.Tasks.TaskScheduler.Current">TaskScheduler.Current</see> 
            will be used.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory.CreationOptions">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskCreationOptions
            </see> value of this TaskFactory.
            </summary>
            <remarks>
            This property returns the default creation options for this factory.  They will be used to create all 
            tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory.ContinuationOptions">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions">TaskContinuationOptions
            </see> value of this TaskFactory.
            </summary>
            <remarks>
            This property returns the default continuation options for this factory.  They will be used to create 
            all continuation tasks unless other options are explicitly specified during calls to this factory's methods.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action"/> 
            argument is null.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors 
            and then calling 
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.  However,
            unless creation and scheduling must be separated, StartNew is the recommended
            approach for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new task.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="action"/> 
            argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors 
            and then calling 
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.  However,
            unless creation and scheduling must be separated, StartNew is the recommended
            approach for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="action"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task"/></param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
            <param name="scheduler">The <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see
            cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="action"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="scheduler"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <param name="state">An object containing data to be used by the <paramref name="action"/>
            delegate.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="action"/>
            argument is null.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <param name="state">An object containing data to be used by the <paramref name="action"/>
            delegate.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task"/></param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="action"/>
            argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <param name="state">An object containing data to be used by the <paramref name="action"/>
            delegate.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="action"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task">Task</see>.
            </summary>
            <param name="action">The action delegate to execute asynchronously.</param>
            <param name="state">An object containing data to be used by the <paramref name="action"/>
            delegate.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task">Task.</see></param>
            <param name="scheduler">The <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see
            cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="action"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="scheduler"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a Task using one of its constructors and
            then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task"/></param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="scheduler">The <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="scheduler"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new <see cref="T:System.Threading.Tasks.Task"/></param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates and starts a <see cref="T:System.Threading.Tasks.Task{TResult}"/>.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="function">A function delegate that returns the future result to be available through
            the <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="state">An object containing data to be used by the <paramref name="function"/>
            delegate.</param>
            <param name="cancellationToken">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken"/> that will be assigned to the new task.</param>
            <param name="creationOptions">A TaskCreationOptions value that controls the behavior of the
            created
            <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <param name="scheduler">The <see
            cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created <see cref="T:System.Threading.Tasks.Task{TResult}">
            Task{TResult}</see>.</param>
            <returns>The started <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="function"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref
            name="scheduler"/>
            argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            Calling StartNew is functionally equivalent to creating a <see cref="T:System.Threading.Tasks.Task`1"/> using one
            of its constructors and then calling
            <see cref="M:System.Threading.Tasks.Task.Start">Start</see> to schedule it for execution.
            However, unless creation and scheduling must be separated, StartNew is the recommended approach
            for both simplicity and performance.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that executes an end method action
            when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The action delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the asynchronous
            operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that executes an end method action
            when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The action delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the asynchronous
            operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that executes an end method action
            when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The action delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the task that executes the end method.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the asynchronous
            operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg3">The third argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task">Task</see> that represents a pair of begin
            and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg3">The third argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task">Task</see> that represents the
            asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The function delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The function delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that executes an end
            method function when a specified <see cref="T:System.IAsyncResult">IAsyncResult</see> completes.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="asyncResult">The IAsyncResult whose completion should trigger the processing of the
            <paramref name="endMethod"/>.</param>
            <param name="endMethod">The function delegate that processes the completed <paramref
            name="asyncResult"/>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the task that executes the end method.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="asyncResult"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents the
            asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg3">The third argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that represents a pair of
            begin and end methods that conform to the Asynchronous Programming Model pattern.
            </summary>
            <typeparam name="TArg1">The type of the first argument passed to the <paramref
            name="beginMethod"/> delegate.</typeparam>
            <typeparam name="TArg2">The type of the second argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TArg3">The type of the third argument passed to <paramref name="beginMethod"/>
            delegate.</typeparam>
            <typeparam name="TResult">The type of the result available through the
            <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.
            </typeparam>
            <param name="beginMethod">The delegate that begins the asynchronous operation.</param>
            <param name="endMethod">The delegate that ends the asynchronous operation.</param>
            <param name="arg1">The first argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg2">The second argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="arg3">The third argument passed to the <paramref name="beginMethod"/>
            delegate.</param>
            <param name="creationOptions">The TaskCreationOptions value that controls the behavior of the
            created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="state">An object containing data to be used by the <paramref name="beginMethod"/>
            delegate.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="beginMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="endMethod"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="creationOptions"/> argument specifies an invalid TaskCreationOptions
            value.</exception>
            <returns>The created <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see> that
            represents the asynchronous operation.</returns>
            <remarks>
            This method throws any exceptions thrown by the <paramref name="beginMethod"/>.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.CheckFromAsyncOptions(System.Threading.Tasks.TaskCreationOptions,System.Boolean)">
            <summary>
            Check validity of options passed to FromAsync method
            </summary>
            <param name="creationOptions">The options to be validated.</param>
            <param name="hasBeginMethod">determines type of FromAsync method that called this method</param>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory.CompleteOnCountdownPromise.ShouldNotifyDebuggerOfWaitCompletion">
            <summary>
            Returns whether we should notify the debugger of a wait completion.  This returns 
            true iff at least one constituent task has its bit set.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskFactory.CompleteOnCountdownPromise`1.ShouldNotifyDebuggerOfWaitCompletion">
            <summary>
            Returns whether we should notify the debugger of a wait completion.  This returns 
            true iff at least one constituent task has its bit set.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks"/> array have completed.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in the <paramref
            name="tasks"/> array have completed.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in the <paramref
            name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks"/> array have completed.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see> 
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in 
            the <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the 
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the 
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in the <paramref
            name="tasks"/> array have completed.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationAction">The action delegate to execute when all tasks in the <paramref
            name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of a set of provided Tasks.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue.</param>
            <param name="continuationFunction">The function delegate to execute when all tasks in the
            <paramref name="tasks"/> array have completed.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAll.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.CommonCWAnyLogicCleanup(System.Threading.Tasks.Task{System.Threading.Tasks.Task})">
            <summary>
            Cleans up the operations performed by CommonCWAnyLogic in a case where
            the created continuation task is being discarded.
            </summary>
            <param name="continuation">The task returned from CommonCWAnyLogic.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the <paramref
            name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TResult">The type of the result that is returned by the <paramref
            name="continuationFunction"/>
            delegate and associated with the created <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</typeparam>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationFunction">The function delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task{TResult}">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task{TResult}"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationFunction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a continuation <see cref="T:System.Threading.Tasks.Task">Task</see>
            that will be started upon the completion of any Task in the provided set.
            </summary>
            <typeparam name="TAntecedentResult">The type of the result of the antecedent <paramref name="tasks"/>.</typeparam>
            <param name="tasks">The array of tasks from which to continue when one task completes.</param>
            <param name="continuationAction">The action delegate to execute when one task in the
            <paramref name="tasks"/> array completes.</param>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken">CancellationToken</see> 
            that will be assigned to the new continuation task.</param>
            <param name="continuationOptions">The <see cref="T:System.Threading.Tasks.TaskContinuationOptions">
            TaskContinuationOptions</see> value that controls the behavior of
            the created continuation <see cref="T:System.Threading.Tasks.Task">Task</see>.</param>
            <param name="scheduler">The <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            that is used to schedule the created continuation <see
            cref="T:System.Threading.Tasks.Task{TResult}"/>.</param>
            <returns>The new continuation <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="tasks"/> array is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="continuationAction"/> argument is null.</exception>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the
            <paramref name="scheduler"/> argument is null.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array contains a null value.</exception>
            <exception cref="T:System.ArgumentException">The exception that is thrown when the
            <paramref name="tasks"/> array is empty.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The exception that is thrown when the
            <paramref name="continuationOptions"/> argument specifies an invalid TaskContinuationOptions
            value.</exception>
            <exception cref="T:System.ObjectDisposedException">The provided <see cref="T:System.Threading.CancellationToken">CancellationToken</see>
            has already been disposed.
            </exception>
            <remarks>
            The NotOn* and OnlyOn* <see cref="T:System.Threading.Tasks.TaskContinuationOptions">TaskContinuationOptions</see>, 
            which constrain for which <see cref="T:System.Threading.Tasks.TaskStatus">TaskStatus</see> states a continuation 
            will be executed, are illegal with ContinueWhenAny.
            </remarks>
        </member>
        <member name="T:System.Threading.Tasks.TaskToApm">
            <summary>
            Provides support for efficiently using Tasks to implement the APM (Begin/End) pattern.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.Begin(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Marshals the Task as an IAsyncResult, using the supplied callback and state
            to implement the APM pattern.
            </summary>
            <param name="task">The Task to be marshaled.</param>
            <param name="callback">The callback to be invoked upon completion.</param>
            <param name="state">The state to be stored in the IAsyncResult.</param>
            <returns>An IAsyncResult to represent the task's asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.End(System.IAsyncResult)">
            <summary>Processes an IAsyncResult returned by Begin.</summary>
            <param name="asyncResult">The IAsyncResult to unwrap.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.End``1(System.IAsyncResult)">
            <summary>Processes an IAsyncResult returned by Begin.</summary>
            <param name="asyncResult">The IAsyncResult to unwrap.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.InvokeCallbackWhenTaskCompletes(System.Threading.Tasks.Task,System.AsyncCallback,System.IAsyncResult)">
            <summary>Invokes the callback asynchronously when the task has completed.</summary>
            <param name="antecedent">The Task to await.</param>
            <param name="callback">The callback to invoke when the Task completes.</param>
            <param name="asyncResult">The Task used as the IAsyncResult.</param>
        </member>
        <member name="T:System.Threading.Tasks.TaskToApm.TaskWrapperAsyncResult">
            <summary>
            Provides a simple IAsyncResult that wraps a Task.  This, in effect, allows
            for overriding what's seen for the CompletedSynchronously and AsyncState values.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskToApm.TaskWrapperAsyncResult.Task">
            <summary>The wrapped Task.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskToApm.TaskWrapperAsyncResult._state">
            <summary>The new AsyncState value.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskToApm.TaskWrapperAsyncResult._completedSynchronously">
            <summary>The new CompletedSynchronously value.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.TaskWrapperAsyncResult.#ctor(System.Threading.Tasks.Task,System.Object,System.Boolean)">
            <summary>Initializes the IAsyncResult with the Task to wrap and the overriding AsyncState and CompletedSynchronously values.</summary>
            <param name="task">The Task to wrap.</param>
            <param name="state">The new AsyncState value</param>
            <param name="completedSynchronously">The new CompletedSynchronously value.</param>
        </member>
        <member name="T:System.Threading.Tasks.TaskScheduler">
            <summary>
            Represents an abstract scheduler for tasks.
            </summary>
            <remarks>
            <para>
            <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> acts as the extension point for all 
            pluggable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and
            how scheduled tasks should be exposed to debuggers.
            </para>
            <para>
            All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler"/> type are thread-safe
            and may be used from multiple threads concurrently.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task">Task</see> to the scheduler.
            </summary>
            <remarks>
            <para>
            A class derived from <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>  
            implements this method to accept tasks being scheduled on the scheduler.
            A typical implementation would store the task in an internal data structure, which would
            be serviced by threads that would execute those tasks at some time in the future.
            </para>
            <para>
            This method is only meant to be called by the .NET Framework and
            should not be called directly by the derived class. This is necessary 
            for maintaining the consistency of the system.
            </para>
            </remarks>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task">Task</see> to be queued.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="task"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Determines whether the provided <see cref="T:System.Threading.Tasks.Task">Task</see>
            can be executed synchronously in this call, and if it can, executes it.
            </summary>
            <remarks>
            <para>
            A class derived from <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> implements this function to
            support inline execution of a task on a thread that initiates a wait on that task object. Inline
            execution is optional, and the request may be rejected by returning false. However, better
            scalability typically results the more tasks that can be inlined, and in fact a scheduler that
            inlines too little may be prone to deadlocks. A proper implementation should ensure that a
            request executing under the policies guaranteed by the scheduler can successfully inline. For
            example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that
            thread should succeed.
            </para>
            <para>
            If a scheduler decides to perform the inline execution, it should do so by calling to the base
            TaskScheduler's
            <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">TryExecuteTask</see> method with the provided task object, propagating
            the return value. It may also be appropriate for the scheduler to remove an inlined task from its
            internal data structures if it decides to honor the inlining request. Note, however, that under
            some circumstances a scheduler may be asked to inline a task that was not previously provided to
            it with the <see cref="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)"/> method.
            </para>
            <para>
            The derived scheduler is responsible for making sure that the calling thread is suitable for
            executing the given task as far as its own scheduling and execution policies are concerned.
            </para>
            </remarks>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task">Task</see> to be
            executed.</param>
            <param name="taskWasPreviouslyQueued">A Boolean denoting whether or not task has previously been
            queued. If this parameter is True, then the task may have been previously queued (scheduled); if
            False, then the task is known not to have been queued, and this call is being made in order to
            execute the task inline without queueing it.</param>
            <returns>A Boolean value indicating whether the task was executed inline.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="task"/> argument is
            null.</exception>
            <exception cref="T:System.InvalidOperationException">The <paramref name="task"/> was already
            executed.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
            <summary>
            Generates an enumerable of <see cref="T:System.Threading.Tasks.Task">Task</see> instances
            currently queued to the scheduler waiting to be executed.
            </summary>
            <remarks>
            <para>
            A class derived from <see cref="T:System.Threading.Tasks.TaskScheduler"/> implements this method in order to support
            integration with debuggers. This method will only be invoked by the .NET Framework when the
            debugger requests access to the data. The enumerable returned will be traversed by debugging
            utilities to access the tasks currently queued to this scheduler, enabling the debugger to
            provide a representation of this information in the user interface.
            </para>
            <para>
            It is important to note that, when this method is called, all other threads in the process will
            be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to
            blocking. If synchronization is necessary, the method should prefer to throw a <see
            cref="T:System.NotSupportedException"/>
            than to block, which could cause a debugger to experience delays. Additionally, this method and
            the enumerable returned must not modify any globally visible state.
            </para>
            <para>
            The returned enumerable should never be null. If there are currently no queued tasks, an empty
            enumerable should be returned instead.
            </para>
            <para>
            For developers implementing a custom debugger, this method shouldn't be called directly, but
            rather this functionality should be accessed through the internal wrapper method
            GetScheduledTasksForDebugger:
            <c>internal Task[] GetScheduledTasksForDebugger()</c>. This method returns an array of tasks,
            rather than an enumerable. In order to retrieve a list of active schedulers, a debugger may use
            another internal method: <c>internal static TaskScheduler[] GetTaskSchedulersForDebugger()</c>.
            This static method returns an array of all active TaskScheduler instances.
            GetScheduledTasksForDebugger then may be used on each of these scheduler instances to retrieve
            the list of scheduled tasks for each.
            </para>
            </remarks>
            <returns>An enumerable that allows traversal of tasks currently queued to this scheduler.
            </returns>
            <exception cref="T:System.NotSupportedException">
            This scheduler is unable to generate a list of queued tasks at this time.
            </exception>
        </member>
        <member name="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
            <summary>
            Indicates the maximum concurrency level this 
            <see cref="T:System.Threading.Tasks.TaskScheduler"/>  is able to support.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.TryRunInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Attempts to execute the target task synchronously.
            </summary>
            <param name="task">The task to run.</param>
            <param name="taskWasPreviouslyQueued">True if the task may have been previously queued,
            false if the task was absolutely not previously queued.</param>
            <returns>True if it ran, false otherwise.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
            <summary>
            Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task">Task</see> that was previously queued to
            this scheduler.
            </summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task">Task</see> to be dequeued.</param>
            <returns>A Boolean denoting whether the <paramref name="task"/> argument was successfully dequeued.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="task"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.NotifyWorkItemProgress">
            <summary>
            Notifies the scheduler that a work item has made progress.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskScheduler.RequiresAtomicStartTransition">
            <summary>
            Indicates whether this is a custom scheduler, in which case the safe code paths will be taken upon task entry
            using a CAS to transition from queued state to executing.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.InternalQueueTask(System.Threading.Tasks.Task)">
            <summary>
            Calls QueueTask() after performing any needed firing of events
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.#ctor">
            <summary>
            Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.AddToActiveTaskSchedulers">
            <summary>Adds this scheduler ot the active schedulers tracking collection for debugging purposes.</summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskScheduler.Default">
            <summary>
            Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> instance.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskScheduler.Current">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            associated with the currently executing task.
            </summary>
            <remarks>
            When not called from within a task, <see cref="P:System.Threading.Tasks.TaskScheduler.Current"/> will return the <see cref="P:System.Threading.Tasks.TaskScheduler.Default"/> scheduler.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskScheduler.InternalCurrent">
            <summary>
            Gets the <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see>
            associated with the currently executing task.
            </summary>
            <remarks>
            When not called from within a task, <see cref="P:System.Threading.Tasks.TaskScheduler.InternalCurrent"/> will return null.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
            <summary>
            Creates a <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            associated with the current <see cref="T:System.Threading.SynchronizationContext"/>.
            </summary>
            <remarks>
            All <see cref="T:System.Threading.Tasks.Task">Task</see> instances queued to 
            the returned scheduler will be executed through a call to the
            <see cref="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">Post</see> method
            on that context.
            </remarks>
            <returns>
            A <see cref="T:System.Threading.Tasks.TaskScheduler"/> associated with 
            the current <see cref="T:System.Threading.SynchronizationContext">SynchronizationContext</see>, as
            determined by <see cref="P:System.Threading.SynchronizationContext.Current">SynchronizationContext.Current</see>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The current SynchronizationContext may not be used as a TaskScheduler.
            </exception>
        </member>
        <member name="P:System.Threading.Tasks.TaskScheduler.Id">
            <summary>
            Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
            <summary>
            Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task">Task</see>
            on this scheduler.
            </summary>
            <remarks>
            <para>
            Scheduler implementations are provided with <see cref="T:System.Threading.Tasks.Task">Task</see>
            instances to be executed through either the <see cref="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)"/> method or the
            <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)"/> method. When the scheduler deems it appropriate to run the
            provided task, <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)"/> should be used to do so. TryExecuteTask handles all
            aspects of executing a task, including action invocation, exception handling, state management,
            and lifecycle control.
            </para>
            <para>
            <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)"/> must only be used for tasks provided to this scheduler by the .NET
            Framework infrastructure. It should not be used to execute arbitrary tasks obtained through
            custom mechanisms.
            </para>
            </remarks>
            <param name="task">
            A <see cref="T:System.Threading.Tasks.Task">Task</see> object to be executed.</param>
            <exception cref="T:System.InvalidOperationException">
            The <paramref name="task"/> is not associated with this scheduler.
            </exception>
            <returns>A Boolean that is true if <paramref name="task"/> was successfully executed, false if it
            was not. A common reason for execution failure is that the task had previously been executed or
            is in the process of being executed by another thread.</returns>
        </member>
        <member name="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
            <summary>
            Occurs when a faulted <see cref="T:System.Threading.Tasks.Task"/>'s unobserved exception is about to trigger exception escalation
            policy, which, by default, would terminate the process.
            </summary>
            <remarks>
            This AppDomain-wide event provides a mechanism to prevent exception
            escalation policy (which, by default, terminates the process) from triggering. 
            Each handler is passed a <see cref="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs"/>
            instance, which may be used to examine the exception and to mark it as observed.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasksForDebugger">
            <summary>
            Provides an array of all queued <see cref="T:System.Threading.Tasks.Task">Task</see> instances
            for the debugger.
            </summary>
            <remarks>
            The returned array is populated through a call to <see cref="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks"/>.
            Note that this function is only meant to be invoked by a debugger remotely. 
            It should not be called by any other codepaths.
            </remarks>
            <returns>An array of <see cref="T:System.Threading.Tasks.Task">Task</see> instances.</returns> 
            <exception cref="T:System.NotSupportedException">
            This scheduler is unable to generate a list of queued tasks at this time.
            </exception>
        </member>
        <member name="M:System.Threading.Tasks.TaskScheduler.GetTaskSchedulersForDebugger">
            <summary>
            Provides an array of all active <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> 
            instances for the debugger.
            </summary>
            <remarks>
            This function is only meant to be invoked by a debugger remotely. 
            It should not be called by any other codepaths.
            </remarks>
            <returns>An array of <see cref="T:System.Threading.Tasks.TaskScheduler">TaskScheduler</see> instances.</returns> 
        </member>
        <member name="T:System.Threading.Tasks.TaskScheduler.SystemThreadingTasks_TaskSchedulerDebugView">
            <summary>
            Nested class that provides debugger view for TaskScheduler
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.SynchronizationContextTaskScheduler">
            <summary>
            A TaskScheduler implementation that executes all tasks queued to it through a call to 
            <see cref="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)"/> on the <see cref="T:System.Threading.SynchronizationContext"/> 
            that its associated with. The default constructor for this class binds to the current <see cref="T:System.Threading.SynchronizationContext"/> 
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.SynchronizationContextTaskScheduler.#ctor">
            <summary>
            Constructs a SynchronizationContextTaskScheduler associated with <see cref="T:System.Threading.SynchronizationContext.Current"/> 
            </summary>
            <exception cref="T:System.InvalidOperationException">This constructor expects <see cref="T:System.Threading.SynchronizationContext.Current"/> to be set.</exception>
        </member>
        <member name="M:System.Threading.Tasks.SynchronizationContextTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            Implementation of <see cref="T:System.Threading.Tasks.TaskScheduler.QueueTask"/> for this scheduler class.
            
            Simply posts the tasks to be executed on the associated <see cref="T:System.Threading.SynchronizationContext"/>.
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:System.Threading.Tasks.SynchronizationContextTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Implementation of <see cref="T:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline"/>  for this scheduler class.
            
            The task will be executed inline only if the call happens within 
            the associated <see cref="T:System.Threading.SynchronizationContext"/>.
            </summary>
            <param name="task"></param>
            <param name="taskWasPreviouslyQueued"></param>
        </member>
        <member name="P:System.Threading.Tasks.SynchronizationContextTaskScheduler.MaximumConcurrencyLevel">
            <summary>
            Implements the <see cref="T:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel"/> property for
            this scheduler class.
            
            By default it returns 1, because a <see cref="T:System.Threading.SynchronizationContext"/> based
            scheduler only supports execution on a single thread.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs">
            <summary>
            Provides data for the event that is raised when a faulted <see cref="T:System.Threading.Tasks.Task"/>'s
            exception goes unobserved.
            </summary>
            <remarks>
            The Exception property is used to examine the exception without marking it
            as observed, whereas the <see cref="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.SetObserved"/> method is used to mark the exception
            as observed.  Marking the exception as observed prevents it from triggering exception escalation policy
            which, by default, terminates the process.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.#ctor(System.AggregateException)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.UnobservedTaskExceptionEventArgs"/> class
            with the unobserved exception.
            </summary>
            <param name="exception">The Exception that has gone unobserved.</param>
        </member>
        <member name="M:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.SetObserved">
            <summary>
            Marks the <see cref="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception"/> as "observed," thus preventing it
            from triggering exception escalation policy which, by default, terminates the process.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Observed">
            <summary>
            Gets whether this exception has been marked as "observed."
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.UnobservedTaskExceptionEventArgs.Exception">
            <summary>
            The Exception that went unobserved.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskSchedulerException">
            <summary>
            Represents an exception used to communicate an invalid operation by a
            <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException"/> class.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException"/>
            class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException"/>
            class using the default error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException"/>
            class with a specified error message and a reference to the inner exception that is the cause of
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskSchedulerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Tasks.TaskSchedulerException"/>
            class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
        </member>
        <member name="T:System.Threading.Tasks.ThreadPoolTaskScheduler">
            <summary>
            An implementation of TaskScheduler that uses the ThreadPool scheduler
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.#ctor">
            <summary>
            Constructs a new ThreadPool task scheduler object
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            Schedules a task to the ThreadPool.
            </summary>
            <param name="task">The task to schedule.</param>
        </member>
        <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            This internal function will do this:
              (1) If the task had previously been queued, attempt to pop it and return false if that fails.
              (2) Return whether the task is executed
            
            IMPORTANT NOTE: TryExecuteTaskInline will NOT throw task exceptions itself. Any wait code path using this function needs
            to account for exceptions that need to be propagated, and throw themselves accordingly.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.ThreadPoolTaskScheduler.NotifyWorkItemProgress">
            <summary>
            Notifies the scheduler that work is progressing (no-op).
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.ThreadPoolTaskScheduler.RequiresAtomicStartTransition">
            <summary>
            This is the only scheduler that returns false for this property, indicating that the task entry codepath is unsafe (CAS free)
            since we know that the underlying scheduler already takes care of atomic transitions from queued to non-queued.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TplEventSource">
            <summary>Provides an event source for tracing TPL information.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TasksSetActivityIds">
            Used to determine if tasks should generate Activity IDs for themselves
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.OnEventCommand(System.Diagnostics.Tracing.EventCommandEventArgs)">
            <summary>
            Get callbacks when the ETW sends us commands`
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Log">
            <summary>
            Defines the singleton instance for the TPL ETW provider.
            The TPL Event provider GUID is {2e5dba47-a3d2-4d16-8ee0-6671ffdcd7b5}.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.#ctor">
            <summary>Prevent external instantiation.  All logging should go through the Log instance.</summary>
        </member>
        <member name="T:System.Threading.Tasks.TplEventSource.TaskWaitBehavior">
            <summary>Configured behavior of a task wait operation.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TaskWaitBehavior.Synchronous">
            <summary>A synchronous wait.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TaskWaitBehavior.Asynchronous">
            <summary>An asynchronous await.</summary>
        </member>
        <member name="T:System.Threading.Tasks.TplEventSource.Tasks">
            <summary>ETW tasks that have start/stop events.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.Loop">
            <summary>A parallel loop.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.Invoke">
            <summary>A parallel invoke.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.TaskExecute">
            <summary>Executing a Task.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.TaskWait">
            <summary>Waiting on a Task.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.ForkJoin">
            <summary>A fork/join task within a loop or invoke.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.TaskScheduled">
            <summary>A task is scheduled to execute.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.AwaitTaskContinuationScheduled">
            <summary>An await task continuation is scheduled to execute.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Tasks.TraceOperation">
            <summary>AsyncCausalityFunctionality.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.TaskTransfer">
            <summary>
            Only the most basic information about the workings of the task library
            This sets activity IDS and logs when tasks are schedules (or waits begin)
            But are otherwise silent
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.Tasks">
            <summary>
            TaskTranser events plus events when tasks start and stop 
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.Parallel">
            <summary>
            Events associted with the higher level parallel APIs
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.AsyncCausalityOperation">
            <summary>
            These are relatively verbose events that effectively just redirect
            the windows AsyncCausalityTracer to ETW
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.TaskStops">
            <summary>
            Emit the stops as well as the schedule/start events
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.TasksFlowActivityIds">
            <summary>
            TasksFlowActivityIds indicate that activity ID flow from one task
            to any task created by it. 
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.AsyncMethod">
            <summary>
            Events related to the happenings of async methods.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.TasksSetActivityIds">
            <summary>
            TasksSetActivityIds will cause the task operations to set Activity Ids 
            This option is incompatible with TasksFlowActivityIds flow is ignored
            if that keyword is set.   This option is likely to be removed in the future
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.Debug">
            <summary>
            Relatively Verbose logging meant for debugging the Task library itself. Will probably be removed in the future
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.Keywords.DebugActivityId">
            <summary>
            Relatively Verbose logging meant for debugging the Task library itself.  Will probably be removed in the future
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.ALL_KEYWORDS">
            <summary>Enabled for all keywords.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.PARALLELLOOPBEGIN_ID">
            <summary>The beginning of a parallel loop.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.PARALLELLOOPEND_ID">
            <summary>The ending of a parallel loop.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.PARALLELINVOKEBEGIN_ID">
            <summary>The beginning of a parallel invoke.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.PARALLELINVOKEEND_ID">
            <summary>The ending of a parallel invoke.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.PARALLELFORK_ID">
            <summary>A task entering a fork/join construct.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.PARALLELJOIN_ID">
            <summary>A task leaving a fork/join construct.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TASKSCHEDULED_ID">
            <summary>A task is scheduled to a task scheduler.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TASKSTARTED_ID">
            <summary>A task is about to execute.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TASKCOMPLETED_ID">
            <summary>A task has finished executing.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TASKWAITBEGIN_ID">
            <summary>A wait on a task is beginning.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TASKWAITEND_ID">
            <summary>A wait on a task is ending.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.AWAITTASKCONTINUATIONSCHEDULED_ID">
            <summary>A continuation of a task is scheduled.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TASKWAITCONTINUATIONCOMPLETE_ID">
            <summary>A continuation of a taskWaitEnd is complete </summary>
        </member>
        <member name="F:System.Threading.Tasks.TplEventSource.TASKWAITCONTINUATIONSTARTED_ID">
            <summary>A continuation of a taskWaitEnd is complete </summary>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.TaskScheduled(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fired when a task is queued to a TaskScheduler.
            </summary>
            <param name="OriginatingTaskSchedulerID">The scheduler ID.</param>
            <param name="OriginatingTaskID">The task ID.</param>
            <param name="TaskID">The task ID.</param>
            <param name="CreatingTaskID">The task ID</param>
            <param name="TaskCreationOptions">The options used to create the task.</param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.TaskStarted(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fired just before a task actually starts executing.
            </summary>
            <param name="OriginatingTaskSchedulerID">The scheduler ID.</param>
            <param name="OriginatingTaskID">The task ID.</param>
            <param name="TaskID">The task ID.</param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.TaskCompleted(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Fired right after a task finished executing.
            </summary>
            <param name="OriginatingTaskSchedulerID">The scheduler ID.</param>
            <param name="OriginatingTaskID">The task ID.</param>
            <param name="TaskID">The task ID.</param>
            <param name="IsExceptional">Whether the task completed due to an error.</param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.TaskWaitBegin(System.Int32,System.Int32,System.Int32,System.Threading.Tasks.TplEventSource.TaskWaitBehavior,System.Int32)">
            <summary>
            Fired when starting to wait for a taks's completion explicitly or implicitly.
            </summary>
            <param name="OriginatingTaskSchedulerID">The scheduler ID.</param>
            <param name="OriginatingTaskID">The task ID.</param>
            <param name="TaskID">The task ID.</param>
            <param name="Behavior">Configured behavior for the wait.</param>
            <param name="ContinueWithTaskID">
            If known, if 'TaskID' has a 'continueWith' task, mention give its ID here.  
            0 means unknown.   This allows better visualization of the common sequential chaining case.
            </param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.TaskWaitEnd(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fired when the wait for a tasks completion returns.
            </summary>
            <param name="OriginatingTaskSchedulerID">The scheduler ID.</param>
            <param name="OriginatingTaskID">The task ID.</param>
            <param name="TaskID">The task ID.</param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.TaskWaitContinuationComplete(System.Int32)">
            <summary>
            Fired when the work (method) associated with a TaskWaitEnd completes
            </summary>
            <param name="TaskID">The task ID.</param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.TaskWaitContinuationStarted(System.Int32)">
            <summary>
            Fired when the work (method) associated with a TaskWaitEnd completes
            </summary>
            <param name="TaskID">The task ID.</param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.AwaitTaskContinuationScheduled(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fired when the an asynchronous continuation for a task is scheduled
            </summary>
            <param name="OriginatingTaskSchedulerID">The scheduler ID.</param>
            <param name="OriginatingTaskID">The task ID.</param>
        </member>
        <member name="M:System.Threading.Tasks.TplEventSource.CreateGuidForTaskID(System.Int32)">
            <summary>
            Activity IDs are GUIDS but task IDS are integers (and are not unique across appdomains
            This routine creates a process wide unique GUID given a task ID
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.ValueTask">
            <summary>Provides an awaitable result of an asynchronous operation.</summary>
            <remarks>
            <see cref="T:System.Threading.Tasks.ValueTask"/> instances are meant to be directly awaited.  To do more complicated operations with them, a <see cref="T:System.Threading.Tasks.Task"/>
            should be extracted using <see cref="M:System.Threading.Tasks.ValueTask.AsTask"/>.  Such operations might include caching a task instance to be awaited later,
            registering multiple continuations with a single task, awaiting the same task multiple times, and using combinators over
            multiple operations:
            <list type="bullet">
            <item>
            Once the result of a <see cref="T:System.Threading.Tasks.ValueTask"/> instance has been retrieved, do not attempt to retrieve it again.
            <see cref="T:System.Threading.Tasks.ValueTask"/> instances may be backed by <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/> instances that are reusable, and such
            instances may use the act of retrieving the instances result as a notification that the instance may now be reused for
            a different operation.  Attempting to then reuse that same <see cref="T:System.Threading.Tasks.ValueTask"/> results in undefined behavior.
            </item>
            <item>
            Do not attempt to add multiple continuations to the same <see cref="T:System.Threading.Tasks.ValueTask"/>.  While this might work if the
            <see cref="T:System.Threading.Tasks.ValueTask"/> wraps a <code>T</code> or a <see cref="T:System.Threading.Tasks.Task"/>, it may not work if the <see cref="T:System.Threading.Tasks.ValueTask"/>
            was constructed from an <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.
            </item>
            <item>
            Some operations that return a <see cref="T:System.Threading.Tasks.ValueTask"/> may invalidate it based on some subsequent operation being performed.
            Unless otherwise documented, assume that a <see cref="T:System.Threading.Tasks.ValueTask"/> should be awaited prior to performing any additional operations
            on the instance from which it was retrieved.
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask.s_canceledTask">
            <summary>A task canceled using `new CancellationToken(true)`.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask.CompletedTask">
            <summary>A successfully completed task.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask._obj">
            <summary>null if representing a successful synchronous completion, otherwise a <see cref="T:System.Threading.Tasks.Task"/> or a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask._token">
            <summary>Opaque value passed through to the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask._continueOnCapturedContext">
            <summary>true to continue on the capture context; otherwise, true.</summary>
            <remarks>Stored in the <see cref="T:System.Threading.Tasks.ValueTask"/> rather than in the configured awaiter to utilize otherwise padding space.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.#ctor(System.Threading.Tasks.Task)">
            <summary>Initialize the <see cref="T:System.Threading.Tasks.ValueTask"/> with a <see cref="T:System.Threading.Tasks.Task"/> that represents the operation.</summary>
            <param name="task">The task.</param>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.#ctor(System.Threading.Tasks.Sources.IValueTaskSource,System.Int16)">
            <summary>Initialize the <see cref="T:System.Threading.Tasks.ValueTask"/> with a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/> object that represents the operation.</summary>
            <param name="source">The source.</param>
            <param name="token">Opaque value passed through to the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</param>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.Equals(System.Threading.Tasks.ValueTask)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Threading.Tasks.ValueTask"/> value.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.op_Equality(System.Threading.Tasks.ValueTask,System.Threading.Tasks.ValueTask)">
            <summary>Returns a value indicating whether two <see cref="T:System.Threading.Tasks.ValueTask"/> values are equal.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.op_Inequality(System.Threading.Tasks.ValueTask,System.Threading.Tasks.ValueTask)">
            <summary>Returns a value indicating whether two <see cref="T:System.Threading.Tasks.ValueTask"/> values are not equal.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.AsTask">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> object to represent this ValueTask.
            </summary>
            <remarks>
            It will either return the wrapped task object if one exists, or it'll
            manufacture a new task object to represent the result.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.Preserve">
            <summary>Gets a <see cref="T:System.Threading.Tasks.ValueTask"/> that may be used at any point in the future.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.GetTaskForValueTaskSource(System.Threading.Tasks.Sources.IValueTaskSource)">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task"/> to represent the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
            <remarks>
            The <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/> is passed in rather than reading and casting <see cref="F:System.Threading.Tasks.ValueTask._obj"/>
            so that the caller can pass in an object it's already validated.
            </remarks>
        </member>
        <member name="T:System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask">
            <summary>Type used to create a <see cref="T:System.Threading.Tasks.Task"/> to represent a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask._source">
            <summary>The associated <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask._token">
            <summary>The token to pass through to operations on <see cref="F:System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask._source"/></summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask.IsCompleted">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask"/> represents a completed operation.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask.IsCompletedSuccessfully">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask"/> represents a successfully completed operation.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask.IsFaulted">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask"/> represents a failed operation.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask.IsCanceled">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask"/> represents a canceled operation.</summary>
            <remarks>
            If the <see cref="T:System.Threading.Tasks.ValueTask"/> is backed by a result or by a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>,
            this will always return false.  If it's backed by a <see cref="T:System.Threading.Tasks.Task"/>, it'll return the
            value of the task's <see cref="P:System.Threading.Tasks.Task.IsCanceled"/> property.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.ThrowIfCompletedUnsuccessfully">
            <summary>Throws the exception that caused the <see cref="T:System.Threading.Tasks.ValueTask"/> to fail.  If it completed successfully, nothing is thrown.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.GetAwaiter">
            <summary>Gets an awaiter for this <see cref="T:System.Threading.Tasks.ValueTask"/>.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask.ConfigureAwait(System.Boolean)">
            <summary>Configures an awaiter for this <see cref="T:System.Threading.Tasks.ValueTask"/>.</summary>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the captured context; otherwise, false.
            </param>
        </member>
        <member name="T:System.Threading.Tasks.ValueTask`1">
            <summary>Provides a value type that can represent a synchronously available value or a task object.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <remarks>
            <see cref="T:System.Threading.Tasks.ValueTask`1"/> instances are meant to be directly awaited.  To do more complicated operations with them, a <see cref="T:System.Threading.Tasks.Task`1"/>
            should be extracted using <see cref="M:System.Threading.Tasks.ValueTask`1.AsTask"/>.  Such operations might include caching a task instance to be awaited later,
            registering multiple continuations with a single task, awaiting the same task multiple times, and using combinators over
            multiple operations:
            <list type="bullet">
            <item>
            Once the result of a <see cref="T:System.Threading.Tasks.ValueTask`1"/> instance has been retrieved, do not attempt to retrieve it again.
            <see cref="T:System.Threading.Tasks.ValueTask`1"/> instances may be backed by <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/> instances that are reusable, and such
            instances may use the act of retrieving the instances result as a notification that the instance may now be reused for
            a different operation.  Attempting to then reuse that same <see cref="T:System.Threading.Tasks.ValueTask`1"/> results in undefined behavior.
            </item>
            <item>
            Do not attempt to add multiple continuations to the same <see cref="T:System.Threading.Tasks.ValueTask`1"/>.  While this might work if the
            <see cref="T:System.Threading.Tasks.ValueTask`1"/> wraps a <code>T</code> or a <see cref="T:System.Threading.Tasks.Task`1"/>, it may not work if the <see cref="T:System.Threading.Tasks.Task`1"/>
            was constructed from an <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.
            </item>
            <item>
            Some operations that return a <see cref="T:System.Threading.Tasks.ValueTask`1"/> may invalidate it based on some subsequent operation being performed.
            Unless otherwise documented, assume that a <see cref="T:System.Threading.Tasks.ValueTask`1"/> should be awaited prior to performing any additional operations
            on the instance from which it was retrieved.
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask`1.s_canceledTask">
            <summary>A task canceled using `new CancellationToken(true)`. Lazily created only when first needed.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask`1._obj">
            <summary>null if <see cref="F:System.Threading.Tasks.ValueTask`1._result"/> has the result, otherwise a <see cref="T:System.Threading.Tasks.Task`1"/> or a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask`1._result">
            <summary>The result to be used if the operation completed successfully synchronously.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask`1._token">
            <summary>Opaque value passed through to the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask`1._continueOnCapturedContext">
            <summary>true to continue on the captured context; otherwise, false.</summary>
            <remarks>Stored in the <see cref="T:System.Threading.Tasks.ValueTask`1"/> rather than in the configured awaiter to utilize otherwise padding space.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.#ctor(`0)">
            <summary>Initialize the <see cref="T:System.Threading.Tasks.ValueTask`1"/> with a <typeparamref name="TResult"/> result value.</summary>
            <param name="result">The result.</param>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>Initialize the <see cref="T:System.Threading.Tasks.ValueTask`1"/> with a <see cref="T:System.Threading.Tasks.Task`1"/> that represents the operation.</summary>
            <param name="task">The task.</param>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.#ctor(System.Threading.Tasks.Sources.IValueTaskSource{`0},System.Int16)">
            <summary>Initialize the <see cref="T:System.Threading.Tasks.ValueTask`1"/> with a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/> object that represents the operation.</summary>
            <param name="source">The source.</param>
            <param name="token">Opaque value passed through to the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</param>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.#ctor(System.Object,`0,System.Int16,System.Boolean)">
            <summary>Non-verified initialization of the struct to the specified values.</summary>
            <param name="obj">The object.</param>
            <param name="result">The result.</param>
            <param name="token">The token.</param>
            <param name="continueOnCapturedContext">true to continue on captured context; otherwise, false.</param>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.Equals(System.Threading.Tasks.ValueTask{`0})">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Threading.Tasks.ValueTask`1"/> value.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.op_Equality(System.Threading.Tasks.ValueTask{`0},System.Threading.Tasks.ValueTask{`0})">
            <summary>Returns a value indicating whether two <see cref="T:System.Threading.Tasks.ValueTask`1"/> values are equal.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.op_Inequality(System.Threading.Tasks.ValueTask{`0},System.Threading.Tasks.ValueTask{`0})">
            <summary>Returns a value indicating whether two <see cref="T:System.Threading.Tasks.ValueTask`1"/> values are not equal.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.AsTask">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task`1"/> object to represent this ValueTask.
            </summary>
            <remarks>
            It will either return the wrapped task object if one exists, or it'll
            manufacture a new task object to represent the result.
            </remarks>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.Preserve">
            <summary>Gets a <see cref="T:System.Threading.Tasks.ValueTask`1"/> that may be used at any point in the future.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.GetTaskForValueTaskSource(System.Threading.Tasks.Sources.IValueTaskSource{`0})">
            <summary>Creates a <see cref="T:System.Threading.Tasks.Task`1"/> to represent the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
            <remarks>
            The <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/> is passed in rather than reading and casting <see cref="F:System.Threading.Tasks.ValueTask`1._obj"/>
            so that the caller can pass in an object it's already validated.
            </remarks>
        </member>
        <member name="T:System.Threading.Tasks.ValueTask`1.ValueTaskSourceAsTask">
            <summary>Type used to create a <see cref="T:System.Threading.Tasks.Task`1"/> to represent a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask`1.ValueTaskSourceAsTask._source">
            <summary>The associated <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.ValueTask`1.ValueTaskSourceAsTask._token">
            <summary>The token to pass through to operations on <see cref="F:System.Threading.Tasks.ValueTask`1.ValueTaskSourceAsTask._source"/></summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask`1.IsCompleted">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask`1"/> represents a completed operation.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask`1.IsCompletedSuccessfully">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask`1"/> represents a successfully completed operation.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask`1.IsFaulted">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask`1"/> represents a failed operation.</summary>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask`1.IsCanceled">
            <summary>Gets whether the <see cref="T:System.Threading.Tasks.ValueTask`1"/> represents a canceled operation.</summary>
            <remarks>
            If the <see cref="T:System.Threading.Tasks.ValueTask`1"/> is backed by a result or by a <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>,
            this will always return false.  If it's backed by a <see cref="T:System.Threading.Tasks.Task"/>, it'll return the
            value of the task's <see cref="P:System.Threading.Tasks.Task.IsCanceled"/> property.
            </remarks>
        </member>
        <member name="P:System.Threading.Tasks.ValueTask`1.Result">
            <summary>Gets the result.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.GetAwaiter">
            <summary>Gets an awaiter for this <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.ConfigureAwait(System.Boolean)">
            <summary>Configures an awaiter for this <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
            <param name="continueOnCapturedContext">
            true to attempt to marshal the continuation back to the captured context; otherwise, false.
            </param>
        </member>
        <member name="M:System.Threading.Tasks.ValueTask`1.ToString">
            <summary>Gets a string-representation of this <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
        </member>
        <member name="T:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1">
            <summary>Provides the core logic for implementing a manual-reset <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/> or <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._continuation">
            <summary>
            The callback to invoke when the operation completes if <see cref="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)"/> was called before the operation completed,
            or <see cref="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCoreShared.s_sentinel"/> if the operation completed before a callback was supplied,
            or null if a callback hasn't yet been provided and the operation hasn't yet completed.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._continuationState">
            <summary>State to pass to <see cref="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._continuation"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._executionContext">
            <summary><see cref="T:System.Threading.ExecutionContext"/> to flow to the callback, or null if no flowing is required.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._capturedContext">
            <summary>
            A "captured" <see cref="T:System.Threading.SynchronizationContext"/> or <see cref="T:System.Threading.Tasks.TaskScheduler"/> with which to invoke the callback,
            or null if no special context is required.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._completed">
            <summary>Whether the current operation has completed.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._result">
            <summary>The result with which the operation succeeded, or the default value if it hasn't yet completed or failed.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._error">
            <summary>The exception with which the operation failed, or null if it hasn't yet completed or completed successfully.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._version">
            <summary>The current version of this value, used to help prevent misuse.</summary>
        </member>
        <member name="P:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.RunContinuationsAsynchronously">
            <summary>Gets or sets whether to force continuations to run asynchronously.</summary>
            <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.Reset">
            <summary>Resets to prepare for the next operation.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.SetResult(`0)">
            <summary>Completes with a successful result.</summary>
            <param name="result">The result.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.SetException(System.Exception)">
            <summary>Complets with an error.</summary>
            <param name="error"></param>
        </member>
        <member name="P:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.Version">
            <summary>Gets the operation version.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.GetStatus(System.Int16)">
            <summary>Gets the status of the operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.GetResult(System.Int16)">
            <summary>Gets the result of the operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)">
            <summary>Schedules the continuation action for this operation.</summary>
            <param name="continuation">The continuation to invoke when the operation has completed.</param>
            <param name="state">The state object to pass to <paramref name="continuation"/> when it's invoked.</param>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
            <param name="flags">The flags describing the behavior of the continuation.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.ValidateToken(System.Int16)">
            <summary>Ensures that the specified token matches the current version.</summary>
            <param name="token">The token supplied by <see cref="T:System.Threading.Tasks.ValueTask"/>.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.SignalCompletion">
            <summary>Signals that the operation has completed.  Invoked after the result or error has been set.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1.InvokeContinuation">
            <summary>
            Invokes the continuation with the appropriate captured context / scheduler.
            This assumes that if <see cref="F:System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1._executionContext"/> is not null we're already
            running within that <see cref="T:System.Threading.ExecutionContext"/>.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags">
            <summary>
            Flags passed from <see cref="T:System.Threading.Tasks.ValueTask"/> and <see cref="T:System.Threading.Tasks.ValueTask`1"/> to
            <see cref="M:System.Threading.Tasks.Sources.IValueTaskSource.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)"/> and <see cref="M:System.Threading.Tasks.Sources.IValueTaskSource`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)"/>
            to control behavior.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags.None">
            <summary>
            No requirements are placed on how the continuation is invoked.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags.UseSchedulingContext">
            <summary>
            Set if OnCompleted should capture the current scheduling context (e.g. SynchronizationContext)
            and use it when queueing the continuation for execution.  If this is not set, the implementation
            may choose to execute the continuation in an arbitrary location.
            </summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags.FlowExecutionContext">
            <summary>
            Set if OnCompleted should capture the current ExecutionContext and use it to run the continuation.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Sources.ValueTaskSourceStatus">
            <summary>Indicates the status of an <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/> or <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ValueTaskSourceStatus.Pending">
            <summary>The operation has not yet completed.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ValueTaskSourceStatus.Succeeded">
            <summary>The operation completed successfully.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ValueTaskSourceStatus.Faulted">
            <summary>The operation completed with an error.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Sources.ValueTaskSourceStatus.Canceled">
            <summary>The operation completed due to cancellation.</summary>
        </member>
        <member name="T:System.Threading.Tasks.Sources.IValueTaskSource">
            <summary>Represents an object that can be wrapped by a <see cref="T:System.Threading.Tasks.ValueTask"/>.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Sources.IValueTaskSource.GetStatus(System.Int16)">
            <summary>Gets the status of the current operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.IValueTaskSource.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)">
            <summary>Schedules the continuation action for this <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
            <param name="continuation">The continuation to invoke when the operation has completed.</param>
            <param name="state">The state object to pass to <paramref name="continuation"/> when it's invoked.</param>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
            <param name="flags">The flags describing the behavior of the continuation.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.IValueTaskSource.GetResult(System.Int16)">
            <summary>Gets the result of the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource"/>.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="T:System.Threading.Tasks.Sources.IValueTaskSource`1">
            <summary>Represents an object that can be wrapped by a <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</summary>
            <typeparam name="TResult">Specifies the type of data returned from the object.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.Sources.IValueTaskSource`1.GetStatus(System.Int16)">
            <summary>Gets the status of the current operation.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.IValueTaskSource`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)">
            <summary>Schedules the continuation action for this <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
            <param name="continuation">The continuation to invoke when the operation has completed.</param>
            <param name="state">The state object to pass to <paramref name="continuation"/> when it's invoked.</param>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
            <param name="flags">The flags describing the behavior of the continuation.</param>
        </member>
        <member name="M:System.Threading.Tasks.Sources.IValueTaskSource`1.GetResult(System.Int16)">
            <summary>Gets the result of the <see cref="T:System.Threading.Tasks.Sources.IValueTaskSource`1"/>.</summary>
            <param name="token">Opaque value that was provided to the <see cref="T:System.Threading.Tasks.ValueTask"/>'s constructor.</param>
        </member>
        <member name="T:System.Threading.ThreadInterruptedException">
            <summary>
            An exception class to indicate that the thread was interrupted from a waiting state.
            </summary>
        </member>
        <member name="F:System.Threading.ThreadPoolGlobals.s_invokeAsyncStateMachineBox">
            <summary>Shim used to invoke <see cref="M:System.Runtime.CompilerServices.IAsyncStateMachineBox.MoveNext"/> of the supplied <see cref="T:System.Runtime.CompilerServices.IAsyncStateMachineBox"/>.</summary>
        </member>
        <member name="M:System.Threading.ThreadPoolWorkQueue.Dispatch">
            <summary>
            Dispatches work items to this thread.
            </summary>
            <returns>
            <c>true</c> if this thread did as much work as was available or its quantum expired.
            <c>false</c> if this thread stopped working early.
            </returns>
        </member>
        <member name="T:System.Threading.TimeoutHelper">
            <summary>
            A helper class to capture a start time using <see cref="P:System.Environment.TickCount"/> as a time in milliseconds.
            Also updates a given timeout by subtracting the current time from the start time.
            </summary>
        </member>
        <member name="M:System.Threading.TimeoutHelper.GetTime">
            <summary>
            Returns <see cref="P:System.Environment.TickCount"/> as a start time in milliseconds as a <see cref="T:System.UInt32"/>.
            <see cref="P:System.Environment.TickCount"/> rolls over from positive to negative every ~25 days, then ~25 days to back to positive again.
            <see cref="T:System.UInt32"/> is used to ignore the sign and double the range to 50 days.
            </summary>
        </member>
        <member name="M:System.Threading.TimeoutHelper.UpdateTimeOut(System.UInt32,System.Int32)">
            <summary>
            Helper function to measure and update the elapsed time
            </summary>
            <param name="startTime"> The first time (in milliseconds) observed when the wait started</param>
            <param name="originalWaitMillisecondsTimeout">The original wait timeout in milliseconds</param>
            <returns>The new wait time in milliseconds, or -1 if the time expired</returns>
        </member>
        <member name="P:System.Threading.Timer.ActiveCount">
            <summary>
            Gets the number of timers that are currently active. An active timer is registered to tick at some point in the
            future, and has not yet been canceled.
            </summary>
        </member>
        <member name="P:System.SR.Acc_CreateAbst">
            <summary>Cannot create an abstract class.</summary>
        </member>
        <member name="P:System.SR.Acc_CreateAbstEx">
            <summary>Cannot create an instance of {0} because it is an abstract class.</summary>
        </member>
        <member name="P:System.SR.Acc_CreateArgIterator">
            <summary>Cannot dynamically create an instance of ArgIterator.</summary>
        </member>
        <member name="P:System.SR.Acc_CreateGeneric">
            <summary>Cannot create a type for which Type.ContainsGenericParameters is true.</summary>
        </member>
        <member name="P:System.SR.Acc_CreateGenericEx">
            <summary>Cannot create an instance of {0} because Type.ContainsGenericParameters is true.</summary>
        </member>
        <member name="P:System.SR.Acc_CreateInterface">
            <summary>Cannot create an instance of an interface.</summary>
        </member>
        <member name="P:System.SR.Acc_CreateInterfaceEx">
            <summary>Cannot create an instance of {0} because it is an interface.</summary>
        </member>
        <member name="P:System.SR.Acc_CreateVoid">
            <summary>Cannot dynamically create an instance of System.Void.</summary>
        </member>
        <member name="P:System.SR.Acc_NotClassInit">
            <summary>Type initializer was not callable.</summary>
        </member>
        <member name="P:System.SR.Acc_ReadOnly">
            <summary>Cannot set a constant field.</summary>
        </member>
        <member name="P:System.SR.Access_Void">
            <summary>Cannot create an instance of void.</summary>
        </member>
        <member name="P:System.SR.AggregateException_ctor_DefaultMessage">
            <summary>One or more errors occurred.</summary>
        </member>
        <member name="P:System.SR.AggregateException_ctor_InnerExceptionNull">
            <summary>An element of innerExceptions was null.</summary>
        </member>
        <member name="P:System.SR.AggregateException_DeserializationFailure">
            <summary>The serialization stream contains no inner exceptions.</summary>
        </member>
        <member name="P:System.SR.AggregateException_InnerException">
            <summary>(Inner Exception #{0})</summary>
        </member>
        <member name="P:System.SR.AppDomain_AppBaseNotSet">
            <summary>The ApplicationBase must be set before retrieving this property.</summary>
        </member>
        <member name="P:System.SR.AppDomain_Name">
            <summary>Name:</summary>
        </member>
        <member name="P:System.SR.AppDomain_NoContextPolicies">
            <summary>There are no context policies.</summary>
        </member>
        <member name="P:System.SR.AppDomain_Policy_PrincipalTwice">
            <summary>Default principal object cannot be set twice.</summary>
        </member>
        <member name="P:System.SR.AmbiguousImplementationException_NullMessage">
            <summary>Ambiguous implementation found.</summary>
        </member>
        <member name="P:System.SR.Arg_AccessException">
            <summary>Cannot access member.</summary>
        </member>
        <member name="P:System.SR.Arg_AccessViolationException">
            <summary>Attempted to read or write protected memory. This is often an indication that other memory is corrupt.</summary>
        </member>
        <member name="P:System.SR.Arg_AmbiguousMatchException">
            <summary>Ambiguous match found.</summary>
        </member>
        <member name="P:System.SR.Arg_ApplicationException">
            <summary>Error in the application.</summary>
        </member>
        <member name="P:System.SR.Arg_ArgumentException">
            <summary>Value does not fall within the expected range.</summary>
        </member>
        <member name="P:System.SR.Arg_ArgumentOutOfRangeException">
            <summary>Specified argument was out of the range of valid values.</summary>
        </member>
        <member name="P:System.SR.Arg_ArithmeticException">
            <summary>Overflow or underflow in the arithmetic operation.</summary>
        </member>
        <member name="P:System.SR.Arg_ArrayLengthsDiffer">
            <summary>Array lengths must be the same.</summary>
        </member>
        <member name="P:System.SR.Arg_ArrayPlusOffTooSmall">
            <summary>Destination array is not long enough to copy all the items in the collection. Check array index and length.</summary>
        </member>
        <member name="P:System.SR.Arg_ArrayTypeMismatchException">
            <summary>Attempted to access an element as a type incompatible with the array.</summary>
        </member>
        <member name="P:System.SR.Arg_ArrayZeroError">
            <summary>Array must not be of length zero.</summary>
        </member>
        <member name="P:System.SR.Arg_BadDecimal">
            <summary>Read an invalid decimal value from the buffer.</summary>
        </member>
        <member name="P:System.SR.Arg_BadImageFormatException">
            <summary>Format of the executable (.exe) or library (.dll) is invalid.</summary>
        </member>
        <member name="P:System.SR.Arg_BadLiteralFormat">
            <summary>Encountered an invalid type for a default value.</summary>
        </member>
        <member name="P:System.SR.Arg_BogusIComparer">
            <summary>Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: '{0}'.</summary>
        </member>
        <member name="P:System.SR.Arg_BufferTooSmall">
            <summary>Not enough space available in the buffer.</summary>
        </member>
        <member name="P:System.SR.Arg_CannotBeNaN">
            <summary>TimeSpan does not accept floating point Not-a-Number values.</summary>
        </member>
        <member name="P:System.SR.Arg_CannotHaveNegativeValue">
            <summary>String cannot contain a minus sign if the base is not 10.</summary>
        </member>
        <member name="P:System.SR.Arg_CannotMixComparisonInfrastructure">
            <summary>The usage of IKeyComparer and IHashCodeProvider/IComparer interfaces cannot be mixed; use one or the other.</summary>
        </member>
        <member name="P:System.SR.Arg_CannotUnloadAppDomainException">
            <summary>Attempt to unload the AppDomain failed.</summary>
        </member>
        <member name="P:System.SR.Arg_CATypeResolutionFailed">
            <summary>Failed to resolve type from string "{0}" which was embedded in custom attribute blob.</summary>
        </member>
        <member name="P:System.SR.Arg_COMAccess">
            <summary>Must specify property Set or Get or method call for a COM Object.</summary>
        </member>
        <member name="P:System.SR.Arg_COMException">
            <summary>Error HRESULT E_FAIL has been returned from a call to a COM component.</summary>
        </member>
        <member name="P:System.SR.Arg_COMPropSetPut">
            <summary>Only one of the following binding flags can be set: BindingFlags.SetProperty, BindingFlags.PutDispProperty,  BindingFlags.PutRefDispProperty.</summary>
        </member>
        <member name="P:System.SR.Arg_CreatInstAccess">
            <summary>Cannot specify both CreateInstance and another access type.</summary>
        </member>
        <member name="P:System.SR.Arg_CryptographyException">
            <summary>Error occurred during a cryptographic operation.</summary>
        </member>
        <member name="P:System.SR.Arg_CustomAttributeFormatException">
            <summary>Binary format of the specified custom attribute was invalid.</summary>
        </member>
        <member name="P:System.SR.Arg_DataMisalignedException">
            <summary>A datatype misalignment was detected in a load or store instruction.</summary>
        </member>
        <member name="P:System.SR.Arg_DateTimeRange">
            <summary>Combination of arguments to the DateTime constructor is out of the legal range.</summary>
        </member>
        <member name="P:System.SR.Arg_DecBitCtor">
            <summary>Decimal byte array constructor requires an array of length four containing valid decimal bytes.</summary>
        </member>
        <member name="P:System.SR.Arg_DirectoryNotFoundException">
            <summary>Attempted to access a path that is not on the disk.</summary>
        </member>
        <member name="P:System.SR.Arg_DivideByZero">
            <summary>Attempted to divide by zero.</summary>
        </member>
        <member name="P:System.SR.Arg_DlgtNullInst">
            <summary>Delegate to an instance method cannot have null 'this'.</summary>
        </member>
        <member name="P:System.SR.Arg_DlgtTargMeth">
            <summary>Cannot bind to the target method because its signature is not compatible with that of the delegate type.</summary>
        </member>
        <member name="P:System.SR.Arg_DlgtTypeMis">
            <summary>Delegates must be of the same type.</summary>
        </member>
        <member name="P:System.SR.Arg_DllNotFoundException">
            <summary>Dll was not found.</summary>
        </member>
        <member name="P:System.SR.Arg_DriveNotFoundException">
            <summary>Attempted to access a drive that is not available.</summary>
        </member>
        <member name="P:System.SR.Arg_DuplicateWaitObjectException">
            <summary>Duplicate objects in argument.</summary>
        </member>
        <member name="P:System.SR.Arg_EHClauseNotClause">
            <summary>This ExceptionHandlingClause is not a clause.</summary>
        </member>
        <member name="P:System.SR.Arg_EHClauseNotFilter">
            <summary>This ExceptionHandlingClause is not a filter.</summary>
        </member>
        <member name="P:System.SR.Arg_EmptyArray">
            <summary>Array may not be empty.</summary>
        </member>
        <member name="P:System.SR.Arg_EmptyOrNullString">
            <summary>String may not be empty or null.</summary>
        </member>
        <member name="P:System.SR.Arg_EndOfStreamException">
            <summary>Attempted to read past the end of the stream.</summary>
        </member>
        <member name="P:System.SR.Arg_EntryPointNotFoundException">
            <summary>Entry point was not found.</summary>
        </member>
        <member name="P:System.SR.Arg_EnumAndObjectMustBeSameType">
            <summary>Object must be the same type as the enum. The type passed in was '{0}'; the enum type was '{1}'.</summary>
        </member>
        <member name="P:System.SR.Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType">
            <summary>Enum underlying type and the object must be same type or object. Type passed in was '{0}'; the enum underlying type was '{1}'.</summary>
        </member>
        <member name="P:System.SR.Arg_EnumIllegalVal">
            <summary>Illegal enum value: {0}.</summary>
        </member>
        <member name="P:System.SR.Arg_EnumLitValueNotFound">
            <summary>Literal value was not found.</summary>
        </member>
        <member name="P:System.SR.Arg_EnumUnderlyingTypeAndObjectMustBeSameType">
            <summary>Enum underlying type and the object must be same type or object must be a String. Type passed in was '{0}'; the enum underlying type was '{1}'.</summary>
        </member>
        <member name="P:System.SR.Arg_EnumValueNotFound">
            <summary>Requested value '{0}' was not found.</summary>
        </member>
        <member name="P:System.SR.Arg_ExecutionEngineException">
            <summary>Internal error in the runtime.</summary>
        </member>
        <member name="P:System.SR.Arg_ExternalException">
            <summary>External component has thrown an exception.</summary>
        </member>
        <member name="P:System.SR.Arg_FieldAccessException">
            <summary>Attempted to access a field that is not accessible by the caller.</summary>
        </member>
        <member name="P:System.SR.Arg_FieldDeclTarget">
            <summary>Field '{0}' defined on type '{1}' is not a field on the target object which is of type '{2}'.</summary>
        </member>
        <member name="P:System.SR.Arg_FldGetArgErr">
            <summary>No arguments can be provided to Get a field value.</summary>
        </member>
        <member name="P:System.SR.Arg_FldGetPropSet">
            <summary>Cannot specify both GetField and SetProperty.</summary>
        </member>
        <member name="P:System.SR.Arg_FldSetArgErr">
            <summary>Only the field value can be specified to set a field value.</summary>
        </member>
        <member name="P:System.SR.Arg_FldSetGet">
            <summary>Cannot specify both Get and Set on a field.</summary>
        </member>
        <member name="P:System.SR.Arg_FldSetInvoke">
            <summary>Cannot specify Set on a Field and Invoke on a method.</summary>
        </member>
        <member name="P:System.SR.Arg_FldSetPropGet">
            <summary>Cannot specify both SetField and GetProperty.</summary>
        </member>
        <member name="P:System.SR.Arg_FormatException">
            <summary>One of the identified items was in an invalid format.</summary>
        </member>
        <member name="P:System.SR.Arg_GenericParameter">
            <summary>Method must be called on a Type for which Type.IsGenericParameter is false.</summary>
        </member>
        <member name="P:System.SR.Arg_GetMethNotFnd">
            <summary>Property Get method was not found.</summary>
        </member>
        <member name="P:System.SR.Arg_GuidArrayCtor">
            <summary>Byte array for GUID must be exactly {0} bytes long.</summary>
        </member>
        <member name="P:System.SR.Arg_HandleNotAsync">
            <summary>Handle does not support asynchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened synchronously (that is, it was not opened for overlapped I/O).</summary>
        </member>
        <member name="P:System.SR.Arg_HandleNotSync">
            <summary>Handle does not support synchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened asynchronously (that is, it was opened explicitly for overlapped I/O).</summary>
        </member>
        <member name="P:System.SR.Arg_HexStyleNotSupported">
            <summary>The number style AllowHexSpecifier is not supported on floating point data types.</summary>
        </member>
        <member name="P:System.SR.Arg_HTCapacityOverflow">
            <summary>Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.</summary>
        </member>
        <member name="P:System.SR.Arg_IndexMustBeInt">
            <summary>All indexes must be of type Int32.</summary>
        </member>
        <member name="P:System.SR.Arg_IndexOutOfRangeException">
            <summary>Index was outside the bounds of the array.</summary>
        </member>
        <member name="P:System.SR.Arg_InsufficientExecutionStackException">
            <summary>Insufficient stack to continue executing the program safely. This can happen from having too many functions on the call stack or function on the stack using too much stack space.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidANSIString">
            <summary>The ANSI string passed in could not be converted from the default ANSI code page to Unicode.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidBase">
            <summary>Invalid Base.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidCastException">
            <summary>Specified cast is not valid.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidComObjectException">
            <summary>Attempt has been made to use a COM object that does not have a backing class factory.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidFilterCriteriaException">
            <summary>Specified filter criteria was invalid.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidHandle">
            <summary>Invalid handle.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidHexStyle">
            <summary>With the AllowHexSpecifier bit set in the enum bit field, the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidNeutralResourcesLanguage_Asm_Culture">
            <summary>The NeutralResourcesLanguageAttribute on the assembly "{0}" specifies an invalid culture name: "{1}".</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidNeutralResourcesLanguage_FallbackLoc">
            <summary>The NeutralResourcesLanguageAttribute specifies an invalid or unrecognized ultimate resource fallback location: "{0}".</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidSatelliteContract_Asm_Ver">
            <summary>Satellite contract version attribute on the assembly '{0}' specifies an invalid version: {1}.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidOleVariantTypeException">
            <summary>Specified OLE variant was invalid.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidOperationException">
            <summary>Operation is not valid due to the current state of the object.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidSearchPattern">
            <summary>Search pattern '{0}' cannot contain ".." to move up directories and can be contained only internally in file/directory names, as in "a..b".</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidTypeInRetType">
            <summary>The return Type must be a type provided by the runtime.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidTypeInSignature">
            <summary>The signature Type array contains some invalid type (i.e. null, void)</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidUTF8String">
            <summary>The UTF8 string passed in could not be converted to Unicode.</summary>
        </member>
        <member name="P:System.SR.Arg_IOException">
            <summary>I/O error occurred.</summary>
        </member>
        <member name="P:System.SR.Arg_KeyNotFound">
            <summary>The given key was not present in the dictionary.</summary>
        </member>
        <member name="P:System.SR.Arg_KeyNotFoundWithKey">
            <summary>The given key '{0}' was not present in the dictionary.</summary>
        </member>
        <member name="P:System.SR.Arg_LongerThanDestArray">
            <summary>Destination array was not long enough. Check the destination index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:System.SR.Arg_LongerThanSrcArray">
            <summary>Source array was not long enough. Check the source index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:System.SR.Arg_LongerThanSrcString">
            <summary>Source string was not long enough. Check sourceIndex and count.</summary>
        </member>
        <member name="P:System.SR.Arg_LowerBoundsMustMatch">
            <summary>The arrays' lower bounds must be identical.</summary>
        </member>
        <member name="P:System.SR.Arg_MarshalAsAnyRestriction">
            <summary>AsAny cannot be used on return types, ByRef parameters, ArrayWithOffset, or parameters passed from unmanaged to managed.</summary>
        </member>
        <member name="P:System.SR.Arg_MarshalDirectiveException">
            <summary>Marshaling directives are invalid.</summary>
        </member>
        <member name="P:System.SR.Arg_MethodAccessException">
            <summary>Attempt to access the method failed.</summary>
        </member>
        <member name="P:System.SR.Arg_MethodAccessException_WithMethodName">
            <summary>Attempt to access the method "{0}" on type "{1}" failed.</summary>
        </member>
        <member name="P:System.SR.Arg_MissingFieldException">
            <summary>Attempted to access a non-existing field.</summary>
        </member>
        <member name="P:System.SR.Arg_MissingManifestResourceException">
            <summary>Unable to find manifest resource.</summary>
        </member>
        <member name="P:System.SR.Arg_MissingMemberException">
            <summary>Attempted to access a missing member.</summary>
        </member>
        <member name="P:System.SR.Arg_MissingMethodException">
            <summary>Attempted to access a missing method.</summary>
        </member>
        <member name="P:System.SR.Arg_MulticastNotSupportedException">
            <summary>Attempted to add multiple callbacks to a delegate that does not support multicast.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeBoolean">
            <summary>Object must be of type Boolean.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeByte">
            <summary>Object must be of type Byte.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeChar">
            <summary>Object must be of type Char.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeDateTime">
            <summary>Object must be of type DateTime.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeDateTimeOffset">
            <summary>Object must be of type DateTimeOffset.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeDecimal">
            <summary>Object must be of type Decimal.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeDelegate">
            <summary>Type must derive from Delegate.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeDouble">
            <summary>Object must be of type Double.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeDriveLetterOrRootDir">
            <summary>Drive name must be a root directory (i.e. 'C:\') or a drive letter ('C').</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeEnum">
            <summary>Type provided must be an Enum.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeEnumBaseTypeOrEnum">
            <summary>The value passed in must be an enum base or an underlying type for an enum, such as an Int32.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeGuid">
            <summary>Object must be of type GUID.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeInt16">
            <summary>Object must be of type Int16.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeInt32">
            <summary>Object must be of type Int32.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeInt64">
            <summary>Object must be of type Int64.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeInterface">
            <summary>Type passed must be an interface.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBePointer">
            <summary>Type must be a Pointer.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBePrimArray">
            <summary>Object must be an array of primitives.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeRuntimeAssembly">
            <summary>Object must be of type RuntimeAssembly.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeSByte">
            <summary>Object must be of type SByte.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeSingle">
            <summary>Object must be of type Single.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeStatic">
            <summary>Method must be a static method.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeString">
            <summary>Object must be of type String.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeTimeSpan">
            <summary>Object must be of type TimeSpan.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeType">
            <summary>Type must be a type provided by the runtime.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeTrue">
            <summary>Argument must be true.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeUInt16">
            <summary>Object must be of type UInt16.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeUInt32">
            <summary>Object must be of type UInt32.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeUInt64">
            <summary>Object must be of type UInt64.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeVersion">
            <summary>Object must be of type Version.</summary>
        </member>
        <member name="P:System.SR.Arg_MustContainEnumInfo">
            <summary>Must specify valid information for parsing in the string.</summary>
        </member>
        <member name="P:System.SR.Arg_NamedParamNull">
            <summary>Named parameter value must not be null.</summary>
        </member>
        <member name="P:System.SR.Arg_NamedParamTooBig">
            <summary>Named parameter array cannot be bigger than argument array.</summary>
        </member>
        <member name="P:System.SR.Arg_NDirectBadObject">
            <summary>No PInvoke conversion exists for value passed to Object-typed parameter.</summary>
        </member>
        <member name="P:System.SR.Arg_Need1DArray">
            <summary>Array was not a one-dimensional array.</summary>
        </member>
        <member name="P:System.SR.Arg_Need2DArray">
            <summary>Array was not a two-dimensional array.</summary>
        </member>
        <member name="P:System.SR.Arg_Need3DArray">
            <summary>Array was not a three-dimensional array.</summary>
        </member>
        <member name="P:System.SR.Arg_NeedAtLeast1Rank">
            <summary>Must provide at least one rank.</summary>
        </member>
        <member name="P:System.SR.Arg_NegativeArgCount">
            <summary>Argument count must not be negative.</summary>
        </member>
        <member name="P:System.SR.Arg_NoAccessSpec">
            <summary>Must specify binding flags describing the invoke operation required (BindingFlags.InvokeMethod CreateInstance GetField SetField GetProperty SetProperty).</summary>
        </member>
        <member name="P:System.SR.Arg_NoDefCTor">
            <summary>No parameterless constructor defined for type '{0}'.</summary>
        </member>
        <member name="P:System.SR.Arg_NoITypeInfo">
            <summary>Specified TypeInfo was invalid because it did not support the ITypeInfo interface.</summary>
        </member>
        <member name="P:System.SR.Arg_NoITypeLib">
            <summary>Specified TypeLib was invalid because it did not support the ITypeLib interface.</summary>
        </member>
        <member name="P:System.SR.Arg_NonZeroLowerBound">
            <summary>The lower bound of target array must be zero.</summary>
        </member>
        <member name="P:System.SR.Arg_NoStaticVirtual">
            <summary>Method cannot be both static and virtual.</summary>
        </member>
        <member name="P:System.SR.Arg_NotFiniteNumberException">
            <summary>Number encountered was not a finite quantity.</summary>
        </member>
        <member name="P:System.SR.Arg_NotFoundIFace">
            <summary>Interface not found.</summary>
        </member>
        <member name="P:System.SR.Arg_NotGenericMethodDefinition">
            <summary>{0} is not a GenericMethodDefinition. MakeGenericMethod may only be called on a method for which MethodBase.IsGenericMethodDefinition is true.</summary>
        </member>
        <member name="P:System.SR.Arg_NotGenericParameter">
            <summary>Method may only be called on a Type for which Type.IsGenericParameter is true.</summary>
        </member>
        <member name="P:System.SR.Arg_NotGenericTypeDefinition">
            <summary>{0} is not a GenericTypeDefinition. MakeGenericType may only be called on a type for which Type.IsGenericTypeDefinition is true.</summary>
        </member>
        <member name="P:System.SR.Arg_NotImplementedException">
            <summary>The method or operation is not implemented.</summary>
        </member>
        <member name="P:System.SR.Arg_NotSupportedException">
            <summary>Specified method is not supported.</summary>
        </member>
        <member name="P:System.SR.Arg_NullIndex">
            <summary>Arrays indexes must be set to an object instance.</summary>
        </member>
        <member name="P:System.SR.Arg_NullReferenceException">
            <summary>Object reference not set to an instance of an object.</summary>
        </member>
        <member name="P:System.SR.Arg_ObjObj">
            <summary>Object type cannot be converted to target type.</summary>
        </member>
        <member name="P:System.SR.Arg_ObjObjEx">
            <summary>Object of type '{0}' cannot be converted to type '{1}'.</summary>
        </member>
        <member name="P:System.SR.Arg_OleAutDateInvalid">
            <summary>Not a legal OleAut date.</summary>
        </member>
        <member name="P:System.SR.Arg_OleAutDateScale">
            <summary>OleAut date did not convert to a DateTime correctly.</summary>
        </member>
        <member name="P:System.SR.Arg_OverflowException">
            <summary>Arithmetic operation resulted in an overflow.</summary>
        </member>
        <member name="P:System.SR.Arg_OutOfMemoryException">
            <summary>Insufficient memory to continue the execution of the program.</summary>
        </member>
        <member name="P:System.SR.Arg_ParamName_Name">
            <summary>(Parameter '{0}')</summary>
        </member>
        <member name="P:System.SR.Arg_ParmArraySize">
            <summary>Must specify one or more parameters.</summary>
        </member>
        <member name="P:System.SR.Arg_ParmCnt">
            <summary>Parameter count mismatch.</summary>
        </member>
        <member name="P:System.SR.Arg_PathEmpty">
            <summary>The path is empty.</summary>
        </member>
        <member name="P:System.SR.Arg_PathIllegalUNC_Path">
            <summary>The UNC path '{0}' should be of the form \\\\server\\share.</summary>
        </member>
        <member name="P:System.SR.Arg_PlatformNotSupported">
            <summary>Operation is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.Arg_PrimWiden">
            <summary>Cannot widen from source type to target type either because the source type is a not a primitive type or the conversion cannot be accomplished.</summary>
        </member>
        <member name="P:System.SR.Arg_PropSetGet">
            <summary>Cannot specify both Get and Set on a property.</summary>
        </member>
        <member name="P:System.SR.Arg_PropSetInvoke">
            <summary>Cannot specify Set on a property and Invoke on a method.</summary>
        </member>
        <member name="P:System.SR.Arg_RankException">
            <summary>Attempted to operate on an array with the incorrect number of dimensions.</summary>
        </member>
        <member name="P:System.SR.Arg_RankIndices">
            <summary>Indices length does not match the array rank.</summary>
        </member>
        <member name="P:System.SR.Arg_RankMultiDimNotSupported">
            <summary>Only single dimensional arrays are supported for the requested action.</summary>
        </member>
        <member name="P:System.SR.Arg_RanksAndBounds">
            <summary>Number of lengths and lowerBounds must match.</summary>
        </member>
        <member name="P:System.SR.Arg_RegGetOverflowBug">
            <summary>RegistryKey.GetValue does not allow a String that has a length greater than Int32.MaxValue.</summary>
        </member>
        <member name="P:System.SR.Arg_RegKeyNotFound">
            <summary>The specified registry key does not exist.</summary>
        </member>
        <member name="P:System.SR.Arg_RegSubKeyValueAbsent">
            <summary>No value exists with that name.</summary>
        </member>
        <member name="P:System.SR.Arg_RegValStrLenBug">
            <summary>Registry value names should not be greater than 16,383 characters.</summary>
        </member>
        <member name="P:System.SR.Arg_ResMgrNotResSet">
            <summary>Type parameter must refer to a subclass of ResourceSet.</summary>
        </member>
        <member name="P:System.SR.Arg_ResourceFileUnsupportedVersion">
            <summary>The ResourceReader class does not know how to read this version of .resources files. Expected version: {0}  This file: {1}</summary>
        </member>
        <member name="P:System.SR.Arg_ResourceNameNotExist">
            <summary>The specified resource name "{0}" does not exist in the resource file.</summary>
        </member>
        <member name="P:System.SR.Arg_SafeArrayRankMismatchException">
            <summary>Specified array was not of the expected rank.</summary>
        </member>
        <member name="P:System.SR.Arg_SafeArrayTypeMismatchException">
            <summary>Specified array was not of the expected type.</summary>
        </member>
        <member name="P:System.SR.Arg_SecurityException">
            <summary>Security error.</summary>
        </member>
        <member name="P:System.SR.SerializationException">
            <summary>Serialization error.</summary>
        </member>
        <member name="P:System.SR.Arg_SetMethNotFnd">
            <summary>Property set method not found.</summary>
        </member>
        <member name="P:System.SR.Arg_StackOverflowException">
            <summary>Operation caused a stack overflow.</summary>
        </member>
        <member name="P:System.SR.Arg_SurrogatesNotAllowedAsSingleChar">
            <summary>Unicode surrogate characters must be written out as pairs together in the same call, not individually. Consider passing in a character array instead.</summary>
        </member>
        <member name="P:System.SR.Arg_SynchronizationLockException">
            <summary>Object synchronization method was called from an unsynchronized block of code.</summary>
        </member>
        <member name="P:System.SR.Arg_SystemException">
            <summary>System error.</summary>
        </member>
        <member name="P:System.SR.Arg_TargetInvocationException">
            <summary>Exception has been thrown by the target of an invocation.</summary>
        </member>
        <member name="P:System.SR.Arg_TargetParameterCountException">
            <summary>Number of parameters specified does not match the expected number.</summary>
        </member>
        <member name="P:System.SR.Arg_ThreadStartException">
            <summary>Thread failed to start.</summary>
        </member>
        <member name="P:System.SR.Arg_ThreadStateException">
            <summary>Thread was in an invalid state for the operation being executed.</summary>
        </member>
        <member name="P:System.SR.Arg_TimeoutException">
            <summary>The operation has timed out.</summary>
        </member>
        <member name="P:System.SR.Arg_TypeAccessException">
            <summary>Attempt to access the type failed.</summary>
        </member>
        <member name="P:System.SR.Arg_TypedReference_Null">
            <summary>The TypedReference must be initialized.</summary>
        </member>
        <member name="P:System.SR.Arg_TypeLoadException">
            <summary>Failure has occurred while loading a type.</summary>
        </member>
        <member name="P:System.SR.Arg_TypeLoadNullStr">
            <summary>A null or zero length string does not represent a valid Type.</summary>
        </member>
        <member name="P:System.SR.Arg_TypeRefPrimitve">
            <summary>TypedReferences cannot be redefined as primitives. Field name '{0}'.</summary>
        </member>
        <member name="P:System.SR.Arg_TypeUnloadedException">
            <summary>Type had been unloaded.</summary>
        </member>
        <member name="P:System.SR.Arg_UnauthorizedAccessException">
            <summary>Attempted to perform an unauthorized operation.</summary>
        </member>
        <member name="P:System.SR.Arg_UnboundGenField">
            <summary>Late bound operations cannot be performed on fields with types for which Type.ContainsGenericParameters is true.</summary>
        </member>
        <member name="P:System.SR.Arg_UnboundGenParam">
            <summary>Late bound operations cannot be performed on types or methods for which ContainsGenericParameters is true.</summary>
        </member>
        <member name="P:System.SR.Arg_UnknownTypeCode">
            <summary>Unknown TypeCode value.</summary>
        </member>
        <member name="P:System.SR.Arg_VarMissNull">
            <summary>Missing parameter does not have a default value.</summary>
        </member>
        <member name="P:System.SR.Arg_VersionString">
            <summary>Version string portion was too short or too long.</summary>
        </member>
        <member name="P:System.SR.Arg_WrongAsyncResult">
            <summary>IAsyncResult object did not come from the corresponding async method on this type.</summary>
        </member>
        <member name="P:System.SR.Arg_WrongType">
            <summary>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</summary>
        </member>
        <member name="P:System.SR.Argument_AbsolutePathRequired">
            <summary>Absolute path information is required.</summary>
        </member>
        <member name="P:System.SR.Argument_AddingDuplicate">
            <summary>An item with the same key has already been added.</summary>
        </member>
        <member name="P:System.SR.Argument_AddingDuplicate__">
            <summary>Item has already been added. Key in dictionary: '{0}'  Key being added: '{1}'</summary>
        </member>
        <member name="P:System.SR.Argument_AddingDuplicateWithKey">
            <summary>An item with the same key has already been added. Key: {0}</summary>
        </member>
        <member name="P:System.SR.Argument_AdjustmentRulesNoNulls">
            <summary>The AdjustmentRule array cannot contain null elements.</summary>
        </member>
        <member name="P:System.SR.Argument_AdjustmentRulesOutOfOrder">
            <summary>The elements of the AdjustmentRule array must be in chronological order and must not overlap.</summary>
        </member>
        <member name="P:System.SR.Argument_AlreadyACCW">
            <summary>The object already has a CCW associated with it.</summary>
        </member>
        <member name="P:System.SR.Argument_AlreadyBoundOrSyncHandle">
            <summary>'handle' has already been bound to the thread pool, or was not opened for asynchronous I/O.</summary>
        </member>
        <member name="P:System.SR.Argument_ArgumentZero">
            <summary>Argument cannot be zero.</summary>
        </member>
        <member name="P:System.SR.Argument_ArrayGetInterfaceMap">
            <summary>Interface maps for generic interfaces on arrays cannot be retrieved.</summary>
        </member>
        <member name="P:System.SR.Argument_ArraysInvalid">
            <summary>Array or pointer types are not valid.</summary>
        </member>
        <member name="P:System.SR.Argument_AttributeNamesMustBeUnique">
            <summary>Attribute names must be unique.</summary>
        </member>
        <member name="P:System.SR.Argument_BadAttributeOnInterfaceMethod">
            <summary>Interface method must be abstract and virtual.</summary>
        </member>
        <member name="P:System.SR.Argument_BadConstantValue">
            <summary>Bad default value.</summary>
        </member>
        <member name="P:System.SR.Argument_BadConstructor">
            <summary>Cannot have private or static constructor.</summary>
        </member>
        <member name="P:System.SR.Argument_BadConstructorCallConv">
            <summary>Constructor must have standard calling convention.</summary>
        </member>
        <member name="P:System.SR.Argument_BadExceptionCodeGen">
            <summary>Incorrect code generation for exception block.</summary>
        </member>
        <member name="P:System.SR.Argument_BadFieldForConstructorBuilder">
            <summary>Field must be on the same type of the given ConstructorInfo.</summary>
        </member>
        <member name="P:System.SR.Argument_BadFieldSig">
            <summary>Field signatures do not have return types.</summary>
        </member>
        <member name="P:System.SR.Argument_BadFieldType">
            <summary>Bad field type in defining field.</summary>
        </member>
        <member name="P:System.SR.Argument_BadFormatSpecifier">
            <summary>Format specifier was invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_BadImageFormatExceptionResolve">
            <summary>A BadImageFormatException has been thrown while parsing the signature. This is likely due to lack of a generic context. Ensure genericTypeArguments and genericMethodArguments are provided and contain enough context.</summary>
        </member>
        <member name="P:System.SR.Argument_BadLabel">
            <summary>Bad label in ILGenerator.</summary>
        </member>
        <member name="P:System.SR.Argument_BadLabelContent">
            <summary>Bad label content in ILGenerator.</summary>
        </member>
        <member name="P:System.SR.Argument_BadNestedTypeFlags">
            <summary>Visibility of interfaces must be one of the following: NestedAssembly, NestedFamANDAssem, NestedFamily, NestedFamORAssem, NestedPrivate or NestedPublic.</summary>
        </member>
        <member name="P:System.SR.Argument_BadObjRef">
            <summary>Invalid ObjRef provided to '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_BadParameterCountsForConstructor">
            <summary>Parameter count does not match passed in argument value count.</summary>
        </member>
        <member name="P:System.SR.Argument_BadParameterTypeForCAB">
            <summary>Cannot emit a CustomAttribute with argument of type {0}.</summary>
        </member>
        <member name="P:System.SR.Argument_BadPropertyForConstructorBuilder">
            <summary>Property must be on the same type of the given ConstructorInfo.</summary>
        </member>
        <member name="P:System.SR.Argument_BadSigFormat">
            <summary>Incorrect signature format.</summary>
        </member>
        <member name="P:System.SR.Argument_BadSizeForData">
            <summary>Data size must be &gt; 1 and &lt; 0x3f0000</summary>
        </member>
        <member name="P:System.SR.Argument_BadTypeAttrInvalidLayout">
            <summary>Bad type attributes. Invalid layout attribute specified.</summary>
        </member>
        <member name="P:System.SR.Argument_BadTypeAttrNestedVisibilityOnNonNestedType">
            <summary>Bad type attributes. Nested visibility flag set on a non-nested type.</summary>
        </member>
        <member name="P:System.SR.Argument_BadTypeAttrNonNestedVisibilityNestedType">
            <summary>Bad type attributes. Non-nested visibility flag set on a nested type.</summary>
        </member>
        <member name="P:System.SR.Argument_BadTypeAttrReservedBitsSet">
            <summary>Bad type attributes. Reserved bits set on the type.</summary>
        </member>
        <member name="P:System.SR.Argument_BadTypeInCustomAttribute">
            <summary>An invalid type was used as a custom attribute constructor argument, field or property.</summary>
        </member>
        <member name="P:System.SR.Argument_CannotCreateTypedReference">
            <summary>Cannot use function evaluation to create a TypedReference object.</summary>
        </member>
        <member name="P:System.SR.Argument_CannotGetTypeTokenForByRef">
            <summary>Cannot get TypeToken for a ByRef type.</summary>
        </member>
        <member name="P:System.SR.Argument_CannotSetParentToInterface">
            <summary>Cannot set parent to an interface.</summary>
        </member>
        <member name="P:System.SR.Argument_CodepageNotSupported">
            <summary>{0} is not a supported code page.</summary>
        </member>
        <member name="P:System.SR.Argument_CompareOptionOrdinal">
            <summary>CompareOption.Ordinal cannot be used with other options.</summary>
        </member>
        <member name="P:System.SR.Argument_ConflictingDateTimeRoundtripStyles">
            <summary>The DateTimeStyles value RoundtripKind cannot be used with the values AssumeLocal, AssumeUniversal or AdjustToUniversal.</summary>
        </member>
        <member name="P:System.SR.Argument_ConflictingDateTimeStyles">
            <summary>The DateTimeStyles values AssumeLocal and AssumeUniversal cannot be used together.</summary>
        </member>
        <member name="P:System.SR.Argument_ConstantDoesntMatch">
            <summary>Constant does not match the defined type.</summary>
        </member>
        <member name="P:System.SR.Argument_ConstantNotSupported">
            <summary>{0} is not a supported constant type.</summary>
        </member>
        <member name="P:System.SR.Argument_ConstantNull">
            <summary>Null is not a valid constant value for this type.</summary>
        </member>
        <member name="P:System.SR.Argument_ConstructorNeedGenericDeclaringType">
            <summary>The specified constructor must be declared on a generic type definition.</summary>
        </member>
        <member name="P:System.SR.Argument_ConversionOverflow">
            <summary>Conversion buffer overflow.</summary>
        </member>
        <member name="P:System.SR.Argument_ConvertMismatch">
            <summary>The conversion could not be completed because the supplied DateTime did not have the Kind property set correctly.  For example, when the Kind property is DateTimeKind.Local, the source time zone must be TimeZoneInfo.Local.</summary>
        </member>
        <member name="P:System.SR.Argument_CORDBBadMethod">
            <summary>Cannot find the method on the object instance.</summary>
        </member>
        <member name="P:System.SR.Argument_CORDBBadVarArgCallConv">
            <summary>Cannot evaluate a VarArgs function.</summary>
        </member>
        <member name="P:System.SR.Argument_CultureIetfNotSupported">
            <summary>Culture IETF Name {0} is not a recognized IETF name.</summary>
        </member>
        <member name="P:System.SR.Argument_CultureInvalidIdentifier">
            <summary>{0} is an invalid culture identifier.</summary>
        </member>
        <member name="P:System.SR.Argument_CultureIsNeutral">
            <summary>Culture ID {0} (0x{0:X4}) is a neutral culture; a region cannot be created from it.</summary>
        </member>
        <member name="P:System.SR.Argument_CultureNotSupported">
            <summary>Culture is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_CustomAssemblyLoadContextRequestedNameMismatch">
            <summary>Resolved assembly's simple name should be the same as of the requested assembly.</summary>
        </member>
        <member name="P:System.SR.Argument_CustomCultureCannotBePassedByNumber">
            <summary>Customized cultures cannot be passed by LCID, only by name.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeBadBinaryData">
            <summary>The binary data must result in a DateTime with ticks between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeHasTicks">
            <summary>The supplied DateTime must have the Year, Month, and Day properties set to 1.  The time cannot be specified more precisely than whole milliseconds.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeHasTimeOfDay">
            <summary>The supplied DateTime includes a TimeOfDay setting.   This is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeIsInvalid">
            <summary>The supplied DateTime represents an invalid time.  For example, when the clock is adjusted forward, any time in the period that is skipped is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeIsNotAmbiguous">
            <summary>The supplied DateTime is not in an ambiguous time range.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeKindMustBeUnspecified">
            <summary>The supplied DateTime must have the Kind property set to DateTimeKind.Unspecified.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeKindMustBeUnspecifiedOrUtc">
            <summary>The supplied DateTime must have the Kind property set to DateTimeKind.Unspecified or DateTimeKind.Utc.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeOffsetInvalidDateTimeStyles">
            <summary>The DateTimeStyles value 'NoCurrentDateDefault' is not allowed when parsing DateTimeOffset.</summary>
        </member>
        <member name="P:System.SR.Argument_DateTimeOffsetIsNotAmbiguous">
            <summary>The supplied DateTimeOffset is not in an ambiguous time range.</summary>
        </member>
        <member name="P:System.SR.Argument_DestinationTooShort">
            <summary>Destination is too short.</summary>
        </member>
        <member name="P:System.SR.Argument_DuplicateTypeName">
            <summary>Duplicate type name within an assembly.</summary>
        </member>
        <member name="P:System.SR.Argument_EmitWriteLineType">
            <summary>EmitWriteLine does not support this field or local type.</summary>
        </member>
        <member name="P:System.SR.Argument_EmptyDecString">
            <summary>Decimal separator cannot be the empty string.</summary>
        </member>
        <member name="P:System.SR.Argument_EmptyFileName">
            <summary>Empty file name is not legal.</summary>
        </member>
        <member name="P:System.SR.Argument_EmptyName">
            <summary>Empty name is not legal.</summary>
        </member>
        <member name="P:System.SR.Argument_EmptyPath">
            <summary>Empty path name is not legal.</summary>
        </member>
        <member name="P:System.SR.Argument_EmptyWaithandleArray">
            <summary>Waithandle array may not be empty.</summary>
        </member>
        <member name="P:System.SR.Argument_EncoderFallbackNotEmpty">
            <summary>Must complete Convert() operation or call Encoder.Reset() before calling GetBytes() or GetByteCount(). Encoder '{0}' fallback '{1}'.</summary>
        </member>
        <member name="P:System.SR.Argument_EncodingConversionOverflowBytes">
            <summary>The output byte buffer is too small to contain the encoded data, encoding '{0}' fallback '{1}'.</summary>
        </member>
        <member name="P:System.SR.Argument_EncodingConversionOverflowChars">
            <summary>The output char buffer is too small to contain the decoded characters, encoding '{0}' fallback '{1}'.</summary>
        </member>
        <member name="P:System.SR.Argument_EncodingNotSupported">
            <summary>'{0}' is not a supported encoding name. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method.</summary>
        </member>
        <member name="P:System.SR.Argument_EnumTypeDoesNotMatch">
            <summary>The argument type, '{0}', is not the same as the enum type '{1}'.</summary>
        </member>
        <member name="P:System.SR.Argument_FallbackBufferNotEmpty">
            <summary>Cannot change fallback when buffer is not empty. Previous Convert() call left data in the fallback buffer.</summary>
        </member>
        <member name="P:System.SR.Argument_FieldDeclaringTypeGeneric">
            <summary>Cannot resolve field {0} because the declaring type of the field handle {1} is generic. Explicitly provide the declaring type to GetFieldFromHandle.</summary>
        </member>
        <member name="P:System.SR.Argument_FieldNeedGenericDeclaringType">
            <summary>The specified field must be declared on a generic type definition.</summary>
        </member>
        <member name="P:System.SR.Argument_GenConstraintViolation">
            <summary>GenericArguments[{0}], '{1}', on '{2}' violates the constraint of type '{3}'.</summary>
        </member>
        <member name="P:System.SR.Argument_GenericArgsCount">
            <summary>The number of generic arguments provided doesn't equal the arity of the generic type definition.</summary>
        </member>
        <member name="P:System.SR.Argument_GenericsInvalid">
            <summary>Generic types are not valid.</summary>
        </member>
        <member name="P:System.SR.Argument_GlobalFunctionHasToBeStatic">
            <summary>Global members must be static.</summary>
        </member>
        <member name="P:System.SR.Argument_HandleLeak">
            <summary>Cannot pass a GCHandle across AppDomains.</summary>
        </member>
        <member name="P:System.SR.Argument_HasToBeArrayClass">
            <summary>Must be an array type.</summary>
        </member>
        <member name="P:System.SR.Argument_IdnBadBidi">
            <summary>Left to right characters may not be mixed with right to left characters in IDN labels.</summary>
        </member>
        <member name="P:System.SR.Argument_IdnBadLabelSize">
            <summary>IDN labels must be between 1 and 63 characters long.</summary>
        </member>
        <member name="P:System.SR.Argument_IdnBadNameSize">
            <summary>IDN names must be between 1 and {0} characters long.</summary>
        </member>
        <member name="P:System.SR.Argument_IdnBadPunycode">
            <summary>Invalid IDN encoded string.</summary>
        </member>
        <member name="P:System.SR.Argument_IdnBadStd3">
            <summary>Label contains character '{0}' not allowed with UseStd3AsciiRules</summary>
        </member>
        <member name="P:System.SR.Argument_IdnIllegalName">
            <summary>Decoded string is not a valid IDN name.</summary>
        </member>
        <member name="P:System.SR.Argument_IllegalEnvVarName">
            <summary>Environment variable name cannot contain equal character.</summary>
        </member>
        <member name="P:System.SR.Argument_IllegalName">
            <summary>Illegal name.</summary>
        </member>
        <member name="P:System.SR.Argument_ImplementIComparable">
            <summary>At least one object must implement IComparable.</summary>
        </member>
        <member name="P:System.SR.Argument_IndexOutOfArrayBounds">
            <summary>The specified index is out of bounds of the specified array.</summary>
        </member>
        <member name="P:System.SR.Argument_InsufficientSpaceToCopyCollection">
            <summary>The specified space is not sufficient to copy the elements from this Collection.</summary>
        </member>
        <member name="P:System.SR.Argument_InterfaceMap">
            <summary>'this' type cannot be an interface itself.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidAppendMode">
            <summary>Append access can be requested only in write-only mode.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidArgumentForComparison">
            <summary>Type of argument is not compatible with the generic comparer.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidArrayLength">
            <summary>Length of the array must be {0}.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidArrayType">
            <summary>Target array type is not compatible with the type of items in the collection.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidAssemblyName">
            <summary>Assembly names may not begin with whitespace or contain the characters '/', or '\\' or ':'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidCalendar">
            <summary>Not a valid calendar for the given culture.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidCharSequence">
            <summary>Invalid Unicode code point found at index {0}.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidCharSequenceNoIndex">
            <summary>String contains invalid Unicode code points.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidCodePageBytesIndex">
            <summary>Unable to translate bytes {0} at index {1} from specified code page to Unicode.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidCodePageConversionIndex">
            <summary>Unable to translate Unicode character \\u{0:X4} at index {1} to specified code page.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidConstructorDeclaringType">
            <summary>The specified constructor must be declared on the generic type definition of the specified type.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidConstructorInfo">
            <summary>The ConstructorInfo object is not valid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidCultureName">
            <summary>Culture name '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidDateTimeKind">
            <summary>Invalid DateTimeKind value.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidDateTimeStyles">
            <summary>An undefined DateTimeStyles value is being used.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidDigitSubstitution">
            <summary>The DigitSubstitution property must be of a valid member of the DigitShapes enumeration. Valid entries include Context, NativeNational or None.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidElementName">
            <summary>Invalid element name '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidElementTag">
            <summary>Invalid element tag '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidElementText">
            <summary>Invalid element text '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidElementValue">
            <summary>Invalid element value '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidEnum">
            <summary>The Enum type should contain one and only one instance field.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidEnumValue">
            <summary>The value '{0}' is not valid for this usage of the type {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidFieldDeclaringType">
            <summary>The specified field must be declared on the generic type definition of the specified type.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidFileModeAndAccessCombo">
            <summary>Combining FileMode: {0} with FileAccess: {1} is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidFlag">
            <summary>Value of flags is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidGenericArg">
            <summary>The generic type parameter was not valid</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidGenericInstArray">
            <summary>Generic arguments must be provided for each generic parameter and each generic argument must be a RuntimeType.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidGroupSize">
            <summary>Every element in the value array should be between one and nine, except for the last element, which can be zero.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidHandle">
            <summary>The handle is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidHighSurrogate">
            <summary>Found a high surrogate char without a following low surrogate at index: {0}. The input may not be in this encoding, or may not contain valid Unicode (UTF-16) characters.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidId">
            <summary>The specified ID parameter '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidKindOfTypeForCA">
            <summary>This type cannot be represented as a custom attribute.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidLabel">
            <summary>Invalid Label.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidLowSurrogate">
            <summary>Found a low surrogate char without a preceding high surrogate at index: {0}. The input may not be in this encoding, or may not contain valid Unicode (UTF-16) characters.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidMemberForNamedArgument">
            <summary>The member must be either a field or a property.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidMethodDeclaringType">
            <summary>The specified method must be declared on the generic type definition of the specified type.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidName">
            <summary>Invalid name.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidNativeDigitCount">
            <summary>The NativeDigits array must contain exactly ten members.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidNativeDigitValue">
            <summary>Each member of the NativeDigits array must be a single text element (one or more UTF16 code points) with a Unicode Nd (Number, Decimal Digit) property indicating it is a digit.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidNeutralRegionName">
            <summary>The region name {0} should not correspond to neutral culture; a specific culture name is required.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidNormalizationForm">
            <summary>Invalid or unsupported normalization form.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidNumberStyles">
            <summary>An undefined NumberStyles value is being used.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidOffLen">
            <summary>Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidOpCodeOnDynamicMethod">
            <summary>Ldtoken, Ldftn and Ldvirtftn OpCodes cannot target DynamicMethods.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidParameterInfo">
            <summary>The ParameterInfo object is not valid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidParamInfo">
            <summary>Invalid type for ParameterInfo member in Attribute class.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidPathChars">
            <summary>Illegal characters in path.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidRegistryViewCheck">
            <summary>The specified RegistryView value is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidResourceCultureName">
            <summary>The given culture name '{0}' cannot be used to locate a resource file. Resource filenames must consist of only letters, numbers, hyphens or underscores.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidSafeBufferOffLen">
            <summary>Offset and length were greater than the size of the SafeBuffer.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidSeekOrigin">
            <summary>Invalid seek origin.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidSerializedString">
            <summary>The specified serialized string '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidStartupHookSignature">
            <summary>The signature of the startup hook '{0}' in assembly '{1}' was invalid. It must be 'public static void Initialize()'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidTimeSpanStyles">
            <summary>An undefined TimeSpanStyles value is being used.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidToken">
            <summary>Token {0:x} is not valid in the scope of module {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidTypeForCA">
            <summary>Cannot build type parameter for custom attribute with a type that does not support the AssemblyQualifiedName property. The type instance supplied was of type '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidTypeForDynamicMethod">
            <summary>Invalid type owner for DynamicMethod.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidTypeName">
            <summary>The name of the type is invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidTypeWithPointersNotSupported">
            <summary>Cannot use type '{0}'. Only value types without pointers or references are supported.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidUnity">
            <summary>Type '{0}' is not deserializable.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidValue">
            <summary>Value was invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_LargeInteger">
            <summary>Integer or token was too large to be encoded.</summary>
        </member>
        <member name="P:System.SR.Argument_LongEnvVarValue">
            <summary>Environment variable name or value is too long.</summary>
        </member>
        <member name="P:System.SR.Argument_MethodDeclaringTypeGeneric">
            <summary>Cannot resolve method {0} because the declaring type of the method handle {1} is generic. Explicitly provide the declaring type to GetMethodFromHandle.</summary>
        </member>
        <member name="P:System.SR.Argument_MethodDeclaringTypeGenericLcg">
            <summary>Method '{0}' has a generic declaring type '{1}'. Explicitly provide the declaring type to GetTokenFor.</summary>
        </member>
        <member name="P:System.SR.Argument_MethodNeedGenericDeclaringType">
            <summary>The specified method cannot be dynamic or global and must be declared on a generic type definition.</summary>
        </member>
        <member name="P:System.SR.Argument_MinMaxValue">
            <summary>'{0}' cannot be greater than {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_MismatchedArrays">
            <summary>Two arrays, {0} and {1}, must be of  the same size.</summary>
        </member>
        <member name="P:System.SR.Argument_MissingDefaultConstructor">
            <summary>was missing default constructor.</summary>
        </member>
        <member name="P:System.SR.Argument_MustBeFalse">
            <summary>Argument must be initialized to false</summary>
        </member>
        <member name="P:System.SR.Argument_MustBeRuntimeAssembly">
            <summary>Assembly must be a runtime Assembly object.</summary>
        </member>
        <member name="P:System.SR.Argument_MustBeRuntimeFieldInfo">
            <summary>FieldInfo must be a runtime FieldInfo object.</summary>
        </member>
        <member name="P:System.SR.Argument_MustBeRuntimeMethodInfo">
            <summary>MethodInfo must be a runtime MethodInfo object.</summary>
        </member>
        <member name="P:System.SR.Argument_MustBeRuntimeReflectionObject">
            <summary>The object must be a runtime Reflection object.</summary>
        </member>
        <member name="P:System.SR.Argument_MustBeRuntimeType">
            <summary>Type must be a runtime Type object.</summary>
        </member>
        <member name="P:System.SR.Argument_MustBeTypeBuilder">
            <summary>'type' must contain a TypeBuilder as a generic argument.</summary>
        </member>
        <member name="P:System.SR.Argument_MustHaveAttributeBaseClass">
            <summary>Type passed in must be derived from System.Attribute or System.Attribute itself.</summary>
        </member>
        <member name="P:System.SR.Argument_MustHaveLayoutOrBeBlittable">
            <summary>The specified structure must be blittable or have layout information.</summary>
        </member>
        <member name="P:System.SR.Argument_NativeOverlappedAlreadyFree">
            <summary>'overlapped' has already been freed.</summary>
        </member>
        <member name="P:System.SR.Argument_NativeOverlappedWrongBoundHandle">
            <summary>'overlapped' was not allocated by this ThreadPoolBoundHandle instance.</summary>
        </member>
        <member name="P:System.SR.Argument_NeedGenericMethodDefinition">
            <summary>Method must represent a generic method definition on a generic type definition.</summary>
        </member>
        <member name="P:System.SR.Argument_NeedNonGenericObject">
            <summary>The specified object must not be an instance of a generic type.</summary>
        </member>
        <member name="P:System.SR.Argument_NeedNonGenericType">
            <summary>The specified Type must not be a generic type definition.</summary>
        </member>
        <member name="P:System.SR.Argument_NeedStructWithNoRefs">
            <summary>The specified Type must be a struct containing no references.</summary>
        </member>
        <member name="P:System.SR.Argument_NeverValidGenericArgument">
            <summary>The type '{0}' may not be used as a type argument.</summary>
        </member>
        <member name="P:System.SR.Argument_NoDomainManager">
            <summary>The domain manager specified by the host could not be instantiated.</summary>
        </member>
        <member name="P:System.SR.Argument_NoEra">
            <summary>No Era was supplied.</summary>
        </member>
        <member name="P:System.SR.Argument_NoModuleFileExtension">
            <summary>Module file name '{0}' must have file extension.</summary>
        </member>
        <member name="P:System.SR.Argument_NoRegionInvariantCulture">
            <summary>There is no region associated with the Invariant Culture (Culture ID: 0x7F).</summary>
        </member>
        <member name="P:System.SR.Argument_NotATP">
            <summary>Type must be a TransparentProxy</summary>
        </member>
        <member name="P:System.SR.Argument_NotAWritableProperty">
            <summary>Not a writable property.</summary>
        </member>
        <member name="P:System.SR.Argument_NotEnoughBytesToRead">
            <summary>There are not enough bytes remaining in the accessor to read at this position.</summary>
        </member>
        <member name="P:System.SR.Argument_NotEnoughBytesToWrite">
            <summary>There are not enough bytes remaining in the accessor to write at this position.</summary>
        </member>
        <member name="P:System.SR.Argument_NotEnoughGenArguments">
            <summary>The type or method has {1} generic parameter(s), but {0} generic argument(s) were provided. A generic argument must be provided for each generic parameter.</summary>
        </member>
        <member name="P:System.SR.Argument_NotExceptionType">
            <summary>Does not extend Exception.</summary>
        </member>
        <member name="P:System.SR.Argument_NotInExceptionBlock">
            <summary>Not currently in an exception block.</summary>
        </member>
        <member name="P:System.SR.Argument_NotMethodCallOpcode">
            <summary>The specified opcode cannot be passed to EmitCall.</summary>
        </member>
        <member name="P:System.SR.Argument_NotSerializable">
            <summary>Argument passed in is not serializable.</summary>
        </member>
        <member name="P:System.SR.Argument_NoUnderlyingCCW">
            <summary>The object has no underlying COM data associated with it.</summary>
        </member>
        <member name="P:System.SR.Argument_NoUninitializedStrings">
            <summary>Uninitialized Strings cannot be created.</summary>
        </member>
        <member name="P:System.SR.Argument_ObjIsWinRTObject">
            <summary>The object's type must not be a Windows Runtime type.</summary>
        </member>
        <member name="P:System.SR.Argument_ObjNotComObject">
            <summary>The object's type must be __ComObject or derived from __ComObject.</summary>
        </member>
        <member name="P:System.SR.Argument_OffsetAndCapacityOutOfBounds">
            <summary>Offset and capacity were greater than the size of the view.</summary>
        </member>
        <member name="P:System.SR.Argument_OffsetLocalMismatch">
            <summary>The UTC Offset of the local dateTime parameter does not match the offset argument.</summary>
        </member>
        <member name="P:System.SR.Argument_OffsetOfFieldNotFound">
            <summary>Field passed in is not a marshaled member of the type '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_OffsetOutOfRange">
            <summary>Offset must be within plus or minus 14 hours.</summary>
        </member>
        <member name="P:System.SR.Argument_OffsetPrecision">
            <summary>Offset must be specified in whole minutes.</summary>
        </member>
        <member name="P:System.SR.Argument_OffsetUtcMismatch">
            <summary>The UTC Offset for Utc DateTime instances must be 0.</summary>
        </member>
        <member name="P:System.SR.Argument_OneOfCulturesNotSupported">
            <summary>Culture name {0} or {1} is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_OnlyMscorlib">
            <summary>Only mscorlib's assembly is valid.</summary>
        </member>
        <member name="P:System.SR.Argument_OutOfOrderDateTimes">
            <summary>The DateStart property must come before the DateEnd property.</summary>
        </member>
        <member name="P:System.SR.Argument_PathEmpty">
            <summary>Path cannot be the empty string or all whitespace.</summary>
        </member>
        <member name="P:System.SR.Argument_PathFormatNotSupported_Path">
            <summary>The format of the path '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_PreAllocatedAlreadyAllocated">
            <summary>'preAllocated' is already in use.</summary>
        </member>
        <member name="P:System.SR.Argument_RecursiveFallback">
            <summary>Recursive fallback not allowed for character \\u{0:X4}.</summary>
        </member>
        <member name="P:System.SR.Argument_RecursiveFallbackBytes">
            <summary>Recursive fallback not allowed for bytes {0}.</summary>
        </member>
        <member name="P:System.SR.Argument_RedefinedLabel">
            <summary>Label multiply defined.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveField">
            <summary>Token {0:x} is not a valid FieldInfo token in the scope of module {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveFieldHandle">
            <summary>Type handle '{0}' and field handle with declaring type '{1}' are incompatible. Get RuntimeFieldHandle and declaring RuntimeTypeHandle off the same FieldInfo.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveMember">
            <summary>Token {0:x} is not a valid MemberInfo token in the scope of module {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveMethod">
            <summary>Token {0:x} is not a valid MethodBase token in the scope of module {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveMethodHandle">
            <summary>Type handle '{0}' and method handle with declaring type '{1}' are incompatible. Get RuntimeMethodHandle and declaring RuntimeTypeHandle off the same MethodBase.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveModuleType">
            <summary>Token {0} resolves to the special module type representing this module.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveString">
            <summary>Token {0:x} is not a valid string token in the scope of module {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_ResolveType">
            <summary>Token {0:x} is not a valid Type token in the scope of module {1}.</summary>
        </member>
        <member name="P:System.SR.Argument_ResultCalendarRange">
            <summary>The result is out of the supported range for this calendar. The result should be between {0} (Gregorian date) and {1} (Gregorian date), inclusive.</summary>
        </member>
        <member name="P:System.SR.Argument_SemaphoreInitialMaximum">
            <summary>The initial count for the semaphore must be greater than or equal to zero and less than the maximum count.</summary>
        </member>
        <member name="P:System.SR.Argument_ShouldNotSpecifyExceptionType">
            <summary>Should not specify exception type for catch clause for filter block.</summary>
        </member>
        <member name="P:System.SR.Argument_ShouldOnlySetVisibilityFlags">
            <summary>Should only set visibility flags when creating EnumBuilder.</summary>
        </member>
        <member name="P:System.SR.Argument_SigIsFinalized">
            <summary>Completed signature cannot be modified.</summary>
        </member>
        <member name="P:System.SR.Argument_StreamNotReadable">
            <summary>Stream was not readable.</summary>
        </member>
        <member name="P:System.SR.Argument_StreamNotWritable">
            <summary>Stream was not writable.</summary>
        </member>
        <member name="P:System.SR.Argument_StringFirstCharIsZero">
            <summary>The first char in the string is the null character.</summary>
        </member>
        <member name="P:System.SR.Argument_StringZeroLength">
            <summary>String cannot be of zero length.</summary>
        </member>
        <member name="P:System.SR.Argument_StructMustNotBeValueClass">
            <summary>The structure must not be a value class.</summary>
        </member>
        <member name="P:System.SR.Argument_TimeSpanHasSeconds">
            <summary>The TimeSpan parameter cannot be specified more precisely than whole minutes.</summary>
        </member>
        <member name="P:System.SR.Argument_TimeZoneInfoBadTZif">
            <summary>The tzfile does not begin with the magic characters 'TZif'.  Please verify that the file is not corrupt.</summary>
        </member>
        <member name="P:System.SR.Argument_TimeZoneInfoInvalidTZif">
            <summary>The TZif data structure is corrupt.</summary>
        </member>
        <member name="P:System.SR.Argument_ToExclusiveLessThanFromExclusive">
            <summary>fromInclusive must be less than or equal to toExclusive.</summary>
        </member>
        <member name="P:System.SR.Argument_TooManyFinallyClause">
            <summary>Exception blocks may have at most one finally clause.</summary>
        </member>
        <member name="P:System.SR.Argument_TransitionTimesAreIdentical">
            <summary>The DaylightTransitionStart property must not equal the DaylightTransitionEnd property.</summary>
        </member>
        <member name="P:System.SR.Argument_TypedReferenceInvalidField">
            <summary>Field '{0}' in TypedReferences cannot be static.</summary>
        </member>
        <member name="P:System.SR.Argument_TypeIsWinRTType">
            <summary>The type must not be a Windows Runtime type.</summary>
        </member>
        <member name="P:System.SR.Argument_TypeMustBeVisibleFromCom">
            <summary>The specified type must be visible from COM.</summary>
        </member>
        <member name="P:System.SR.Argument_TypeMustNotBeComImport">
            <summary>The type must not be imported from COM.</summary>
        </member>
        <member name="P:System.SR.Argument_TypeNameTooLong">
            <summary>Type name was too long. The fully qualified type name must be less than 1,024 characters.</summary>
        </member>
        <member name="P:System.SR.Argument_TypeNotActivatableViaWindowsRuntime">
            <summary>Type '{0}' does not have an activation factory because it is not activatable by Windows Runtime.</summary>
        </member>
        <member name="P:System.SR.Argument_TypeNotComObject">
            <summary>The type must be __ComObject or be derived from __ComObject.</summary>
        </member>
        <member name="P:System.SR.Argument_TypeNotValid">
            <summary>The Type object is not valid.</summary>
        </member>
        <member name="P:System.SR.Argument_UnclosedExceptionBlock">
            <summary>The IL Generator cannot be used while there are unclosed exceptions.</summary>
        </member>
        <member name="P:System.SR.Argument_Unexpected_TypeSource">
            <summary>Unexpected TypeKind when marshaling Windows.Foundation.TypeName.</summary>
        </member>
        <member name="P:System.SR.Argument_UnknownUnmanagedCallConv">
            <summary>Unknown unmanaged calling convention for function signature.</summary>
        </member>
        <member name="P:System.SR.Argument_UnmanagedMemAccessorWrapAround">
            <summary>The UnmanagedMemoryAccessor capacity and offset would wrap around the high end of the address space.</summary>
        </member>
        <member name="P:System.SR.Argument_UnmatchedMethodForLocal">
            <summary>Local passed in does not belong to this ILGenerator.</summary>
        </member>
        <member name="P:System.SR.Argument_UnmatchingSymScope">
            <summary>Non-matching symbol scope.</summary>
        </member>
        <member name="P:System.SR.Argument_UTCOutOfRange">
            <summary>The UTC time represented when the offset is applied must be between year 0 and 10,000.</summary>
        </member>
        <member name="P:System.SR.Argument_VerStringTooLong">
            <summary>The unmanaged Version information is too large to persist.</summary>
        </member>
        <member name="P:System.SR.Argument_WaitHandleNameTooLong">
            <summary>The length of the name exceeds the maximum limit.</summary>
        </member>
        <member name="P:System.SR.Argument_WinRTSystemRuntimeType">
            <summary>Cannot marshal type '{0}' to Windows Runtime. Only 'System.RuntimeType' is supported.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_BadMethodImplBody">
            <summary>MethodOverride's body must be from this type.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_BufferNotFromPool">
            <summary>The buffer is not associated with this pool and may not be returned to it.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_OtherNotArrayOfCorrectLength">
            <summary>Object is not a array with the same number of elements as the array to compare it to.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_NotIsomorphic">
            <summary>Object contains non-primitive or non-blittable data.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_TupleIncorrectType">
            <summary>Argument must be of type {0}.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_TupleLastArgumentNotATuple">
            <summary>The last element of an eight element tuple must be a Tuple.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_ValueTupleIncorrectType">
            <summary>Argument must be of type {0}.</summary>
        </member>
        <member name="P:System.SR.ArgumentException_ValueTupleLastArgumentNotAValueTuple">
            <summary>The last element of an eight element ValueTuple must be a ValueTuple.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Array">
            <summary>Array cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_ArrayElement">
            <summary>At least one element in the specified array was null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_ArrayValue">
            <summary>Found a null value within an array.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Assembly">
            <summary>Assembly cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_AssemblyName">
            <summary>AssemblyName cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_AssemblyNameName">
            <summary>AssemblyName.Name cannot be null or an empty string.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Buffer">
            <summary>Buffer cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Child">
            <summary>Cannot have a null child.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Collection">
            <summary>Collection cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Dictionary">
            <summary>Dictionary cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_FileName">
            <summary>File name cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Generic">
            <summary>Value cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_GUID">
            <summary>GUID cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Key">
            <summary>Key cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Path">
            <summary>Path cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_SafeHandle">
            <summary>SafeHandle cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Stream">
            <summary>Stream cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_String">
            <summary>String reference not set to an instance of a String.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Type">
            <summary>Type cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_TypedRefType">
            <summary>Type in TypedReference cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Waithandles">
            <summary>The waitHandles parameter cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_ActualValue">
            <summary>Actual value was {0}.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_AddressSpace">
            <summary>The number of bytes cannot exceed the virtual address space on a 32 bit machine.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_AddValue">
            <summary>Value to add was out of range.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_ArrayLB">
            <summary>Number was less than the array's lower bound in the first dimension.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_ArrayLBAndLength">
            <summary>Higher indices will exceed Int32.MaxValue because of large lower bound and/or length.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_BadHourMinuteSecond">
            <summary>Hour, Minute, and Second parameters describe an un-representable DateTime.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_BadYearMonthDay">
            <summary>Year, Month, and Day parameters describe an un-representable DateTime.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_BiggerThanCollection">
            <summary>Larger than collection size.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_BinaryReaderFillBuffer">
            <summary>The number of bytes requested does not fit into BinaryReader's internal buffer.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Bounds_Lower_Upper">
            <summary>Argument must be between {0} and {1}.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_CalendarRange">
            <summary>Specified time is not supported in this calendar. It should be between {0} (Gregorian date) and {1} (Gregorian date), inclusive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Capacity">
            <summary>Capacity exceeds maximum capacity.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Count">
            <summary>Count must be positive and count must refer to a location within the string/array/collection.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DateArithmetic">
            <summary>The added or subtracted value results in an un-representable DateTime.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DateTimeBadMonths">
            <summary>Months value must be between +/-120000.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DateTimeBadTicks">
            <summary>Ticks must be between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DateTimeBadYears">
            <summary>Years value must be between +/-10000.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Day">
            <summary>Day must be between 1 and {0} for month {1}.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DayOfWeek">
            <summary>The DayOfWeek enumeration must be in the range 0 through 6.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DayParam">
            <summary>The Day parameter must be in the range 1 through 31.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DecimalRound">
            <summary>Decimal can only round to between 0 and 28 digits of precision.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_DecimalScale">
            <summary>Decimal's scale value must be between 0 and 28, inclusive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_EndIndexStartIndex">
            <summary>endIndex cannot be greater than startIndex.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Enum">
            <summary>Enum value was out of legal range.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Era">
            <summary>Time value was out of era range.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_FileLengthTooBig">
            <summary>Specified file length was too large for the file system.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_FileTimeInvalid">
            <summary>Not a valid Win32 FileTime.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_GenericPositive">
            <summary>Value must be positive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_GetByteCountOverflow">
            <summary>Too many characters. The resulting number of bytes is larger than what can be returned as an int.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_GetCharCountOverflow">
            <summary>Too many bytes. The resulting number of chars is larger than what can be returned as an int.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_HashtableLoadFactor">
            <summary>Load factor needs to be between 0.1 and 1.0.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_HugeArrayNotSupported">
            <summary>Arrays larger than 2GB are not supported.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Index">
            <summary>Index was out of range. Must be non-negative and less than the size of the collection.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_IndexCount">
            <summary>Index and count must refer to a location within the string.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_IndexCountBuffer">
            <summary>Index and count must refer to a location within the buffer.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_IndexLargerThanMaxValue">
            <summary>This collection cannot work with indices larger than Int32.MaxValue - 1 (0x7FFFFFFF - 1).</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_IndexLength">
            <summary>Index and length must refer to a location within the string.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_IndexString">
            <summary>Index was out of range. Must be non-negative and less than the length of the string.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_InvalidEraValue">
            <summary>Era value was not valid.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_InvalidHighSurrogate">
            <summary>A valid high surrogate character is between 0xd800 and 0xdbff, inclusive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_InvalidLowSurrogate">
            <summary>A valid low surrogate character is between 0xdc00 and 0xdfff, inclusive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_InvalidUTF32">
            <summary>A valid UTF32 value is between 0x000000 and 0x10ffff, inclusive, and should not include surrogate codepoint values (0x00d800 ~ 0x00dfff).</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Length">
            <summary>The specified length exceeds maximum capacity of SecureString.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_LengthGreaterThanCapacity">
            <summary>The length cannot be greater than the capacity.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_LengthTooLarge">
            <summary>The specified length exceeds the maximum value of {0}.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_LessEqualToIntegerMaxVal">
            <summary>Argument must be less than or equal to 2^31 - 1 milliseconds.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_ListInsert">
            <summary>Index must be within the bounds of the List.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Month">
            <summary>Month must be between one and twelve.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_MonthParam">
            <summary>The Month parameter must be in the range 1 through 12.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_MustBeNonNegInt32">
            <summary>Value must be non-negative and less than or equal to Int32.MaxValue.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_MustBeNonNegNum">
            <summary>'{0}' must be non-negative.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_MustBePositive">
            <summary>'{0}' must be greater than zero.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NeedNonNegNum">
            <summary>Non-negative number required.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NeedNonNegOrNegative1">
            <summary>Number must be either non-negative and less than or equal to Int32.MaxValue or -1.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NeedPosNum">
            <summary>Positive number required.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NeedValidId">
            <summary>The ID parameter must be in the range {0} through {1}.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NegativeCapacity">
            <summary>Capacity must be positive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NegativeCount">
            <summary>Count cannot be less than zero.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NegativeLength">
            <summary>Length cannot be less than zero.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_OffsetLength">
            <summary>Offset and length must refer to a position in the string.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_OffsetOut">
            <summary>Either offset did not refer to a position in the string, or there is an insufficient length of destination character array.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_ParamSequence">
            <summary>The specified parameter index is not in range.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_PartialWCHAR">
            <summary>Pointer startIndex and length do not refer to a valid string.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_PeriodTooLarge">
            <summary>Period must be less than 2^32-2.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_PositionLessThanCapacityRequired">
            <summary>The position may not be greater or equal to the capacity of the accessor.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Range">
            <summary>Valid values are between {0} and {1}, inclusive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_RoundingDigits">
            <summary>Rounding digits must be between 0 and 15, inclusive.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_SmallCapacity">
            <summary>capacity was less than the current size.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_SmallMaxCapacity">
            <summary>MaxCapacity must be one or greater.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_StartIndex">
            <summary>StartIndex cannot be less than zero.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_StartIndexLargerThanLength">
            <summary>startIndex cannot be larger than length of string.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_StartIndexLessThanLength">
            <summary>startIndex must be less than length of string.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_StreamLength">
            <summary>Stream length must be non-negative and less than 2^31 - 1 - origin.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_TimeoutTooLarge">
            <summary>Time-out interval must be less than 2^32-2.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_UIntPtrMax">
            <summary>The length of the buffer must be less than the maximum UIntPtr value for your platform.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_UnmanagedMemStreamLength">
            <summary>UnmanagedMemoryStream length must be non-negative and less than 2^63 - 1 - baseAddress.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_UnmanagedMemStreamWrapAround">
            <summary>The UnmanagedMemoryStream capacity would wrap around the high end of the address space.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_UtcOffset">
            <summary>The TimeSpan parameter must be within plus or minus 14.0 hours.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_UtcOffsetAndDaylightDelta">
            <summary>The sum of the BaseUtcOffset and DaylightDelta properties must within plus or minus 14.0 hours.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Version">
            <summary>Version's parameters must be greater than or equal to zero.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Week">
            <summary>The Week parameter must be in the range 1 through 5.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Year">
            <summary>Year must be between 1 and 9999.</summary>
        </member>
        <member name="P:System.SR.Arithmetic_NaN">
            <summary>Function does not accept floating point Not-a-Number values.</summary>
        </member>
        <member name="P:System.SR.ArrayTypeMismatch_CantAssignType">
            <summary>Source array type cannot be assigned to destination array type.</summary>
        </member>
        <member name="P:System.SR.ArrayTypeMismatch_ConstrainedCopy">
            <summary>Array.ConstrainedCopy will only work on array types that are provably compatible, without any form of boxing, unboxing, widening, or casting of each array element.  Change the array types (i.e., copy a Derived[] to a Base[]), or use a mitigation strategy i ...</summary>
        </member>
        <member name="P:System.SR.AssemblyLoadContext_Unload_CannotUnloadIfNotCollectible">
            <summary>Cannot unload non-collectible AssemblyLoadContext.</summary>
        </member>
        <member name="P:System.SR.AssemblyLoadContext_Unload_AlreadyUnloaded">
            <summary>Unload called on AssemblyLoadContext that is unloading or that was already unloaded.</summary>
        </member>
        <member name="P:System.SR.AssemblyLoadContext_Verify_NotUnloading">
            <summary>AssemblyLoadContext is unloading or was already unloaded.</summary>
        </member>
        <member name="P:System.SR.AssertionFailed">
            <summary>Assertion failed.</summary>
        </member>
        <member name="P:System.SR.AssertionFailed_Cnd">
            <summary>Assertion failed: {0}</summary>
        </member>
        <member name="P:System.SR.AssumptionFailed">
            <summary>Assumption failed.</summary>
        </member>
        <member name="P:System.SR.AssumptionFailed_Cnd">
            <summary>Assumption failed: {0}</summary>
        </member>
        <member name="P:System.SR.AsyncMethodBuilder_InstanceNotInitialized">
            <summary>The builder was not properly initialized.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_BadILFormat">
            <summary>Bad IL format.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_InvalidType">
            <summary>Corrupt .resources file.  The specified type doesn't exist.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_NegativeStringLength">
            <summary>Corrupt .resources file. String length must be non-negative.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ParameterSignatureMismatch">
            <summary>The parameters and the signature of the method don't match.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResType_SerBlobMismatch">
            <summary>The type serialized in the .resources file was not the same type that the .resources file said it contained. Expected '{0}' but read '{1}'.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourceDataLengthInvalid">
            <summary>Corrupt .resources file.  The specified data length '{0}' is not a valid position in the stream.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourceNameCorrupted">
            <summary>Corrupt .resources file. A resource name extends past the end of the stream.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourceNameCorrupted_NameIndex">
            <summary>Corrupt .resources file. The resource name for name index {0} extends past the end of the stream.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourcesDataInvalidOffset">
            <summary>Corrupt .resources file. Invalid offset '{0}' into data section.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourcesHeaderCorrupted">
            <summary>Corrupt .resources file. Unable to read resources from this file because of invalid header information. Try regenerating the .resources file.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourcesIndexTooLong">
            <summary>Corrupt .resources file. String for name index '{0}' extends past the end of the file.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourcesNameInvalidOffset">
            <summary>Corrupt .resources file. Invalid offset '{0}' into name section.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_ResourcesNameTooLong">
            <summary>Corrupt .resources file. Resource name extends past the end of the file.</summary>
        </member>
        <member name="P:System.SR.BadImageFormat_TypeMismatch">
            <summary>Corrupt .resources file.  The specified type doesn't match the available data in the stream.</summary>
        </member>
        <member name="P:System.SR.CancellationToken_CreateLinkedToken_TokensIsEmpty">
            <summary>No tokens were supplied.</summary>
        </member>
        <member name="P:System.SR.CancellationToken_SourceDisposed">
            <summary>The CancellationTokenSource associated with this CancellationToken has been disposed.</summary>
        </member>
        <member name="P:System.SR.CancellationTokenSource_Disposed">
            <summary>The CancellationTokenSource has been disposed.</summary>
        </member>
        <member name="P:System.SR.ConcurrentCollection_SyncRoot_NotSupported">
            <summary>The SyncRoot property may not be used for the synchronization of concurrent collections.</summary>
        </member>
        <member name="P:System.SR.event_SpinLock_FastPathFailed">
            <summary>SpinLock beginning to spin.</summary>
        </member>
        <member name="P:System.SR.event_SpinWait_NextSpinWillYield">
            <summary>Next spin will yield.</summary>
        </member>
        <member name="P:System.SR.event_TaskCompleted">
            <summary>Task {2} completed.</summary>
        </member>
        <member name="P:System.SR.event_TaskScheduled">
            <summary>Task {2} scheduled to TaskScheduler {0}.</summary>
        </member>
        <member name="P:System.SR.event_TaskStarted">
            <summary>Task {2} executing.</summary>
        </member>
        <member name="P:System.SR.event_TaskWaitBegin">
            <summary>Beginning wait ({3}) on Task {2}.</summary>
        </member>
        <member name="P:System.SR.event_TaskWaitEnd">
            <summary>Ending wait on Task {2}.</summary>
        </member>
        <member name="P:System.SR.EventSource_AbstractMustNotDeclareEventMethods">
            <summary>Abstract event source must not declare event methods ({0} with ID {1}).</summary>
        </member>
        <member name="P:System.SR.EventSource_AbstractMustNotDeclareKTOC">
            <summary>Abstract event source must not declare {0} nested type.</summary>
        </member>
        <member name="P:System.SR.EventSource_AddScalarOutOfRange">
            <summary>Getting out of bounds during scalar addition.</summary>
        </member>
        <member name="P:System.SR.EventSource_BadHexDigit">
            <summary>Bad Hexidecimal digit "{0}".</summary>
        </member>
        <member name="P:System.SR.EventSource_ChannelTypeDoesNotMatchEventChannelValue">
            <summary>Channel {0} does not match event channel value {1}.</summary>
        </member>
        <member name="P:System.SR.EventSource_DataDescriptorsOutOfRange">
            <summary>Data descriptors are out of range.</summary>
        </member>
        <member name="P:System.SR.EventSource_DuplicateStringKey">
            <summary>Multiple definitions for string "{0}".</summary>
        </member>
        <member name="P:System.SR.EventSource_EnumKindMismatch">
            <summary>The type of {0} is not expected in {1}.</summary>
        </member>
        <member name="P:System.SR.EventSource_EvenHexDigits">
            <summary>Must have an even number of Hexidecimal digits.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventChannelOutOfRange">
            <summary>Channel {0} has a value of {1} which is outside the legal range (16-254).</summary>
        </member>
        <member name="P:System.SR.EventSource_EventIdReused">
            <summary>Event {0} has ID {1} which is already in use.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventMustHaveTaskIfNonDefaultOpcode">
            <summary>Event {0} (with ID {1}) has a non-default opcode but not a task.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventMustNotBeExplicitImplementation">
            <summary>Event method {0} (with ID {1}) is an explicit interface method implementation. Re-write method as implicit implementation.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventNameDoesNotEqualTaskPlusOpcode">
            <summary>Event {0} (with ID {1}) has a name that is not the concatenation of its task name and opcode.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventNameReused">
            <summary>Event name {0} used more than once.  If you wish to overload a method, the overloaded method should have a NonEvent attribute.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventParametersMismatch">
            <summary>Event {0} was called with {1} argument(s), but it is defined with {2} parameter(s).</summary>
        </member>
        <member name="P:System.SR.EventSource_EventSourceGuidInUse">
            <summary>An instance of EventSource with Guid {0} already exists.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventTooBig">
            <summary>The payload for a single event is too large.</summary>
        </member>
        <member name="P:System.SR.EventSource_EventWithAdminChannelMustHaveMessage">
            <summary>Event {0} specifies an Admin channel {1}. It must specify a Message property.</summary>
        </member>
        <member name="P:System.SR.EventSource_IllegalKeywordsValue">
            <summary>Keyword {0} has a value of {1} which is outside the legal range (0-0x0000080000000000).</summary>
        </member>
        <member name="P:System.SR.EventSource_IllegalOpcodeValue">
            <summary>Opcode {0} has a value of {1} which is outside the legal range (11-238).</summary>
        </member>
        <member name="P:System.SR.EventSource_IllegalTaskValue">
            <summary>Task {0} has a value of {1} which is outside the legal range (1-65535).</summary>
        </member>
        <member name="P:System.SR.EventSource_IllegalValue">
            <summary>Illegal value "{0}" (prefix strings with @ to indicate a literal string).</summary>
        </member>
        <member name="P:System.SR.EventSource_IncorrentlyAuthoredTypeInfo">
            <summary>Incorrectly-authored TypeInfo - a type should be serialized as one field or as one group</summary>
        </member>
        <member name="P:System.SR.EventSource_InvalidCommand">
            <summary>Invalid command value.</summary>
        </member>
        <member name="P:System.SR.EventSource_InvalidEventFormat">
            <summary>Can't specify both etw event format flags.</summary>
        </member>
        <member name="P:System.SR.EventSource_KeywordCollision">
            <summary>Keywords {0} and {1} are defined with the same value ({2}).</summary>
        </member>
        <member name="P:System.SR.EventSource_KeywordNeedPowerOfTwo">
            <summary>Value {0} for keyword {1} needs to be a power of 2.</summary>
        </member>
        <member name="P:System.SR.EventSource_ListenerCreatedInsideCallback">
            <summary>Creating an EventListener inside a EventListener callback.</summary>
        </member>
        <member name="P:System.SR.EventSource_ListenerNotFound">
            <summary>Listener not found.</summary>
        </member>
        <member name="P:System.SR.EventSource_ListenerWriteFailure">
            <summary>An error occurred when writing to a listener.</summary>
        </member>
        <member name="P:System.SR.EventSource_MaxChannelExceeded">
            <summary>Attempt to define more than the maximum limit of 8 channels for a provider.</summary>
        </member>
        <member name="P:System.SR.EventSource_MismatchIdToWriteEvent">
            <summary>Event {0} was assigned event ID {1} but {2} was passed to WriteEvent.</summary>
        </member>
        <member name="P:System.SR.EventSource_NeedGuid">
            <summary>The Guid of an EventSource must be non zero.</summary>
        </member>
        <member name="P:System.SR.EventSource_NeedName">
            <summary>The name of an EventSource must not be null.</summary>
        </member>
        <member name="P:System.SR.EventSource_NeedPositiveId">
            <summary>Event IDs must be positive integers.</summary>
        </member>
        <member name="P:System.SR.EventSource_NoFreeBuffers">
            <summary>No Free Buffers available from the operating system (e.g. event rate too fast).</summary>
        </member>
        <member name="P:System.SR.EventSource_NonCompliantTypeError">
            <summary>The API supports only anonymous types or types decorated with the EventDataAttribute. Non-compliant type: {0} dataType.</summary>
        </member>
        <member name="P:System.SR.EventSource_NoRelatedActivityId">
            <summary>EventSource expects the first parameter of the Event method to be of type Guid and to be named "relatedActivityId" when calling WriteEventWithRelatedActivityId.</summary>
        </member>
        <member name="P:System.SR.EventSource_NotSupportedArrayOfBinary">
            <summary>Arrays of Binary are not supported.</summary>
        </member>
        <member name="P:System.SR.EventSource_NotSupportedArrayOfNil">
            <summary>Arrays of Nil are not supported.</summary>
        </member>
        <member name="P:System.SR.EventSource_NotSupportedArrayOfNullTerminatedString">
            <summary>Arrays of null-terminated string are not supported.</summary>
        </member>
        <member name="P:System.SR.EventSource_NotSupportedCustomSerializedData">
            <summary>Enumerables of custom-serialized data are not supported</summary>
        </member>
        <member name="P:System.SR.EventSource_NotSupportedNestedArraysEnums">
            <summary>Nested arrays/enumerables are not supported.</summary>
        </member>
        <member name="P:System.SR.EventSource_NullInput">
            <summary>Null passed as a event argument.</summary>
        </member>
        <member name="P:System.SR.EventSource_OpcodeCollision">
            <summary>Opcodes {0} and {1} are defined with the same value ({2}).</summary>
        </member>
        <member name="P:System.SR.EventSource_PinArrayOutOfRange">
            <summary>Pins are out of range.</summary>
        </member>
        <member name="P:System.SR.EventSource_RecursiveTypeDefinition">
            <summary>Recursive type definition is not supported.</summary>
        </member>
        <member name="P:System.SR.EventSource_SessionIdError">
            <summary>Bit position in AllKeywords ({0}) must equal the command argument named "EtwSessionKeyword" ({1}).</summary>
        </member>
        <member name="P:System.SR.EventSource_StopsFollowStarts">
            <summary>An event with stop suffix must follow a corresponding event with a start suffix.</summary>
        </member>
        <member name="P:System.SR.EventSource_TaskCollision">
            <summary>Tasks {0} and {1} are defined with the same value ({2}).</summary>
        </member>
        <member name="P:System.SR.EventSource_TaskOpcodePairReused">
            <summary>Event {0} (with ID {1}) has the same task/opcode pair as event {2} (with ID {3}).</summary>
        </member>
        <member name="P:System.SR.EventSource_TooManyArgs">
            <summary>Too many arguments.</summary>
        </member>
        <member name="P:System.SR.EventSource_TooManyFields">
            <summary>Too many fields in structure.</summary>
        </member>
        <member name="P:System.SR.EventSource_ToString">
            <summary>EventSource({0}, {1})</summary>
        </member>
        <member name="P:System.SR.EventSource_TraitEven">
            <summary>There must be an even number of trait strings (they are key-value pairs).</summary>
        </member>
        <member name="P:System.SR.EventSource_TypeMustBeSealedOrAbstract">
            <summary>Event source types must be sealed or abstract.</summary>
        </member>
        <member name="P:System.SR.EventSource_TypeMustDeriveFromEventSource">
            <summary>Event source types must derive from EventSource.</summary>
        </member>
        <member name="P:System.SR.EventSource_UndefinedChannel">
            <summary>Use of undefined channel value {0} for event {1}.</summary>
        </member>
        <member name="P:System.SR.EventSource_UndefinedKeyword">
            <summary>Use of undefined keyword value {0} for event {1}.</summary>
        </member>
        <member name="P:System.SR.EventSource_UndefinedOpcode">
            <summary>Use of undefined opcode value {0} for event {1}.</summary>
        </member>
        <member name="P:System.SR.EventSource_UnknownEtwTrait">
            <summary>Unknown ETW trait "{0}".</summary>
        </member>
        <member name="P:System.SR.EventSource_UnsupportedEventTypeInManifest">
            <summary>Unsupported type {0} in event source.</summary>
        </member>
        <member name="P:System.SR.EventSource_UnsupportedMessageProperty">
            <summary>Event {0} specifies an illegal or unsupported formatting message ("{1}").</summary>
        </member>
        <member name="P:System.SR.EventSource_VarArgsParameterMismatch">
            <summary>The parameters to the Event method do not match the parameters to the WriteEvent method. This may cause the event to be displayed incorrectly.</summary>
        </member>
        <member name="P:System.SR.Exception_EndOfInnerExceptionStack">
            <summary>--- End of inner exception stack trace ---</summary>
        </member>
        <member name="P:System.SR.Exception_EndStackTraceFromPreviousThrow">
            <summary>--- End of stack trace from previous location where exception was thrown ---</summary>
        </member>
        <member name="P:System.SR.Exception_WasThrown">
            <summary>Exception of type '{0}' was thrown.</summary>
        </member>
        <member name="P:System.SR.ExecutionContext_ExceptionInAsyncLocalNotification">
            <summary>An exception was not handled in an AsyncLocal&lt;T&gt; notification callback.</summary>
        </member>
        <member name="P:System.SR.FieldAccess_InitOnly">
            <summary>InitOnly (aka ReadOnly) fields can only be initialized in the type/instance constructor.</summary>
        </member>
        <member name="P:System.SR.FileNotFound_ResolveAssembly">
            <summary>Could not resolve assembly '{0}'.</summary>
        </member>
        <member name="P:System.SR.Format_AttributeUsage">
            <summary>Duplicate AttributeUsageAttribute found on attribute type {0}.</summary>
        </member>
        <member name="P:System.SR.Format_Bad7BitInt32">
            <summary>Too many bytes in what should have been a 7 bit encoded Int32.</summary>
        </member>
        <member name="P:System.SR.Format_BadBase">
            <summary>Invalid digits for the specified base.</summary>
        </member>
        <member name="P:System.SR.Format_BadBase64Char">
            <summary>The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.</summary>
        </member>
        <member name="P:System.SR.Format_BadBase64CharArrayLength">
            <summary>Invalid length for a Base-64 char array or string.</summary>
        </member>
        <member name="P:System.SR.Format_BadBoolean">
            <summary>String '{0}' was not recognized as a valid Boolean.</summary>
        </member>
        <member name="P:System.SR.Format_BadDatePattern">
            <summary>Could not determine the order of year, month, and date from '{0}'.</summary>
        </member>
        <member name="P:System.SR.Format_BadDateTime">
            <summary>String '{0}' was not recognized as a valid DateTime.</summary>
        </member>
        <member name="P:System.SR.Format_BadDateTimeCalendar">
            <summary>The DateTime represented by the string '{0}' is not supported in calendar '{1}'.</summary>
        </member>
        <member name="P:System.SR.Format_BadDayOfWeek">
            <summary>String '{0}' was not recognized as a valid DateTime because the day of week was incorrect.</summary>
        </member>
        <member name="P:System.SR.Format_BadFormatSpecifier">
            <summary>Format specifier '{0}' was invalid.</summary>
        </member>
        <member name="P:System.SR.Format_NoFormatSpecifier">
            <summary>No format specifiers were provided.</summary>
        </member>
        <member name="P:System.SR.Format_BadQuote">
            <summary>Cannot find a matching quote character for the character '{0}'.</summary>
        </member>
        <member name="P:System.SR.Format_BadTimeSpan">
            <summary>String '{0}' was not recognized as a valid TimeSpan.</summary>
        </member>
        <member name="P:System.SR.Format_DateOutOfRange">
            <summary>The DateTime represented by the string '{0}' is out of range.</summary>
        </member>
        <member name="P:System.SR.Format_EmptyInputString">
            <summary>Input string was either empty or contained only whitespace.</summary>
        </member>
        <member name="P:System.SR.Format_ExtraJunkAtEnd">
            <summary>Additional non-parsable characters are at the end of the string.</summary>
        </member>
        <member name="P:System.SR.Format_GuidBrace">
            <summary>Expected {0xdddddddd, etc}.</summary>
        </member>
        <member name="P:System.SR.Format_GuidBraceAfterLastNumber">
            <summary>Could not find a brace, or the length between the previous token and the brace was zero (i.e., '0x,'etc.).</summary>
        </member>
        <member name="P:System.SR.Format_GuidComma">
            <summary>Could not find a comma, or the length between the previous token and the comma was zero (i.e., '0x,'etc.).</summary>
        </member>
        <member name="P:System.SR.Format_GuidDashes">
            <summary>Dashes are in the wrong position for GUID parsing.</summary>
        </member>
        <member name="P:System.SR.Format_GuidEndBrace">
            <summary>Could not find the ending brace.</summary>
        </member>
        <member name="P:System.SR.Format_GuidHexPrefix">
            <summary>Expected 0x prefix.</summary>
        </member>
        <member name="P:System.SR.Format_GuidInvalidChar">
            <summary>Guid string should only contain hexadecimal characters.</summary>
        </member>
        <member name="P:System.SR.Format_GuidInvLen">
            <summary>Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).</summary>
        </member>
        <member name="P:System.SR.Format_GuidUnrecognized">
            <summary>Unrecognized Guid format.</summary>
        </member>
        <member name="P:System.SR.Format_IndexOutOfRange">
            <summary>Index (zero based) must be greater than or equal to zero and less than the size of the argument list.</summary>
        </member>
        <member name="P:System.SR.Format_InvalidEnumFormatSpecification">
            <summary>Format string can be only "G", "g", "X", "x", "F", "f", "D" or "d".</summary>
        </member>
        <member name="P:System.SR.Format_InvalidGuidFormatSpecification">
            <summary>Format string can be only "D", "d", "N", "n", "P", "p", "B", "b", "X" or "x".</summary>
        </member>
        <member name="P:System.SR.Format_InvalidString">
            <summary>Input string was not in a correct format.</summary>
        </member>
        <member name="P:System.SR.Format_MissingIncompleteDate">
            <summary>There must be at least a partial date with a year present in the input string '{0}'.</summary>
        </member>
        <member name="P:System.SR.Format_NeedSingleChar">
            <summary>String must be exactly one character long.</summary>
        </member>
        <member name="P:System.SR.Format_NoParsibleDigits">
            <summary>Could not find any recognizable digits.</summary>
        </member>
        <member name="P:System.SR.Format_OffsetOutOfRange">
            <summary>The time zone offset of string '{0}' must be within plus or minus 14 hours.</summary>
        </member>
        <member name="P:System.SR.Format_RepeatDateTimePattern">
            <summary>DateTime pattern '{0}' appears more than once with different values.</summary>
        </member>
        <member name="P:System.SR.Format_StringZeroLength">
            <summary>String cannot have zero length.</summary>
        </member>
        <member name="P:System.SR.Format_UnknownDateTimeWord">
            <summary>The string '{0}' was not recognized as a valid DateTime. There is an unknown word starting at index '{1}'.</summary>
        </member>
        <member name="P:System.SR.Format_UTCOutOfRange">
            <summary>The UTC representation of the date '{0}' falls outside the year range 1-9999.</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_1200">
            <summary>Unicode</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_12000">
            <summary>Unicode (UTF-32)</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_12001">
            <summary>Unicode (UTF-32 Big-Endian)</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_1201">
            <summary>Unicode (Big-Endian)</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_20127">
            <summary>US-ASCII</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_28591">
            <summary>Western European (ISO)</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_65000">
            <summary>Unicode (UTF-7)</summary>
        </member>
        <member name="P:System.SR.Globalization_cp_65001">
            <summary>Unicode (UTF-8)</summary>
        </member>
        <member name="P:System.SR.IndexOutOfRange_ArrayRankIndex">
            <summary>Array does not have that many dimensions.</summary>
        </member>
        <member name="P:System.SR.IndexOutOfRange_UMSPosition">
            <summary>Unmanaged memory stream position was beyond the capacity of the stream.</summary>
        </member>
        <member name="P:System.SR.InsufficientMemory_MemFailPoint">
            <summary>Insufficient available memory to meet the expected demands of an operation at this time.  Please try again later.</summary>
        </member>
        <member name="P:System.SR.InsufficientMemory_MemFailPoint_TooBig">
            <summary>Insufficient memory to meet the expected demands of an operation, and this system is likely to never satisfy this request.  If this is a 32 bit system, consider booting in 3 GB mode.</summary>
        </member>
        <member name="P:System.SR.InsufficientMemory_MemFailPoint_VAFrag">
            <summary>Insufficient available memory to meet the expected demands of an operation at this time, possibly due to virtual address space fragmentation.  Please try again later.</summary>
        </member>
        <member name="P:System.SR.Interop_COM_TypeMismatch">
            <summary>Type mismatch between source and destination types.</summary>
        </member>
        <member name="P:System.SR.Interop_Marshal_Unmappable_Char">
            <summary>Cannot marshal: Encountered unmappable character.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_CannotCastNullToValueType">
            <summary>Null object cannot be converted to a value type.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_CannotCoerceByRefVariant">
            <summary>Object cannot be coerced to the original type of the ByRef VARIANT it was obtained from.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_DBNull">
            <summary>Object cannot be cast to DBNull.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_DownCastArrayElement">
            <summary>At least one element in the source array could not be cast down to the destination array type.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_Empty">
            <summary>Object cannot be cast to Empty.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_FromDBNull">
            <summary>Object cannot be cast from DBNull to other types.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_FromTo">
            <summary>Invalid cast from '{0}' to '{1}'.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_IConvertible">
            <summary>Object must implement IConvertible.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_OATypeMismatch">
            <summary>OleAut reported a type mismatch.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_StoreArrayElement">
            <summary>Object cannot be stored in an array of this type.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_WinRTIPropertyValueArrayCoersion">
            <summary>Object in an IPropertyValue is of type '{0}' which cannot be convereted to a '{1}' due to array element '{2}': {3}.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_WinRTIPropertyValueCoersion">
            <summary>Object in an IPropertyValue is of type '{0}' with value '{1}', which cannot be converted to a '{2}'.</summary>
        </member>
        <member name="P:System.SR.InvalidCast_WinRTIPropertyValueElement">
            <summary>Object in an IPropertyValue is of type '{0}', which cannot be converted to a '{1}'.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_AsyncFlowCtrlCtxMismatch">
            <summary>AsyncFlowControl objects can be used to restore flow only on a Context that had its flow suppressed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_AsyncIOInProgress">
            <summary>The stream is currently in use by a previous operation on the stream.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_BadEmptyMethodBody">
            <summary>Method '{0}' does not have a method body.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_BadILGeneratorUsage">
            <summary>ILGenerator usage is invalid.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_BadInstructionOrIndexOutOfBound">
            <summary>MSIL instruction is invalid or index is out of bounds.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_BadInterfaceNotAbstract">
            <summary>Interface must be declared abstract.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_BadMethodBody">
            <summary>Method '{0}' cannot have a method body.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_BadTypeAttributesNotAbstract">
            <summary>Type must be declared abstract if any of its methods are abstract.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CalledTwice">
            <summary>The method cannot be called twice on the same instance.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CannotImportGlobalFromDifferentModule">
            <summary>Unable to import a global method or field from a different module.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CannotRegisterSecondResolver">
            <summary>A resolver is already set for the assembly.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CannotRemoveLastFromEmptyCollection">
            <summary>Cannot remove the last element from an empty collection.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CannotRestoreUnsupressedFlow">
            <summary>Cannot restore context flow when it is not suppressed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CannotSupressFlowMultipleTimes">
            <summary>Context flow is already suppressed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CannotUseAFCMultiple">
            <summary>AsyncFlowControl object can be used only once to call Undo().</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CannotUseAFCOtherThread">
            <summary>AsyncFlowControl object must be used on the thread where it was created.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CantInstantiateAbstractClass">
            <summary>Instances of abstract classes cannot be created.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CantInstantiateFunctionPointer">
            <summary>Instances of function pointers cannot be created.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CollectionBackingDictionaryTooLarge">
            <summary>The collection backing this Dictionary contains too many elements.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CollectionBackingListTooLarge">
            <summary>The collection backing this List contains too many elements.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_CollectionCorrupted">
            <summary>A prior operation on this collection was interrupted by an exception. Collection's state is no longer trusted.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ComputerName">
            <summary>Computer name could not be obtained.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ConcurrentOperationsNotSupported">
            <summary>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ConstructorNotAllowedOnInterface">
            <summary>Interface cannot have constructors.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_DateTimeParsing">
            <summary>Internal Error in DateTime and Calendar operations.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_DebuggerLaunchFailed">
            <summary>Debugger unable to launch.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_DefaultConstructorILGen">
            <summary>Unable to access ILGenerator on a constructor created with DefineDefaultConstructor.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EndReadCalledMultiple">
            <summary>EndRead can only be called once for each asynchronous operation.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EndWriteCalledMultiple">
            <summary>EndWrite can only be called once for each asynchronous operation.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumEnded">
            <summary>Enumeration already finished.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumFailedVersion">
            <summary>Collection was modified; enumeration operation may not execute.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumNotStarted">
            <summary>Enumeration has not started. Call MoveNext.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumOpCantHappen">
            <summary>Enumeration has either not started or has already finished.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EventInfoNotAvailable">
            <summary>This API does not support EventInfo tokens.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EventTokenTableRequiresDelegate">
            <summary>Type '{0}' is not a delegate type.  EventTokenTable may only be used with delegate types.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_GenericParametersAlreadySet">
            <summary>The generic parameters are already defined on this MethodBuilder.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_GetVersion">
            <summary>OSVersion's call to GetVersionEx failed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_GlobalsHaveBeenCreated">
            <summary>Type definition of the global function has been completed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_HandleIsNotInitialized">
            <summary>Handle is not initialized.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_HandleIsNotPinned">
            <summary>Handle is not pinned.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_HashInsertFailed">
            <summary>Hashtable insert failed. Load factor too high. The most common cause is multiple threads writing to the Hashtable simultaneously.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_IComparerFailed">
            <summary>Failed to compare two elements in the array.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_MethodBaked">
            <summary>Type definition of the method is complete.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_MethodBuilderBaked">
            <summary>The signature of the MethodBuilder can no longer be modified because an operation on the MethodBuilder caused the methodDef token to be created. For example, a call to SetCustomAttribute requires the methodDef token to emit the CustomAttribute token.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_MethodHasBody">
            <summary>Method already has a body.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_MustCallInitialize">
            <summary>You must call Initialize on this object instance before using it.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NativeOverlappedReused">
            <summary>NativeOverlapped cannot be reused for multiple operations.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NoMultiModuleAssembly">
            <summary>You cannot have more than one dynamic module in each dynamic assembly in this version of the runtime.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NoPublicAddMethod">
            <summary>Cannot add the event handler since no public add method exists for the event.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NoPublicRemoveMethod">
            <summary>Cannot remove the event handler since no public remove method exists for the event.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NotADebugModule">
            <summary>Not a debug ModuleBuilder.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NotAllowedInDynamicMethod">
            <summary>The requested operation is invalid for DynamicMethod.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NotAVarArgCallingConvention">
            <summary>Calling convention must be VarArgs.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NotGenericType">
            <summary>This operation is only valid on generic types.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NotSupportedOnWinRTEvent">
            <summary>Adding or removing event handlers dynamically is not supported on WinRT events.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NotWithConcurrentGC">
            <summary>This API is not available when the concurrent GC is enabled.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NoUnderlyingTypeOnEnum">
            <summary>Underlying type information on enumeration is not specified.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NoValue">
            <summary>Nullable object must have a value.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NullArray">
            <summary>The underlying array is null.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NullContext">
            <summary>Cannot call Set on a null context</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NullModuleHandle">
            <summary>The requested operation is invalid when called on a null ModuleHandle.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_OpenLocalVariableScope">
            <summary>Local variable scope was not properly closed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_Overlapped_Pack">
            <summary>Cannot pack a packed Overlapped again.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_PropertyInfoNotAvailable">
            <summary>This API does not support PropertyInfo tokens.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ReadOnly">
            <summary>Instance is read-only.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ResMgrBadResSet_Type">
            <summary>'{0}': ResourceSet derived classes must provide a constructor that takes a String file name and a constructor that takes a Stream.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ResourceNotStream_Name">
            <summary>Resource '{0}' was not a Stream - call GetObject instead.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ResourceNotString_Name">
            <summary>Resource '{0}' was not a String - call GetObject instead.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ResourceNotString_Type">
            <summary>Resource was of type '{0}' instead of String - call GetObject instead.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_SetData_OnlyOnce">
            <summary>SetData can only be used to set the value of a given name once.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_SetLatencyModeNoGC">
            <summary>The NoGCRegion mode is in progress.End it and then set a different mode.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ShouldNotHaveMethodBody">
            <summary>Method body should not exist.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ThreadWrongThreadStart">
            <summary>The thread was created with a ThreadStart delegate that does not accept a parameter.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_TimeoutsNotSupported">
            <summary>Timeouts are not supported on this stream.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_TimerAlreadyClosed">
            <summary>The Timer was already closed using an incompatible Dispose method.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_TypeCannotBeBoxed">
            <summary>The given type cannot be boxed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_TypeHasBeenCreated">
            <summary>Unable to change after type has been created.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_TypeNotCreated">
            <summary>Type has not been created.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_UnderlyingArrayListChanged">
            <summary>This range in the underlying list is invalid. A possible cause is that elements were removed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_UnknownEnumType">
            <summary>Unknown enum type.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_WriteOnce">
            <summary>This property has already been set and cannot be modified.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_WrongAsyncResultOrEndCalledMultiple">
            <summary>Either the IAsyncResult object did not come from the corresponding async method on this type, or the End method was called multiple times with the same IAsyncResult.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple">
            <summary>Either the IAsyncResult object did not come from the corresponding async method on this type, or EndRead was called multiple times with the same IAsyncResult.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple">
            <summary>Either the IAsyncResult object did not come from the corresponding async method on this type, or EndWrite was called multiple times with the same IAsyncResult.</summary>
        </member>
        <member name="P:System.SR.InvalidProgram_Default">
            <summary>Common Language Runtime detected an invalid program.</summary>
        </member>
        <member name="P:System.SR.InvalidTimeZone_InvalidFileData">
            <summary>The time zone ID '{0}' was found on the local computer, but the file at '{1}' was corrupt.</summary>
        </member>
        <member name="P:System.SR.InvalidTimeZone_InvalidRegistryData">
            <summary>The time zone ID '{0}' was found on the local computer, but the registry information was corrupt.</summary>
        </member>
        <member name="P:System.SR.InvalidTimeZone_InvalidJulianDay">
            <summary>Invalid Julian day in POSIX strings.</summary>
        </member>
        <member name="P:System.SR.InvalidTimeZone_NoTTInfoStructures">
            <summary>There are no ttinfo structures in the tzfile.  At least one ttinfo structure is required in order to construct a TimeZoneInfo object.</summary>
        </member>
        <member name="P:System.SR.InvalidTimeZone_UnparseablePosixMDateString">
            <summary>'{0}' is not a valid POSIX-TZ-environment-variable MDate rule.  A valid rule has the format 'Mm.w.d'.</summary>
        </member>
        <member name="P:System.SR.InvariantFailed">
            <summary>Invariant failed.</summary>
        </member>
        <member name="P:System.SR.InvariantFailed_Cnd">
            <summary>Invariant failed: {0}</summary>
        </member>
        <member name="P:System.SR.IO_DriveNotFound_Drive">
            <summary>Could not find the drive '{0}'. The drive might not be ready or might not be mapped.</summary>
        </member>
        <member name="P:System.SR.IO_EOF_ReadBeyondEOF">
            <summary>Unable to read beyond the end of the stream.</summary>
        </member>
        <member name="P:System.SR.IO_FileLoad">
            <summary>Could not load the specified file.</summary>
        </member>
        <member name="P:System.SR.IO_FileName_Name">
            <summary>File name: '{0}'</summary>
        </member>
        <member name="P:System.SR.IO_FileNotFound">
            <summary>Unable to find the specified file.</summary>
        </member>
        <member name="P:System.SR.IO_FileNotFound_FileName">
            <summary>Could not find file '{0}'.</summary>
        </member>
        <member name="P:System.SR.IO_AlreadyExists_Name">
            <summary>Cannot create '{0}' because a file or directory with the same name already exists.</summary>
        </member>
        <member name="P:System.SR.IO_BindHandleFailed">
            <summary>BindHandle for ThreadPool failed on this handle.</summary>
        </member>
        <member name="P:System.SR.IO_FileExists_Name">
            <summary>The file '{0}' already exists.</summary>
        </member>
        <member name="P:System.SR.IO_FileStreamHandlePosition">
            <summary>The OS handle's position is not what FileStream expected. Do not use a handle simultaneously in one FileStream and in Win32 code or another FileStream. This may cause data loss.</summary>
        </member>
        <member name="P:System.SR.IO_FileTooLong2GB">
            <summary>The file is too long. This operation is currently limited to supporting files less than 2 gigabytes in size.</summary>
        </member>
        <member name="P:System.SR.IO_FileTooLongOrHandleNotSync">
            <summary>IO operation will not work. Most likely the file will become too long or the handle was not opened to support synchronous IO operations.</summary>
        </member>
        <member name="P:System.SR.IO_FixedCapacity">
            <summary>Unable to expand length of this stream beyond its capacity.</summary>
        </member>
        <member name="P:System.SR.IO_InvalidStringLen_Len">
            <summary>BinaryReader encountered an invalid string length of {0} characters.</summary>
        </member>
        <member name="P:System.SR.IO_SeekAppendOverwrite">
            <summary>Unable seek backward to overwrite data that previously existed in a file opened in Append mode.</summary>
        </member>
        <member name="P:System.SR.IO_SeekBeforeBegin">
            <summary>An attempt was made to move the position before the beginning of the stream.</summary>
        </member>
        <member name="P:System.SR.IO_SetLengthAppendTruncate">
            <summary>Unable to truncate data that previously existed in a file opened in Append mode.</summary>
        </member>
        <member name="P:System.SR.IO_SharingViolation_File">
            <summary>The process cannot access the file '{0}' because it is being used by another process.</summary>
        </member>
        <member name="P:System.SR.IO_SharingViolation_NoFileName">
            <summary>The process cannot access the file because it is being used by another process.</summary>
        </member>
        <member name="P:System.SR.IO_StreamTooLong">
            <summary>Stream was too long.</summary>
        </member>
        <member name="P:System.SR.IO_PathNotFound_NoPathName">
            <summary>Could not find a part of the path.</summary>
        </member>
        <member name="P:System.SR.IO_PathNotFound_Path">
            <summary>Could not find a part of the path '{0}'.</summary>
        </member>
        <member name="P:System.SR.IO_PathTooLong">
            <summary>The specified file name or path is too long, or a component of the specified path is too long.</summary>
        </member>
        <member name="P:System.SR.IO_PathTooLong_Path">
            <summary>The path '{0}' is too long, or a component of the specified path is too long.</summary>
        </member>
        <member name="P:System.SR.IO_UnknownFileName">
            <summary>[Unknown]</summary>
        </member>
        <member name="P:System.SR.Lazy_CreateValue_NoParameterlessCtorForT">
            <summary>The lazily-initialized type does not have a public, parameterless constructor.</summary>
        </member>
        <member name="P:System.SR.Lazy_ctor_ModeInvalid">
            <summary>The mode argument specifies an invalid value.</summary>
        </member>
        <member name="P:System.SR.Lazy_StaticInit_InvalidOperation">
            <summary>ValueFactory returned null.</summary>
        </member>
        <member name="P:System.SR.Lazy_ToString_ValueNotCreated">
            <summary>Value is not created.</summary>
        </member>
        <member name="P:System.SR.Lazy_Value_RecursiveCallsToValue">
            <summary>ValueFactory attempted to access the Value property of this instance.</summary>
        </member>
        <member name="P:System.SR.Loader_ContextPolicies">
            <summary>Context Policies:</summary>
        </member>
        <member name="P:System.SR.Loader_Name">
            <summary>Name:</summary>
        </member>
        <member name="P:System.SR.Loader_NoContextPolicies">
            <summary>There are no context policies.</summary>
        </member>
        <member name="P:System.SR.ManualResetEventSlim_ctor_SpinCountOutOfRange">
            <summary>The spinCount argument must be in the range 0 to {0}, inclusive.</summary>
        </member>
        <member name="P:System.SR.ManualResetEventSlim_ctor_TooManyWaiters">
            <summary>There are too many threads currently waiting on the event. A maximum of {0} waiting threads are supported.</summary>
        </member>
        <member name="P:System.SR.ManualResetEventSlim_Disposed">
            <summary>The event has been disposed.</summary>
        </member>
        <member name="P:System.SR.Marshaler_StringTooLong">
            <summary>Marshaler restriction: Excessively long string.</summary>
        </member>
        <member name="P:System.SR.MissingConstructor_Name">
            <summary>Constructor on type '{0}' not found.</summary>
        </member>
        <member name="P:System.SR.MissingField">
            <summary>Field not found.</summary>
        </member>
        <member name="P:System.SR.MissingField_Name">
            <summary>Field '{0}' not found.</summary>
        </member>
        <member name="P:System.SR.MissingManifestResource_MultipleBlobs">
            <summary>A case-insensitive lookup for resource file "{0}" in assembly "{1}" found multiple entries. Remove the duplicates or specify the exact case.</summary>
        </member>
        <member name="P:System.SR.MissingManifestResource_NoNeutralAsm">
            <summary>Could not find the resource "{0}" among the resources {2} embedded in the assembly "{1}", nor among the resources in any satellite assemblies for the specified culture. Perhaps the resources were embedded with an incorrect name.</summary>
        </member>
        <member name="P:System.SR.MissingManifestResource_NoNeutralDisk">
            <summary>Could not find any resources appropriate for the specified culture (or the neutral culture) on disk.</summary>
        </member>
        <member name="P:System.SR.MissingManifestResource_NoPRIresources">
            <summary>Unable to open Package Resource Index.</summary>
        </member>
        <member name="P:System.SR.MissingManifestResource_ResWFileNotLoaded">
            <summary>Unable to load resources for resource file "{0}" in package "{1}".</summary>
        </member>
        <member name="P:System.SR.MissingMember">
            <summary>Member not found.</summary>
        </member>
        <member name="P:System.SR.MissingMember_Name">
            <summary>Member '{0}' not found.</summary>
        </member>
        <member name="P:System.SR.MissingMemberNestErr">
            <summary>TypedReference can only be made on nested value Types.</summary>
        </member>
        <member name="P:System.SR.MissingMemberTypeRef">
            <summary>FieldInfo does not match the target Type.</summary>
        </member>
        <member name="P:System.SR.MissingMethod_Name">
            <summary>Method '{0}' not found.</summary>
        </member>
        <member name="P:System.SR.MissingSatelliteAssembly_Culture_Name">
            <summary>The satellite assembly named "{1}" for fallback culture "{0}" either could not be found or could not be loaded. This is generally a setup problem. Please consider reinstalling or repairing the application.</summary>
        </member>
        <member name="P:System.SR.MissingSatelliteAssembly_Default">
            <summary>Resource lookup fell back to the ultimate fallback resources in a satellite assembly, but that satellite either was not found or could not be loaded. Please consider reinstalling or repairing the application.</summary>
        </member>
        <member name="P:System.SR.Multicast_Combine">
            <summary>Delegates that are not of type MulticastDelegate may not be combined.</summary>
        </member>
        <member name="P:System.SR.MustUseCCRewrite">
            <summary>An assembly (probably "{1}") must be rewritten using the code contracts binary rewriter (CCRewrite) because it is calling Contract.{0} and the CONTRACTS_FULL symbol is defined.  Remove any explicit definitions of the CONTRACTS_FULL symbol from your project ...</summary>
        </member>
        <member name="P:System.SR.NotImplemented_ResourcesLongerThanInt64Max">
            <summary>Resource files longer than 2^63 bytes are not currently implemented.</summary>
        </member>
        <member name="P:System.SR.NotSupported_AbstractNonCLS">
            <summary>This non-CLS method is not implemented.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ActivAttr">
            <summary>Activation Attributes are not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_AppX">
            <summary>{0} is not supported in AppX.</summary>
        </member>
        <member name="P:System.SR.NotSupported_AssemblyLoadFromHash">
            <summary>Assembly.LoadFrom with hashValue is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ByRefLike">
            <summary>Cannot create boxed ByRef-like values.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ByRefLikeArray">
            <summary>Cannot create arrays of ByRef-like values.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ByRefToByRefLikeReturn">
            <summary>ByRef to ByRef-like return values are not supported in reflection invocation.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ByRefToVoidReturn">
            <summary>ByRef to void return values are not supported in reflection invocation.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CallToVarArg">
            <summary>Vararg calling convention not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CannotCallEqualsOnSpan">
            <summary>Equals() on Span and ReadOnlySpan is not supported. Use operator== instead.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CannotCallGetHashCodeOnSpan">
            <summary>GetHashCode() on Span and ReadOnlySpan is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ChangeType">
            <summary>ChangeType operation is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CollectibleAssemblyResolve">
            <summary>Resolving to a collectible assembly is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CollectibleBoundNonCollectible">
            <summary>A non-collectible assembly may not reference a collectible assembly.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CollectibleWinRT">
            <summary>WinRT Interop is not supported for collectible types.</summary>
        </member>
        <member name="P:System.SR.NotSupported_CreateInstanceWithTypeBuilder">
            <summary>CreateInstance cannot be used with an object of type TypeBuilder.</summary>
        </member>
        <member name="P:System.SR.NotSupported_DBNullSerial">
            <summary>Only one DBNull instance may exist, and calls to DBNull deserialization methods are not allowed.</summary>
        </member>
        <member name="P:System.SR.NotSupported_DynamicAssembly">
            <summary>The invoked member is not supported in a dynamic assembly.</summary>
        </member>
        <member name="P:System.SR.NotSupported_DynamicMethodFlags">
            <summary>Wrong MethodAttributes or CallingConventions for DynamicMethod. Only public, static, standard supported</summary>
        </member>
        <member name="P:System.SR.NotSupported_DynamicModule">
            <summary>The invoked member is not supported in a dynamic module.</summary>
        </member>
        <member name="P:System.SR.NotSupported_FileStreamOnNonFiles">
            <summary>FileStream was asked to open a device that was not a file. For support for devices like 'com1:' or 'lpt1:', call CreateFile, then use the FileStream constructors that take an OS handle as an IntPtr.</summary>
        </member>
        <member name="P:System.SR.NotSupported_FixedSizeCollection">
            <summary>Collection was of a fixed size.</summary>
        </member>
        <member name="P:System.SR.NotSupported_GenericMethod">
            <summary>Generic methods with NativeCallableAttribute are not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_GlobalMethodSerialization">
            <summary>Serialization of global methods (including implicit serialization via the use of asynchronous delegates) is not supported.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_SpanOverlappedOperation">
            <summary>This operation is invalid on overlapping buffers.</summary>
        </member>
        <member name="P:System.SR.NotSupported_IDispInvokeDefaultMemberWithNamedArgs">
            <summary>Invoking default method with named arguments is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_IllegalOneByteBranch">
            <summary>Illegal one-byte branch at position: {0}. Requested branch was: {1}.</summary>
        </member>
        <member name="P:System.SR.NotSupported_KeyCollectionSet">
            <summary>Mutating a key collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ManagedActivation">
            <summary>Cannot create uninitialized instances of types requiring managed activation.</summary>
        </member>
        <member name="P:System.SR.NotSupported_MaxWaitHandles">
            <summary>The number of WaitHandles must be less than or equal to 64.</summary>
        </member>
        <member name="P:System.SR.NotSupported_MemStreamNotExpandable">
            <summary>Memory stream is not expandable.</summary>
        </member>
        <member name="P:System.SR.NotSupported_MustBeModuleBuilder">
            <summary>Module argument must be a ModuleBuilder.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NativeCallableTarget">
            <summary>Methods with NativeCallableAttribute cannot be used as delegate target.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NoCodepageData">
            <summary>No data is available for encoding {0}. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NonBlittableTypes">
            <summary>Non-blittable parameter types are not supported for NativeCallable methods.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NonReflectedType">
            <summary>Not supported in a non-reflected type.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NonStaticMethod">
            <summary>Non-static methods with NativeCallableAttribute are not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NoParentDefaultConstructor">
            <summary>Parent does not have a default constructor. The default constructor must be explicitly defined.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NoTypeInfo">
            <summary>Cannot resolve {0} to a TypeInfo object.</summary>
        </member>
        <member name="P:System.SR.NotSupported_NYI">
            <summary>This feature is not currently implemented.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ObsoleteResourcesFile">
            <summary>Found an obsolete .resources file in assembly '{0}'. Rebuild that .resources file then rebuild that assembly.</summary>
        </member>
        <member name="P:System.SR.NotSupported_OleAutBadVarType">
            <summary>The given Variant type is not supported by this OleAut function.</summary>
        </member>
        <member name="P:System.SR.NotSupported_OpenType">
            <summary>Cannot create arrays of open type.</summary>
        </member>
        <member name="P:System.SR.NotSupported_OutputStreamUsingTypeBuilder">
            <summary>Output streams do not support TypeBuilders.</summary>
        </member>
        <member name="P:System.SR.NotSupported_PIAInAppxProcess">
            <summary>A Primary Interop Assembly is not supported in AppX.</summary>
        </member>
        <member name="P:System.SR.NotSupported_RangeCollection">
            <summary>The specified operation is not supported on Ranges.</summary>
        </member>
        <member name="P:System.SR.NotSupported_Reading">
            <summary>Accessor does not support reading.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ReadOnlyCollection">
            <summary>Collection is read-only.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ResourceObjectSerialization">
            <summary>Cannot read resources that depend on serialization.</summary>
        </member>
        <member name="P:System.SR.NotSupported_SignalAndWaitSTAThread">
            <summary>SignalAndWait on a STA thread is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_StringComparison">
            <summary>The string comparison type passed in is currently not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_SubclassOverride">
            <summary>Derived classes must provide an implementation.</summary>
        </member>
        <member name="P:System.SR.NotSupported_SymbolMethod">
            <summary>Not supported in an array method of a type definition that is not complete.</summary>
        </member>
        <member name="P:System.SR.NotSupported_TooManyArgs">
            <summary>Stack size too deep. Possibly too many arguments.</summary>
        </member>
        <member name="P:System.SR.NotSupported_Type">
            <summary>Type is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_TypeCannotDeserialized">
            <summary>Direct deserialization of type '{0}' is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_TypeNotYetCreated">
            <summary>The invoked member is not supported before the type is created.</summary>
        </member>
        <member name="P:System.SR.NotSupported_UmsSafeBuffer">
            <summary>This operation is not supported for an UnmanagedMemoryStream created from a SafeBuffer.</summary>
        </member>
        <member name="P:System.SR.NotSupported_UnitySerHolder">
            <summary>The UnitySerializationHolder object is designed to transmit information about other types and is not serializable itself.</summary>
        </member>
        <member name="P:System.SR.NotSupported_UnknownTypeCode">
            <summary>TypeCode '{0}' was not valid.</summary>
        </member>
        <member name="P:System.SR.NotSupported_WaitAllSTAThread">
            <summary>WaitAll for multiple handles on a STA thread is not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_UnreadableStream">
            <summary>Stream does not support reading.</summary>
        </member>
        <member name="P:System.SR.NotSupported_UnseekableStream">
            <summary>Stream does not support seeking.</summary>
        </member>
        <member name="P:System.SR.NotSupported_UnwritableStream">
            <summary>Stream does not support writing.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ValueClassCM">
            <summary>Custom marshalers for value types are not currently supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ValueCollectionSet">
            <summary>Mutating a value collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:System.SR.NotSupported_VoidArray">
            <summary>Arrays of System.Void are not supported.</summary>
        </member>
        <member name="P:System.SR.NotSupported_WinRT_PartialTrust">
            <summary>Windows Runtime is not supported in partial trust.</summary>
        </member>
        <member name="P:System.SR.NotSupported_Writing">
            <summary>Accessor does not support writing.</summary>
        </member>
        <member name="P:System.SR.NotSupported_WrongResourceReader_Type">
            <summary>This .resources file should not be read with this reader. The resource reader type is "{0}".</summary>
        </member>
        <member name="P:System.SR.NullReference_This">
            <summary>The pointer for this method was null.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_FileClosed">
            <summary>Cannot access a closed file.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_Generic">
            <summary>Cannot access a disposed object.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_ObjectName_Name">
            <summary>Object name: '{0}'.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_WriterClosed">
            <summary>Cannot write to a closed TextWriter.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_ReaderClosed">
            <summary>Cannot read from a closed TextReader.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_ResourceSet">
            <summary>Cannot access a closed resource set.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_StreamClosed">
            <summary>Cannot access a closed Stream.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_ViewAccessorClosed">
            <summary>Cannot access a closed accessor.</summary>
        </member>
        <member name="P:System.SR.ObjectDisposed_SafeHandleClosed">
            <summary>Safe handle has been closed.</summary>
        </member>
        <member name="P:System.SR.OperationCanceled">
            <summary>The operation was canceled.</summary>
        </member>
        <member name="P:System.SR.OutOfMemory_GCHandleMDA">
            <summary>The GCHandle MDA has run out of available cookies.</summary>
        </member>
        <member name="P:System.SR.Overflow_Byte">
            <summary>Value was either too large or too small for an unsigned byte.</summary>
        </member>
        <member name="P:System.SR.Overflow_Char">
            <summary>Value was either too large or too small for a character.</summary>
        </member>
        <member name="P:System.SR.Overflow_Currency">
            <summary>Value was either too large or too small for a Currency.</summary>
        </member>
        <member name="P:System.SR.Overflow_Decimal">
            <summary>Value was either too large or too small for a Decimal.</summary>
        </member>
        <member name="P:System.SR.Overflow_Duration">
            <summary>The duration cannot be returned for TimeSpan.MinValue because the absolute value of TimeSpan.MinValue exceeds the value of TimeSpan.MaxValue.</summary>
        </member>
        <member name="P:System.SR.Overflow_Int16">
            <summary>Value was either too large or too small for an Int16.</summary>
        </member>
        <member name="P:System.SR.Overflow_Int32">
            <summary>Value was either too large or too small for an Int32.</summary>
        </member>
        <member name="P:System.SR.Overflow_Int64">
            <summary>Value was either too large or too small for an Int64.</summary>
        </member>
        <member name="P:System.SR.Overflow_NegateTwosCompNum">
            <summary>Negating the minimum value of a twos complement number is invalid.</summary>
        </member>
        <member name="P:System.SR.Overflow_NegativeUnsigned">
            <summary>The string was being parsed as an unsigned number and could not have a negative sign.</summary>
        </member>
        <member name="P:System.SR.Overflow_SByte">
            <summary>Value was either too large or too small for a signed byte.</summary>
        </member>
        <member name="P:System.SR.Overflow_TimeSpanElementTooLarge">
            <summary>The TimeSpan string '{0}' could not be parsed because at least one of the numeric components is out of range or contains too many digits.</summary>
        </member>
        <member name="P:System.SR.Overflow_TimeSpanTooLong">
            <summary>TimeSpan overflowed because the duration is too long.</summary>
        </member>
        <member name="P:System.SR.Overflow_UInt16">
            <summary>Value was either too large or too small for a UInt16.</summary>
        </member>
        <member name="P:System.SR.Overflow_UInt32">
            <summary>Value was either too large or too small for a UInt32.</summary>
        </member>
        <member name="P:System.SR.Overflow_UInt64">
            <summary>Value was either too large or too small for a UInt64.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_ArgIterator">
            <summary>ArgIterator is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_ComInterop">
            <summary>COM Interop is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_NamedSynchronizationPrimitives">
            <summary>The named version of this synchronization primitive is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_NamedSyncObjectWaitAnyWaitAll">
            <summary>Wait operations on multiple wait handles including a named synchronization primitive are not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_OSXFileLocking">
            <summary>Locking/unlocking file regions is not supported on this platform. Use FileShare on the entire file instead.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_ReflectionOnly">
            <summary>ReflectionOnly loading is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_Remoting">
            <summary>Remoting is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_SecureBinarySerialization">
            <summary>Secure binary serialization is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_StrongNameSigning">
            <summary>Strong-name signing is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_WinRT">
            <summary>Windows Runtime is not supported on this operating system.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_OverlappedIO">
            <summary>This API is specific to the way in which Windows handles asynchronous I/O, and is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_ITypeInfo">
            <summary>Marshalling a System.Type to an unmanaged ITypeInfo or marshalling an ITypeInfo to a System.Type is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_IExpando">
            <summary>Marshalling an IDispatchEx to an IReflect or IExpando is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_AppDomains">
            <summary>Secondary AppDomains are not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_CAS">
            <summary>Code Access Security is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_Principal">
            <summary>Windows Principal functionality is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_ThreadAbort">
            <summary>Thread abort is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_ThreadSuspend">
            <summary>Thread suspend is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.Policy_CannotLoadSemiTrustAssembliesDuringInit">
            <summary>All assemblies loaded as part of AppDomain initialization must be fully trusted.</summary>
        </member>
        <member name="P:System.SR.PostconditionFailed">
            <summary>Postcondition failed.</summary>
        </member>
        <member name="P:System.SR.PostconditionFailed_Cnd">
            <summary>Postcondition failed: {0}</summary>
        </member>
        <member name="P:System.SR.PostconditionOnExceptionFailed">
            <summary>Postcondition failed after throwing an exception.</summary>
        </member>
        <member name="P:System.SR.PostconditionOnExceptionFailed_Cnd">
            <summary>Postcondition failed after throwing an exception: {0}</summary>
        </member>
        <member name="P:System.SR.PreconditionFailed">
            <summary>Precondition failed.</summary>
        </member>
        <member name="P:System.SR.PreconditionFailed_Cnd">
            <summary>Precondition failed: {0}</summary>
        </member>
        <member name="P:System.SR.PersistedFiles_NoHomeDirectory">
            <summary>The home directory of the current user could not be determined.</summary>
        </member>
        <member name="P:System.SR.Rank_MultiDimNotSupported">
            <summary>Only single dimension arrays are supported here.</summary>
        </member>
        <member name="P:System.SR.Rank_MustMatch">
            <summary>The specified arrays must have the same number of dimensions.</summary>
        </member>
        <member name="P:System.SR.ReflectionTypeLoad_LoadFailed">
            <summary>Unable to load one or more of the requested types.</summary>
        </member>
        <member name="P:System.SR.ResourceReaderIsClosed">
            <summary>ResourceReader is closed.</summary>
        </member>
        <member name="P:System.SR.Resources_StreamNotValid">
            <summary>Stream is not a valid resource file.</summary>
        </member>
        <member name="P:System.SR.RFLCT_AmbigCust">
            <summary>Multiple custom attributes of the same type found.</summary>
        </member>
        <member name="P:System.SR.RFLCT_Ambiguous">
            <summary>Ambiguous match found.</summary>
        </member>
        <member name="P:System.SR.InvalidFilterCriteriaException_CritInt">
            <summary>An Int32 must be provided for the filter criteria.</summary>
        </member>
        <member name="P:System.SR.InvalidFilterCriteriaException_CritString">
            <summary>A String must be provided for the filter criteria.</summary>
        </member>
        <member name="P:System.SR.RFLCT_InvalidFieldFail">
            <summary>'{0}' field specified was not found.</summary>
        </member>
        <member name="P:System.SR.RFLCT_InvalidPropFail">
            <summary>'{0}' property specified was not found.</summary>
        </member>
        <member name="P:System.SR.RFLCT_Targ_ITargMismatch">
            <summary>Object does not match target type.</summary>
        </member>
        <member name="P:System.SR.RFLCT_Targ_StatFldReqTarg">
            <summary>Non-static field requires a target.</summary>
        </member>
        <member name="P:System.SR.RFLCT_Targ_StatMethReqTarg">
            <summary>Non-static method requires a target.</summary>
        </member>
        <member name="P:System.SR.RuntimeWrappedException">
            <summary>An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException.</summary>
        </member>
        <member name="P:System.SR.Security_CannotReadFileData">
            <summary>The time zone ID '{0}' was found on the local computer, but the application does not have permission to read the file.</summary>
        </member>
        <member name="P:System.SR.Security_CannotReadRegistryData">
            <summary>The time zone ID '{0}' was found on the local computer, but the application does not have permission to read the registry information.</summary>
        </member>
        <member name="P:System.SR.Security_RegistryPermission">
            <summary>Requested registry access is not allowed.</summary>
        </member>
        <member name="P:System.SR.SemaphoreSlim_ctor_InitialCountWrong">
            <summary>The initialCount argument must be non-negative and less than or equal to the maximumCount.</summary>
        </member>
        <member name="P:System.SR.SemaphoreSlim_ctor_MaxCountWrong">
            <summary>The maximumCount argument must be a positive number. If a maximum is not required, use the constructor without a maxCount parameter.</summary>
        </member>
        <member name="P:System.SR.SemaphoreSlim_Disposed">
            <summary>The semaphore has been disposed.</summary>
        </member>
        <member name="P:System.SR.SemaphoreSlim_Release_CountWrong">
            <summary>The releaseCount argument must be greater than zero.</summary>
        </member>
        <member name="P:System.SR.SemaphoreSlim_Wait_TimeoutWrong">
            <summary>The timeout must represent a value between -1 and Int32.MaxValue, inclusive.</summary>
        </member>
        <member name="P:System.SR.Serialization_BadParameterInfo">
            <summary>Non existent ParameterInfo. Position bigger than member's parameters length.</summary>
        </member>
        <member name="P:System.SR.Serialization_CorruptField">
            <summary>The value of the field '{0}' is invalid.  The serialized data is corrupt.</summary>
        </member>
        <member name="P:System.SR.Serialization_DateTimeTicksOutOfRange">
            <summary>Invalid serialized DateTime data. Ticks must be between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks.</summary>
        </member>
        <member name="P:System.SR.Serialization_DelegatesNotSupported">
            <summary>Serializing delegates is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.Serialization_InsufficientDeserializationState">
            <summary>Insufficient state to deserialize the object. Missing field '{0}'. More information is needed.</summary>
        </member>
        <member name="P:System.SR.Serialization_InsufficientState">
            <summary>Insufficient state to return the real object.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidData">
            <summary>An error occurred while deserializing the object.  The serialized data is corrupt.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidDelegateType">
            <summary>Cannot serialize delegates over unmanaged function pointers, dynamic methods or methods outside the delegate creator's assembly.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidEscapeSequence">
            <summary>The serialized data contained an invalid escape sequence '\\{0}'.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidFieldState">
            <summary>Object fields may not be properly initialized.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidOnDeser">
            <summary>OnDeserialization method was called while the object was not being deserialized.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidPtrValue">
            <summary>An IntPtr or UIntPtr with an eight byte value cannot be deserialized on a machine with a four byte word size.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidType">
            <summary>Only system-provided types can be passed to the GetUninitializedObject method. '{0}' is not a valid instance of a type.</summary>
        </member>
        <member name="P:System.SR.Serialization_KeyValueDifferentSizes">
            <summary>The keys and values arrays have different sizes.</summary>
        </member>
        <member name="P:System.SR.Serialization_MemberOutOfRange">
            <summary>The deserialized value of the member "{0}" in the class "{1}" is out of range.</summary>
        </member>
        <member name="P:System.SR.Serialization_MemberTypeNotRecognized">
            <summary>Unknown member type.</summary>
        </member>
        <member name="P:System.SR.Serialization_MissField">
            <summary>Field {0} is missing.</summary>
        </member>
        <member name="P:System.SR.Serialization_MissingDateTimeData">
            <summary>Invalid serialized DateTime data. Unable to find 'ticks' or 'dateData'.</summary>
        </member>
        <member name="P:System.SR.Serialization_MissingKeys">
            <summary>The Keys for this Hashtable are missing.</summary>
        </member>
        <member name="P:System.SR.Serialization_MissingValues">
            <summary>The values for this dictionary are missing.</summary>
        </member>
        <member name="P:System.SR.Serialization_NoParameterInfo">
            <summary>Serialized member does not have a ParameterInfo.</summary>
        </member>
        <member name="P:System.SR.Serialization_NotFound">
            <summary>Member '{0}' was not found.</summary>
        </member>
        <member name="P:System.SR.Serialization_NullKey">
            <summary>One of the serialized keys is null.</summary>
        </member>
        <member name="P:System.SR.Serialization_NullSignature">
            <summary>The method signature cannot be null.</summary>
        </member>
        <member name="P:System.SR.Serialization_OptionalFieldVersionValue">
            <summary>Version value must be positive.</summary>
        </member>
        <member name="P:System.SR.Serialization_SameNameTwice">
            <summary>Cannot add the same member twice to a SerializationInfo object.</summary>
        </member>
        <member name="P:System.SR.Serialization_StringBuilderCapacity">
            <summary>The serialized Capacity property of StringBuilder must be positive, less than or equal to MaxCapacity and greater than or equal to the String length.</summary>
        </member>
        <member name="P:System.SR.Serialization_StringBuilderMaxCapacity">
            <summary>The serialized MaxCapacity property of StringBuilder must be positive and greater than or equal to the String length.</summary>
        </member>
        <member name="P:System.SR.Serialization_UnableToFindModule">
            <summary>The given module {0} cannot be found within the assembly {1}.</summary>
        </member>
        <member name="P:System.SR.Serialization_UnknownMember">
            <summary>Cannot get the member '{0}'.</summary>
        </member>
        <member name="P:System.SR.SpinLock_Exit_SynchronizationLockException">
            <summary>The calling thread does not hold the lock.</summary>
        </member>
        <member name="P:System.SR.SpinLock_IsHeldByCurrentThread">
            <summary>Thread tracking is disabled.</summary>
        </member>
        <member name="P:System.SR.SpinLock_TryEnter_ArgumentOutOfRange">
            <summary>The timeout must be a value between -1 and Int32.MaxValue, inclusive.</summary>
        </member>
        <member name="P:System.SR.SpinLock_TryEnter_LockRecursionException">
            <summary>The calling thread already holds the lock.</summary>
        </member>
        <member name="P:System.SR.SpinLock_TryReliableEnter_ArgumentException">
            <summary>The tookLock argument must be set to false before calling this method.</summary>
        </member>
        <member name="P:System.SR.SpinWait_SpinUntil_ArgumentNull">
            <summary>The condition argument is null.</summary>
        </member>
        <member name="P:System.SR.SpinWait_SpinUntil_TimeoutWrong">
            <summary>The timeout must represent a value between -1 and Int32.MaxValue, inclusive.</summary>
        </member>
        <member name="P:System.SR.StackTrace_InFileLineNumber">
            <summary>in {0}:line {1}</summary>
        </member>
        <member name="P:System.SR.Task_ContinueWith_ESandLR">
            <summary>The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running.</summary>
        </member>
        <member name="P:System.SR.Task_ContinueWith_NotOnAnything">
            <summary>The specified TaskContinuationOptions excluded all continuation kinds.</summary>
        </member>
        <member name="P:System.SR.Task_Delay_InvalidDelay">
            <summary>The value needs to translate in milliseconds to -1 (signifying an infinite timeout), 0 or a positive integer less than or equal to Int32.MaxValue.</summary>
        </member>
        <member name="P:System.SR.Task_Delay_InvalidMillisecondsDelay">
            <summary>The value needs to be either -1 (signifying an infinite timeout), 0 or a positive integer.</summary>
        </member>
        <member name="P:System.SR.Task_Dispose_NotCompleted">
            <summary>A task may only be disposed if it is in a completion state (RanToCompletion, Faulted or Canceled).</summary>
        </member>
        <member name="P:System.SR.Task_FromAsync_LongRunning">
            <summary>It is invalid to specify TaskCreationOptions.LongRunning in calls to FromAsync.</summary>
        </member>
        <member name="P:System.SR.Task_FromAsync_PreferFairness">
            <summary>It is invalid to specify TaskCreationOptions.PreferFairness in calls to FromAsync.</summary>
        </member>
        <member name="P:System.SR.Task_MultiTaskContinuation_EmptyTaskList">
            <summary>The tasks argument contains no tasks.</summary>
        </member>
        <member name="P:System.SR.Task_MultiTaskContinuation_FireOptions">
            <summary>It is invalid to exclude specific continuation kinds for continuations off of multiple tasks.</summary>
        </member>
        <member name="P:System.SR.Task_MultiTaskContinuation_NullTask">
            <summary>The tasks argument included a null value.</summary>
        </member>
        <member name="P:System.SR.Task_RunSynchronously_AlreadyStarted">
            <summary>RunSynchronously may not be called on a task that was already started.</summary>
        </member>
        <member name="P:System.SR.Task_RunSynchronously_Continuation">
            <summary>RunSynchronously may not be called on a continuation task.</summary>
        </member>
        <member name="P:System.SR.Task_RunSynchronously_Promise">
            <summary>RunSynchronously may not be called on a task not bound to a delegate, such as the task returned from an asynchronous method.</summary>
        </member>
        <member name="P:System.SR.Task_RunSynchronously_TaskCompleted">
            <summary>RunSynchronously may not be called on a task that has already completed.</summary>
        </member>
        <member name="P:System.SR.Task_Start_AlreadyStarted">
            <summary>Start may not be called on a task that was already started.</summary>
        </member>
        <member name="P:System.SR.Task_Start_ContinuationTask">
            <summary>Start may not be called on a continuation task.</summary>
        </member>
        <member name="P:System.SR.Task_Start_Promise">
            <summary>Start may not be called on a promise-style task.</summary>
        </member>
        <member name="P:System.SR.Task_Start_TaskCompleted">
            <summary>Start may not be called on a task that has completed.</summary>
        </member>
        <member name="P:System.SR.Task_ThrowIfDisposed">
            <summary>The task has been disposed.</summary>
        </member>
        <member name="P:System.SR.Task_WaitMulti_NullTask">
            <summary>The tasks array included at least one null element.</summary>
        </member>
        <member name="P:System.SR.TaskCanceledException_ctor_DefaultMessage">
            <summary>A task was canceled.</summary>
        </member>
        <member name="P:System.SR.TaskCompletionSourceT_TrySetException_NoExceptions">
            <summary>The exceptions collection was empty.</summary>
        </member>
        <member name="P:System.SR.TaskCompletionSourceT_TrySetException_NullException">
            <summary>The exceptions collection included at least one null element.</summary>
        </member>
        <member name="P:System.SR.TaskExceptionHolder_UnhandledException">
            <summary>A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result, the unobserved exception was rethrown by the finalizer thread.</summary>
        </member>
        <member name="P:System.SR.TaskExceptionHolder_UnknownExceptionType">
            <summary>(Internal)Expected an Exception or an IEnumerable&lt;Exception&gt;</summary>
        </member>
        <member name="P:System.SR.TaskScheduler_ExecuteTask_WrongTaskScheduler">
            <summary>ExecuteTask may not be called for a task which was previously queued to a different TaskScheduler.</summary>
        </member>
        <member name="P:System.SR.TaskScheduler_FromCurrentSynchronizationContext_NoCurrent">
            <summary>The current SynchronizationContext may not be used as a TaskScheduler.</summary>
        </member>
        <member name="P:System.SR.TaskScheduler_InconsistentStateAfterTryExecuteTaskInline">
            <summary>The TryExecuteTaskInline call to the underlying scheduler succeeded, but the task body was not invoked.</summary>
        </member>
        <member name="P:System.SR.TaskSchedulerException_ctor_DefaultMessage">
            <summary>An exception was thrown by a TaskScheduler.</summary>
        </member>
        <member name="P:System.SR.TaskT_DebuggerNoResult">
            <summary>{Not yet computed}</summary>
        </member>
        <member name="P:System.SR.TaskT_TransitionToFinal_AlreadyCompleted">
            <summary>An attempt was made to transition a task to a final state when it had already completed.</summary>
        </member>
        <member name="P:System.SR.Thread_ApartmentState_ChangeFailed">
            <summary>Failed to set the specified COM apartment state.</summary>
        </member>
        <member name="P:System.SR.Thread_GetSetCompressedStack_NotSupported">
            <summary>Use CompressedStack.(Capture/Run) instead.</summary>
        </member>
        <member name="P:System.SR.Thread_Operation_RequiresCurrentThread">
            <summary>This operation must be performed on the same thread as that represented by the Thread instance.</summary>
        </member>
        <member name="P:System.SR.Threading_AbandonedMutexException">
            <summary>The wait completed due to an abandoned mutex.</summary>
        </member>
        <member name="P:System.SR.Threading_WaitHandleCannotBeOpenedException">
            <summary>No handle of the given name exists.</summary>
        </member>
        <member name="P:System.SR.Threading_WaitHandleCannotBeOpenedException_InvalidHandle">
            <summary>A WaitHandle with system-wide name '{0}' cannot be created. A WaitHandle of a different type might have the same name.</summary>
        </member>
        <member name="P:System.SR.Threading_WaitHandleTooManyPosts">
            <summary>The WaitHandle cannot be signaled because it would exceed its maximum count.</summary>
        </member>
        <member name="P:System.SR.Threading_SemaphoreFullException">
            <summary>Adding the specified count to the semaphore would cause it to exceed its maximum count.</summary>
        </member>
        <member name="P:System.SR.Threading_ThreadInterrupted">
            <summary>Thread was interrupted from a waiting state.</summary>
        </member>
        <member name="P:System.SR.ThreadLocal_Disposed">
            <summary>The ThreadLocal object has been disposed.</summary>
        </member>
        <member name="P:System.SR.ThreadLocal_Value_RecursiveCallsToValue">
            <summary>ValueFactory attempted to access the Value property of this instance.</summary>
        </member>
        <member name="P:System.SR.ThreadLocal_ValuesNotAvailable">
            <summary>The ThreadLocal object is not tracking values. To use the Values property, use a ThreadLocal constructor that accepts the trackAllValues parameter and set the parameter to true.</summary>
        </member>
        <member name="P:System.SR.TimeZoneNotFound_MissingData">
            <summary>The time zone ID '{0}' was not found on the local computer.</summary>
        </member>
        <member name="P:System.SR.TypeInitialization_Default">
            <summary>Type constructor threw an exception.</summary>
        </member>
        <member name="P:System.SR.TypeInitialization_Type">
            <summary>The type initializer for '{0}' threw an exception.</summary>
        </member>
        <member name="P:System.SR.TypeLoad_ResolveNestedType">
            <summary>Could not resolve nested type '{0}' in type "{1}'.</summary>
        </member>
        <member name="P:System.SR.TypeLoad_ResolveType">
            <summary>Could not resolve type '{0}'.</summary>
        </member>
        <member name="P:System.SR.TypeLoad_ResolveTypeFromAssembly">
            <summary>Could not resolve type '{0}' in assembly '{1}'.</summary>
        </member>
        <member name="P:System.SR.UnauthorizedAccess_IODenied_NoPathName">
            <summary>Access to the path is denied.</summary>
        </member>
        <member name="P:System.SR.UnauthorizedAccess_IODenied_Path">
            <summary>Access to the path '{0}' is denied.</summary>
        </member>
        <member name="P:System.SR.UnauthorizedAccess_MemStreamBuffer">
            <summary>MemoryStream's internal buffer cannot be accessed.</summary>
        </member>
        <member name="P:System.SR.UnauthorizedAccess_RegistryKeyGeneric_Key">
            <summary>Access to the registry key '{0}' is denied.</summary>
        </member>
        <member name="P:System.SR.UnknownError_Num">
            <summary>Unknown error "{0}".</summary>
        </member>
        <member name="P:System.SR.Verification_Exception">
            <summary>Operation could destabilize the runtime.</summary>
        </member>
        <member name="P:System.SR.Word_At">
            <summary>at</summary>
        </member>
        <member name="P:System.SR.DebugAssertBanner">
            <summary>---- DEBUG ASSERTION FAILED ----</summary>
        </member>
        <member name="P:System.SR.DebugAssertLongMessage">
            <summary>---- Assert Long Message ----</summary>
        </member>
        <member name="P:System.SR.DebugAssertShortMessage">
            <summary>---- Assert Short Message ----</summary>
        </member>
        <member name="P:System.SR.LockRecursionException_ReadAfterWriteNotAllowed">
            <summary>A read lock may not be acquired with the write lock held in this mode.</summary>
        </member>
        <member name="P:System.SR.LockRecursionException_RecursiveReadNotAllowed">
            <summary>Recursive read lock acquisitions not allowed in this mode.</summary>
        </member>
        <member name="P:System.SR.LockRecursionException_RecursiveWriteNotAllowed">
            <summary>Recursive write lock acquisitions not allowed in this mode.</summary>
        </member>
        <member name="P:System.SR.LockRecursionException_RecursiveUpgradeNotAllowed">
            <summary>Recursive upgradeable lock acquisitions not allowed in this mode.</summary>
        </member>
        <member name="P:System.SR.LockRecursionException_WriteAfterReadNotAllowed">
            <summary>Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.</summary>
        </member>
        <member name="P:System.SR.SynchronizationLockException_MisMatchedUpgrade">
            <summary>The upgradeable lock is being released without being held.</summary>
        </member>
        <member name="P:System.SR.SynchronizationLockException_MisMatchedRead">
            <summary>The read lock is being released without being held.</summary>
        </member>
        <member name="P:System.SR.SynchronizationLockException_IncorrectDispose">
            <summary>The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock.</summary>
        </member>
        <member name="P:System.SR.LockRecursionException_UpgradeAfterReadNotAllowed">
            <summary>Upgradeable lock may not be acquired with read lock held.</summary>
        </member>
        <member name="P:System.SR.LockRecursionException_UpgradeAfterWriteNotAllowed">
            <summary>Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer.</summary>
        </member>
        <member name="P:System.SR.SynchronizationLockException_MisMatchedWrite">
            <summary>The write lock is being released without being held.</summary>
        </member>
        <member name="P:System.SR.NotSupported_SignatureType">
            <summary>This method is not supported on signature types.</summary>
        </member>
        <member name="P:System.SR.MemoryDisposed">
            <summary>Memory&lt;T&gt; has been disposed.</summary>
        </member>
        <member name="P:System.SR.Memory_OutstandingReferences">
            <summary>Release all references before disposing this instance.</summary>
        </member>
        <member name="P:System.SR.HashCode_HashCodeNotSupported">
            <summary>HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.</summary>
        </member>
        <member name="P:System.SR.HashCode_EqualityNotSupported">
            <summary>HashCode is a mutable struct and should not be compared with other HashCodes.</summary>
        </member>
        <member name="P:System.SR.Arg_TypeNotSupported">
            <summary>Specified type is not supported</summary>
        </member>
        <member name="P:System.SR.IO_InvalidReadLength">
            <summary>The read operation returned an invalid length.</summary>
        </member>
        <member name="P:System.SR.Arg_BasePathNotFullyQualified">
            <summary>Basepath argument is not fully qualified.</summary>
        </member>
        <member name="P:System.SR.Arg_ElementsInSourceIsGreaterThanDestination">
            <summary>Number of elements in source vector is greater than the destination array</summary>
        </member>
        <member name="P:System.SR.Arg_NullArgumentNullRef">
            <summary>The method was called with a null array argument.</summary>
        </member>
        <member name="P:System.SR.Argument_CannotPrepareAbstract">
            <summary>Abstract methods cannot be prepared.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidGenericInstantiation">
            <summary>The given generic instantiation was invalid.</summary>
        </member>
        <member name="P:System.SR.Argument_OverlapAlignmentMismatch">
            <summary>Overlapping spans have mismatching alignment.</summary>
        </member>
        <member name="P:System.SR.Arg_InsufficientNumberOfElements">
            <summary>At least {0} element(s) are expected in the parameter "{1}".</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeNullTerminatedString">
            <summary>The string must be null-terminated.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Week_ISO">
            <summary>The week parameter must be in the range 1 through 53.</summary>
        </member>
        <member name="P:System.SR.Argument_BadPInvokeMethod">
            <summary>PInvoke methods must be static and native and cannot be abstract.</summary>
        </member>
        <member name="P:System.SR.Argument_BadPInvokeOnInterface">
            <summary>PInvoke methods cannot exist on interfaces.</summary>
        </member>
        <member name="P:System.SR.Argument_MethodRedefined">
            <summary>Method has been already defined.</summary>
        </member>
        <member name="P:System.SR.Argument_CannotExtractScalar">
            <summary>Cannot extract a Unicode scalar value from the specified index in the input.</summary>
        </member>
        <member name="P:System.SR.Argument_CannotParsePrecision">
            <summary>Characters following the format symbol must be a number of {0} or less.</summary>
        </member>
        <member name="P:System.SR.Argument_GWithPrecisionNotSupported">
            <summary>The 'G' format combined with a precision is not supported.</summary>
        </member>
        <member name="P:System.SR.Argument_PrecisionTooLarge">
            <summary>Precision cannot be larger than {0}.</summary>
        </member>
        <member name="P:System.SR.AssemblyDependencyResolver_FailedToLoadHostpolicy">
            <summary>Cannot load hostpolicy library. AssemblyDependencyResolver is currently only supported if the runtime is hosted through hostpolicy library.</summary>
        </member>
        <member name="P:System.SR.AssemblyDependencyResolver_FailedToResolveDependencies">
            <summary>Dependency resolution failed for component {0} with error code {1}. Detailed error: {2}</summary>
        </member>
        <member name="P:System.SR.Arg_EnumNotCloneable">
            <summary>The supplied object does not implement ICloneable.</summary>
        </member>
        <member name="P:System.SR.InvalidOp_InvalidNewEnumVariant">
            <summary>The returned enumerator does not implement IEnumVARIANT.</summary>
        </member>
        <member name="P:System.SR.Argument_StructArrayTooLarge">
            <summary>Array size exceeds addressing limitations.</summary>
        </member>
        <member name="P:System.SR.IndexOutOfRange_ArrayWithOffset">
            <summary>ArrayWithOffset: offset exceeds array size.</summary>
        </member>
        <member name="P:System.SR.Serialization_DangerousDeserialization">
            <summary>An action was attempted during deserialization that could lead to a security vulnerability. The action has been aborted.</summary>
        </member>
        <member name="P:System.SR.Serialization_DangerousDeserialization_Switch">
            <summary>An action was attempted during deserialization that could lead to a security vulnerability. The action has been aborted. To allow the action, set the '{0}' AppContext switch to true.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidStartupHookSimpleAssemblyName">
            <summary>The startup hook simple assembly name '{0}' is invalid. It must be a valid assembly name and it may not contain directory separator, space or comma characters and must not end with '.dll'.</summary>
        </member>
        <member name="P:System.SR.Argument_StartupHookAssemblyLoadFailed">
            <summary>Startup hook assembly '{0}' failed to load. See inner exception for details.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NonStaticComRegFunction">
            <summary>COM register function must be static.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_NonStaticComUnRegFunction">
            <summary>COM unregister function must be static.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_InvalidComRegFunctionSig">
            <summary>COM register function must have a System.Type parameter and a void return type.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_InvalidComUnRegFunctionSig">
            <summary>COM unregister function must have a System.Type parameter and a void return type.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_MultipleComRegFunctions">
            <summary>Type '{0}' has more than one COM registration function.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_MultipleComUnRegFunctions">
            <summary>Type '{0}' has more than one COM unregistration function.</summary>
        </member>
        <member name="T:System.Buffers.ArrayPool`1">
            <summary>
            Provides a resource pool that enables reusing instances of type <see cref="T:T[]"/>. 
            </summary>
            <remarks>
            <para>
            Renting and returning buffers with an <see cref="T:System.Buffers.ArrayPool`1"/> can increase performance
            in situations where arrays are created and destroyed frequently, resulting in significant
            memory pressure on the garbage collector.
            </para>
            <para>
            This class is thread-safe.  All members may be used by multiple threads concurrently.
            </para>
            </remarks>
        </member>
        <member name="P:System.Buffers.ArrayPool`1.Shared">
            <summary>
            Retrieves a shared <see cref="T:System.Buffers.ArrayPool`1"/> instance.
            </summary>
            <remarks>
            The shared pool provides a default implementation of <see cref="T:System.Buffers.ArrayPool`1"/>
            that's intended for general applicability.  It maintains arrays of multiple sizes, and 
            may hand back a larger array than was actually requested, but will never hand back a smaller 
            array than was requested. Renting a buffer from it with <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> will result in an 
            existing buffer being taken from the pool if an appropriate buffer is available or in a new 
            buffer being allocated if one is not available.
            byte[] and char[] are the most commonly pooled array types. For these we use a special pool type
            optimized for very fast access speeds, at the expense of more memory consumption.
            The shared pool instance is created lazily on first access.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Create">
            <summary>
            Creates a new <see cref="T:System.Buffers.ArrayPool`1"/> instance using default configuration options.
            </summary>
            <returns>A new <see cref="T:System.Buffers.ArrayPool`1"/> instance.</returns>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Create(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:System.Buffers.ArrayPool`1"/> instance using custom configuration options.
            </summary>
            <param name="maxArrayLength">The maximum length of array instances that may be stored in the pool.</param>
            <param name="maxArraysPerBucket">
            The maximum number of array instances that may be stored in each bucket in the pool.  The pool
            groups arrays of similar lengths into buckets for faster access.
            </param>
            <returns>A new <see cref="T:System.Buffers.ArrayPool`1"/> instance with the specified configuration options.</returns>
            <remarks>
            The created pool will group arrays into buckets, with no more than <paramref name="maxArraysPerBucket"/>
            in each bucket and with those arrays not exceeding <paramref name="maxArrayLength"/> in length.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Rent(System.Int32)">
            <summary>
            Retrieves a buffer that is at least the requested length.
            </summary>
            <param name="minimumLength">The minimum length of the array needed.</param>
            <returns>
            An <see cref="T:T[]"/> that is at least <paramref name="minimumLength"/> in length.
            </returns>
            <remarks>
            This buffer is loaned to the caller and should be returned to the same pool via 
            <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/> so that it may be reused in subsequent usage of <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/>.  
            It is not a fatal error to not return a rented buffer, but failure to do so may lead to 
            decreased application performance, as the pool may need to create a new buffer to replace
            the one lost.
            </remarks>
        </member>
        <member name="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)">
            <summary>
            Returns to the pool an array that was previously obtained via <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> on the same 
            <see cref="T:System.Buffers.ArrayPool`1"/> instance.
            </summary>
            <param name="array">
            The buffer previously obtained from <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> to return to the pool.
            </param>
            <param name="clearArray">
            If <c>true</c> and if the pool will store the buffer to enable subsequent reuse, <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/>
            will clear <paramref name="array"/> of its contents so that a subsequent consumer via <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> 
            will not see the previous consumer's content.  If <c>false</c> or if the pool will release the buffer,
            the array's contents are left unchanged.
            </param>
            <remarks>
            Once a buffer has been returned to the pool, the caller gives up all ownership of the buffer 
            and must not use it. The reference returned from a given call to <see cref="M:System.Buffers.ArrayPool`1.Rent(System.Int32)"/> must only be
            returned via <see cref="M:System.Buffers.ArrayPool`1.Return(`0[],System.Boolean)"/> once.  The default <see cref="T:System.Buffers.ArrayPool`1"/>
            may hold onto the returned buffer in order to rent it again, or it may release the returned buffer
            if it's determined that the pool already has enough buffers stored.
            </remarks>
        </member>
        <member name="T:System.Buffers.ArrayPoolEventSource.BufferAllocatedReason">
            <summary>The reason for a BufferAllocated event.</summary>
        </member>
        <member name="F:System.Buffers.ArrayPoolEventSource.BufferAllocatedReason.Pooled">
            <summary>The pool is allocating a buffer to be pooled in a bucket.</summary>
        </member>
        <member name="F:System.Buffers.ArrayPoolEventSource.BufferAllocatedReason.OverMaximumSize">
            <summary>The requested buffer size was too large to be pooled.</summary>
        </member>
        <member name="F:System.Buffers.ArrayPoolEventSource.BufferAllocatedReason.PoolExhausted">
            <summary>The pool has already allocated for pooling as many buffers of a particular size as it's allowed.</summary>
        </member>
        <member name="M:System.Buffers.ArrayPoolEventSource.BufferRented(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Event for when a buffer is rented.  This is invoked once for every successful call to Rent,
            regardless of whether a buffer is allocated or a buffer is taken from the pool.  In a
            perfect situation where all rented buffers are returned, we expect to see the number
            of BufferRented events exactly match the number of BuferReturned events, with the number
            of BufferAllocated events being less than or equal to those numbers (ideally significantly
            less than).
            </summary>
        </member>
        <member name="M:System.Buffers.ArrayPoolEventSource.BufferAllocated(System.Int32,System.Int32,System.Int32,System.Int32,System.Buffers.ArrayPoolEventSource.BufferAllocatedReason)">
            <summary>
            Event for when a buffer is allocated by the pool.  In an ideal situation, the number
            of BufferAllocated events is significantly smaller than the number of BufferRented and
            BufferReturned events.
            </summary>
        </member>
        <member name="M:System.Buffers.ArrayPoolEventSource.BufferReturned(System.Int32,System.Int32,System.Int32)">
            <summary>
            Event raised when a buffer is returned to the pool.  This event is raised regardless of whether
            the returned buffer is stored or dropped.  In an ideal situation, the number of BufferReturned
            events exactly matches the number of BufferRented events.
            </summary>
        </member>
        <member name="M:System.Buffers.ArrayPoolEventSource.BufferTrimmed(System.Int32,System.Int32,System.Int32)">
            <summary>
            Event raised when we attempt to free a buffer due to inactivity or memory pressure (by no longer
            referencing it). It is possible (although not commmon) this buffer could be rented as we attempt
            to free it. A rent event before or after this event for the same ID, is a rare, but expected case.
            </summary>
        </member>
        <member name="M:System.Buffers.ArrayPoolEventSource.BufferTrimPoll(System.Int32,System.Int32)">
            <summary>
            Event raised when we check to trim buffers.
            </summary>
        </member>
        <member name="F:System.Buffers.ConfigurableArrayPool`1.DefaultMaxArrayLength">
            <summary>The default maximum length of each array in the pool (2^20).</summary>
        </member>
        <member name="F:System.Buffers.ConfigurableArrayPool`1.DefaultMaxNumberOfArraysPerBucket">
            <summary>The default maximum number of arrays per bucket that are available for rent.</summary>
        </member>
        <member name="P:System.Buffers.ConfigurableArrayPool`1.Id">
            <summary>Gets an ID for the pool to use with events.</summary>
        </member>
        <member name="T:System.Buffers.ConfigurableArrayPool`1.Bucket">
            <summary>Provides a thread-safe bucket containing buffers that can be Rent'd and Return'd.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates the pool with numberOfBuffers arrays where each buffer is of bufferLength length.
            </summary>
        </member>
        <member name="P:System.Buffers.ConfigurableArrayPool`1.Bucket.Id">
            <summary>Gets an ID for the bucket to use with events.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.Rent">
            <summary>Takes an array from the bucket.  If the bucket is empty, returns null.</summary>
        </member>
        <member name="M:System.Buffers.ConfigurableArrayPool`1.Bucket.Return(`0[])">
            <summary>
            Attempts to return the buffer to the bucket.  If successful, the buffer will be stored
            in the bucket and true will be returned; otherwise, the buffer won't be stored, and false
            will be returned.
            </summary>
        </member>
        <member name="T:System.Buffers.IMemoryOwner`1">
            <summary>
            Owner of Memory<typeparamref name="T"/> that is responsible for disposing the underlying memory appropriately.
            </summary>
        </member>
        <member name="P:System.Buffers.IMemoryOwner`1.Memory">
            <summary>
            Returns a Memory<typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:System.Buffers.IPinnable">
            <summary>
            Provides a mechanism for pinning and unpinning objects to prevent the GC from moving them.
            </summary>
        </member>
        <member name="M:System.Buffers.IPinnable.Pin(System.Int32)">
            <summary>
            Call this method to indicate that the IPinnable object can not be moved by the garbage collector.
            The address of the pinned object can be taken.
            <param name="elementIndex">The offset to the element within the memory at which the returned <see cref="T:System.Buffers.MemoryHandle"/> points to.</param>
            </summary>
        </member>
        <member name="M:System.Buffers.IPinnable.Unpin">
            <summary>
            Call this method to indicate that the IPinnable object no longer needs to be pinned.
            The garbage collector is free to move the object now.
            </summary>
        </member>
        <member name="T:System.Buffers.MemoryHandle">
            <summary>
            A handle for the memory.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryHandle.#ctor(System.Void*,System.Runtime.InteropServices.GCHandle,System.Buffers.IPinnable)">
            <summary>
            Creates a new memory handle for the memory.
            </summary>
            <param name="pointer">pointer to memory</param>
            <param name="pinnable">reference to manually managed object, or default if there is no memory manager</param>
            <param name="handle">handle used to pin array buffers</param>
        </member>
        <member name="P:System.Buffers.MemoryHandle.Pointer">
            <summary>
            Returns the pointer to memory, where the memory is assumed to be pinned and hence the address won't change.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryHandle.Dispose">
            <summary>
            Frees the pinned handle and releases IPinnable.
            </summary>
        </member>
        <member name="T:System.Buffers.MemoryManager`1">
            <summary>
            Manager of <see cref="T:System.Memory`1"/> that provides the implementation.
            </summary>
        </member>
        <member name="P:System.Buffers.MemoryManager`1.Memory">
            <summary>
            Returns a <see cref="T:System.Memory`1"/>.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.GetSpan">
            <summary>
            Returns a span wrapping the underlying memory.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Pin(System.Int32)">
            <summary>
            Returns a handle to the memory that has been pinned and hence its address can be taken.
            </summary>
            <param name="elementIndex">The offset to the element within the memory at which the returned <see cref="T:System.Buffers.MemoryHandle"/> points to. (default = 0)</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Unpin">
            <summary>
            Lets the garbage collector know that the object is free to be moved now.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.CreateMemory(System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> for the current <see cref="T:System.Buffers.MemoryManager`1"/>.
            </summary>
            <param name="length">The element count in the memory, starting at offset 0.</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.CreateMemory(System.Int32,System.Int32)">
            <summary>
            Returns a <see cref="T:System.Memory`1"/> for the current <see cref="T:System.Buffers.MemoryManager`1"/>.
            </summary>
            <param name="start">The offset to the element which the returned memory starts at.</param>
            <param name="length">The element count in the memory, starting at element offset <paramref name="start"/>.</param>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.TryGetArray(System.ArraySegment{`0}@)">
            <summary>
            Returns an array segment.
            <remarks>Returns the default array segment if not overriden.</remarks>
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.System#IDisposable#Dispose">
            <summary>
            Implements IDisposable.
            </summary>
        </member>
        <member name="M:System.Buffers.MemoryManager`1.Dispose(System.Boolean)">
            <summary>
            Clean up of any leftover managed and unmanaged resources.
            </summary>
        </member>
        <member name="T:System.Buffers.OperationStatus">
            <summary>
            This enum defines the various potential status that can be returned from Span-based operations
            that support processing of input contained in multiple discontiguous buffers.
            </summary>
        </member>
        <member name="F:System.Buffers.OperationStatus.Done">
            <summary>
            The entire input buffer has been processed and the operation is complete.
            </summary>
        </member>
        <member name="F:System.Buffers.OperationStatus.DestinationTooSmall">
            <summary>
            The input is partially processed, up to what could fit into the destination buffer.
            The caller can enlarge the destination buffer, slice the buffers appropriately, and retry.
            </summary>
        </member>
        <member name="F:System.Buffers.OperationStatus.NeedMoreData">
            <summary>
            The input is partially processed, up to the last valid chunk of the input that could be consumed.
            The caller can stitch the remaining unprocessed input with more data, slice the buffers appropriately, and retry.
            </summary>
        </member>
        <member name="F:System.Buffers.OperationStatus.InvalidData">
            <summary>
            The input contained invalid bytes which could not be processed. If the input is partially processed,
            the destination contains the partial result. This guarantees that no additional data appended to the input
            will make the invalid sequence valid.
            </summary>
        </member>
        <member name="T:System.Buffers.StandardFormat">
            <summary>
            Represents a standard formatting string without using an actual String. A StandardFormat consists of a character (such as 'G', 'D' or 'X')
            and an optional precision ranging from 0..99, or the special value NoPrecision.
            </summary>
        </member>
        <member name="F:System.Buffers.StandardFormat.NoPrecision">
            <summary>
            Precision values for format that don't use a precision, or for when the precision is to be unspecified.
            </summary>
        </member>
        <member name="F:System.Buffers.StandardFormat.MaxPrecision">
            <summary>
            The maximum valid precision value.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.Symbol">
            <summary>
            The character component of the format.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.Precision">
            <summary>
            The precision component of the format. Ranges from 0..9 or the special value NoPrecision.
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.HasPrecision">
            <summary>
            true if Precision is a value other than NoPrecision
            </summary>
        </member>
        <member name="P:System.Buffers.StandardFormat.IsDefault">
            <summary>
            true if the StandardFormat == default(StandardFormat)
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.#ctor(System.Char,System.Byte)">
            <summary>
            Create a StandardFormat.
            </summary>
            <param name="symbol">A type-specific formatting character such as 'G', 'D' or 'X'</param>
            <param name="precision">An optional precision ranging from 0..9 or the special value NoPrecision (the default)</param>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Implicit(System.Char)~System.Buffers.StandardFormat">
            <summary>
            Converts a character to a StandardFormat using the NoPrecision precision.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts a <see cref="T:System.ReadOnlySpan`1"/> into a StandardFormat
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Parse(System.String)">
            <summary>
            Converts a classic .NET format string into a StandardFormat
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.TryParse(System.ReadOnlySpan{System.Char},System.Buffers.StandardFormat@)">
            <summary>
            Tries to convert a <see cref="T:System.ReadOnlySpan`1"/> into a StandardFormat. A return value indicates whether the conversion succeeded or failed.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Equals(System.Object)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.GetHashCode">
            <summary>
            Compute a hash code.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Equals(System.Buffers.StandardFormat)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.ToString">
            <summary>
            Returns the format in classic .NET format.
            </summary>
        </member>
        <member name="F:System.Buffers.StandardFormat.FormatStringLength">
            <summary>The exact buffer length required by <see cref="M:System.Buffers.StandardFormat.Format(System.Span{System.Char})"/>.</summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.Format(System.Span{System.Char})">
            <summary>
            Formats the format in classic .NET format.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Equality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
            <summary>
            Returns true if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="M:System.Buffers.StandardFormat.op_Inequality(System.Buffers.StandardFormat,System.Buffers.StandardFormat)">
            <summary>
            Returns false if both the Symbol and Precision are equal.
            </summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1">
            <summary>
            Provides an ArrayPool implementation meant to be used as the singleton returned from ArrayPool.Shared.
            </summary>
            <remarks>
            The implementation uses a tiered caching scheme, with a small per-thread cache for each array size, followed
            by a cache per array size shared by all threads, split into per-core stacks meant to be used by threads
            running on that core.  Locks are used to protect each per-core stack, because a thread can migrate after
            checking its processor number, because multiple threads could interleave on the same core, and because
            a thread is allowed to check other core's buckets if its core's bucket is empty/full.
            </remarks>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.NumBuckets">
            <summary>The number of buckets (array sizes) in the pool, one for each array length, starting from length 16.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.MaxPerCorePerArraySizeStacks">
            <summary>Maximum number of per-core stacks to use per array size.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.MaxBuffersPerArraySizePerCore">
            <summary>The maximum number of buffers to store in a bucket's global queue.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._bucketArraySizes">
            <summary>The length of arrays stored in the corresponding indices in <see cref="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._buckets"/> and <see cref="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.t_tlsBuckets"/>.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._buckets">
            <summary>
            An array of per-core array stacks. The slots are lazily initialized to avoid creating
            lots of overhead for unused array sizes.
            </summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.t_tlsBuckets">
            <summary>A per-thread array of arrays, to cache one array per array size per thread.</summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.s_allTlsBuckets">
            <summary>
            Used to keep track of all thread local buckets for trimming if needed
            </summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.#ctor">
            <summary>Initialize the pool.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.CreatePerCoreLockedStacks(System.Int32)">
            <summary>Allocate a new PerCoreLockedStacks and try to store it into the <see cref="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1._buckets"/> array.</summary>
        </member>
        <member name="P:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.Id">
            <summary>Gets an ID for the pool to use with events.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.Gen2GcCallbackFunc(System.Object)">
            <summary>
            This is the static function that is called from the gen2 GC callback.
            The input object is the instance we want the callback on.
            </summary>
            <remarks>
            The reason that we make this function static and take the instance as a parameter is that
            we would otherwise root the instance to the Gen2GcCallback object, leaking the instance even when
            the application no longer needs it.
            </remarks>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks">
            <summary>
            Stores a set of stacks of arrays, with one stack per core.
            </summary>
        </member>
        <member name="F:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks._perCoreStacks">
            <summary>The stacks.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.#ctor">
            <summary>Initializes the stacks.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.TryPush(`0[])">
            <summary>Try to push the array into the stacks. If each is full when it's tested, the array will be dropped.</summary>
        </member>
        <member name="M:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.PerCoreLockedStacks.TryPop">
            <summary>Try to get an array from the stacks.  If each is empty when it's tested, null will be returned.</summary>
        </member>
        <member name="T:System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1.LockedStack">
            <summary>Provides a simple stack of arrays, protected by a lock.</summary>
        </member>
        <member name="T:System.Buffers.Binary.BinaryPrimitives">
            <summary>
            Reads bytes as primitives with specific endianness
            </summary>
            <remarks>
            For native formats, MemoryExtensions.Read{T}; should be used.
            Use these helpers when you need to read specific endinanness.
            </remarks>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)">
            <summary>
            This is a no-op and added only for consistency.
            This allows the caller to read a struct of numeric primitives and reverse each field
            rather than having to skip sbyte fields.
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)">
            <summary>
            Reverses a primitive value - performs an endianness swap
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)">
            <summary>
            Reverses a primitive value - performs an endianness swap
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)">
            <summary>
            Reverses a primitive value - performs an endianness swap
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)">
            <summary>
            This is a no-op and added only for consistency.
            This allows the caller to read a struct of numeric primitives and reverse each field
            rather than having to skip byte fields.
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)">
            <summary>
            Reverses a primitive value - performs an endianness swap
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)">
            <summary>
            Reverses a primitive value - performs an endianness swap
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)">
            <summary>
            Reverses a primitive value - performs an endianness swap
            </summary> 
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads an Int16 out of a read-only span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads an Int32 out of a read-only span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads an Int64 out of a read-only span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a UInt16 out of a read-only span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a UInt32 out of a read-only span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a UInt64 out of a read-only span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
            <summary>
            Reads an Int16 out of a read-only span of bytes as big endian.
            <returns>If the span is too small to contain an Int16, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Reads an Int32 out of a read-only span of bytes as big endian.
            <returns>If the span is too small to contain an Int32, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
            <summary>
            Reads an Int64 out of a read-only span of bytes as big endian.
            <returns>If the span is too small to contain an Int64, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
            <summary>
            Reads a UInt16 out of a read-only span of bytes as big endian.
            <returns>If the span is too small to contain a UInt16, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
            <summary>
            Reads a UInt32 out of a read-only span of bytes as big endian.
            <returns>If the span is too small to contain a UInt32, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
            <summary>
            Reads a UInt64 out of a read-only span of bytes as big endian.
            <returns>If the span is too small to contain a UInt64, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads an Int16 out of a read-only span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads an Int32 out of a read-only span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads an Int64 out of a read-only span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a UInt16 out of a read-only span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a UInt32 out of a read-only span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a UInt64 out of a read-only span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)">
            <summary>
            Reads an Int16 out of a read-only span of bytes as little endian.
            <returns>If the span is too small to contain an Int16, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Reads an Int32 out of a read-only span of bytes as little endian.
            <returns>If the span is too small to contain an Int32, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)">
            <summary>
            Reads an Int64 out of a read-only span of bytes as little endian.
            <returns>If the span is too small to contain an Int64, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)">
            <summary>
            Reads a UInt16 out of a read-only span of bytes as little endian.
            <returns>If the span is too small to contain a UInt16, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)">
            <summary>
            Reads a UInt32 out of a read-only span of bytes as little endian.
            <returns>If the span is too small to contain a UInt32, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)">
            <summary>
            Reads a UInt64 out of a read-only span of bytes as little endian.
            <returns>If the span is too small to contain a UInt64, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
            <summary>
            Writes an Int16 into a span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
            <summary>
            Writes an Int32 into a span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
            <summary>
            Writes an Int64 into a span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
            <summary>
            Write a UInt16 into a span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
            <summary>
            Write a UInt32 into a span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
            <summary>
            Write a UInt64 into a span of bytes as big endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)">
            <summary>
            Writes an Int16 into a span of bytes as big endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)">
            <summary>
            Writes an Int32 into a span of bytes as big endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)">
            <summary>
            Writes an Int64 into a span of bytes as big endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)">
            <summary>
            Write a UInt16 into a span of bytes as big endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)">
            <summary>
            Write a UInt32 into a span of bytes as big endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)">
            <summary>
            Write a UInt64 into a span of bytes as big endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
            <summary>
            Writes an Int16 into a span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
            <summary>
            Writes an Int32 into a span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
            <summary>
            Writes an Int64 into a span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
            <summary>
            Write a UInt16 into a span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
            <summary>
            Write a UInt32 into a span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
            <summary>
            Write a UInt64 into a span of bytes as little endian.
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)">
            <summary>
            Writes an Int16 into a span of bytes as little endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)">
            <summary>
            Writes an Int32 into a span of bytes as little endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)">
            <summary>
            Writes an Int64 into a span of bytes as little endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)">
            <summary>
            Write a UInt16 into a span of bytes as little endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)">
            <summary>
            Write a UInt32 into a span of bytes as little endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)">
            <summary>
            Write a UInt64 into a span of bytes as little endian.
            <returns>If the span is too small to contain the value, return false.</returns>
            </summary>
        </member>
        <member name="M:System.Buffers.Text.FormattingHelpers.GetSymbolOrDefault(System.Buffers.StandardFormat@,System.Char)">
            <summary>
            Returns the symbol contained within the standard format. If the standard format
            has not been initialized, returns the provided fallback symbol.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.FormattingHelpers.FillWithAsciiZeros(System.Span{System.Byte})">
            <summary>
            Fills a buffer with the ASCII character '0' (0x30).
            </summary>
        </member>
        <member name="M:System.Buffers.Text.FormattingHelpers.WriteFourDecimalDigits(System.UInt32,System.Span{System.Byte},System.Int32)">
            <summary>
            Writes a value [ 0000 .. 9999 ] to the buffer starting at the specified offset.
            This method performs best when the starting index is a constant literal.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.FormattingHelpers.WriteTwoDecimalDigits(System.UInt32,System.Span{System.Byte},System.Int32)">
            <summary>
            Writes a value [ 00 .. 99 ] to the buffer starting at the specified offset.
            This method performs best when the starting index is a constant literal.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.FormattingHelpers.DivMod(System.UInt64,System.UInt64,System.UInt64@)">
            <summary>
            We don't have access to Math.DivRem, so this is a copy of the implementation.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.FormattingHelpers.DivMod(System.UInt32,System.UInt32,System.UInt32@)">
            <summary>
            We don't have access to Math.DivRem, so this is a copy of the implementation.
            </summary>
        </member>
        <member name="T:System.Buffers.Text.Utf8Formatter">
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
            <summary>
            Methods to format common data types as Utf8 strings.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Boolean,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a Boolean as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G (default)   True/False
                l             true/false
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTimeOffset,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a DateTimeOffset as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <exceptions>
            <remarks>
            Formats supported:
                default       05/25/2017 10:30:15 -08:00
                G             05/25/2017 10:30:15
                R             Tue, 03 Jan 2017 08:08:05 GMT       (RFC 1123)
                l             tue, 03 jan 2017 08:08:05 gmt       (Lowercase RFC 1123)
                O             2017-06-12T05:30:45.7680000-07:00   (Round-trippable)
            </remarks>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.DateTime,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a DateTime as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G  (default)  05/25/2017 10:30:15
                R             Tue, 03 Jan 2017 08:08:05 GMT       (RFC 1123)
                l             tue, 03 jan 2017 08:08:05 gmt       (Lowercase RFC 1123)
                O             2017-06-12T05:30:45.7680000-07:00   (Round-trippable)
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Decimal,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a Decimal as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g  (default)  
                F/f             12.45       Fixed point
                E/e             1.245000e1  Exponential
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Double,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a Double as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g  (default)  
                F/f             12.45       Fixed point
                E/e             1.245000e1  Exponential
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Single,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a Single as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g  (default)  
                F/f             12.45       Fixed point
                E/e             1.245000e1  Exponential
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Guid,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a Guid as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                D (default)     nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn
                B               {nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}
                P               (nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn)
                N               nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="T:System.Buffers.Text.Utf8Formatter.DecomposedGuid">
            <summary>
            Used to provide access to the individual bytes of a GUID.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Byte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a Byte as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.SByte,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats an SByte as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a Unt16 as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int16,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats an Int16 as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a UInt32 as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int32,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats an Int32 as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.UInt64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a UInt64 as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.Int64,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats an Int64 as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Formatter.TryFormat(System.TimeSpan,System.Span{System.Byte},System.Int32@,System.Buffers.StandardFormat)">
            <summary>
            Formats a TimeSpan as a UTF8 string.
            </summary>
            <param name="value">Value to format</param>
            <param name="destination">Buffer to write the UTF8-formatted value to</param>
            <param name="bytesWritten">Receives the length of the formatted text in bytes</param>
            <param name="format">The standard format to use</param>
            <returns>
            true for success. "bytesWritten" contains the length of the formatted text in bytes.
            false if buffer was too short. Iteratively increase the size of the buffer and retry until it succeeds. 
            </returns>
            <remarks>
            Formats supported:
                c/t/T (default) [-][d.]hh:mm:ss[.fffffff]              (constant format)
                G               [-]d:hh:mm:ss.fffffff                  (general long)
                g               [-][d:][h]h:mm:ss[.f[f[f[f[f[f[f]]]]]] (general short)
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="T:System.Buffers.Text.Utf8Parser">
            <summary>
            Methods to parse common data types to Utf8 strings.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Boolean@,System.Int32@,System.Char)">
            <summary>
            Parses a Boolean at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G (default)   True/False
                l             true/false
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTime@,System.Int32@,System.Char)">
            <summary>
            Parses a DateTime at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                default       05/25/2017 10:30:15 -08:00
                G             05/25/2017 10:30:15
                R             Tue, 03 Jan 2017 08:08:05 GMT       (RFC 1123)
                l             tue, 03 jan 2017 08:08:05 gmt       (Lowercase RFC 1123)
                O             2017-06-12T05:30:45.7680000-07:00   (Round-trippable)
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.DateTimeOffset@,System.Int32@,System.Char)">
            <summary>
            Parses a DateTimeOffset at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G  (default)  05/25/2017 10:30:15
                R             Tue, 03 Jan 2017 08:08:05 GMT       (RFC 1123)
                l             tue, 03 jan 2017 08:08:05 gmt       (Lowercase RFC 1123)
                O             2017-06-12T05:30:45.7680000-07:00   (Round-trippable)
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryCreateDateTimeOffset(System.DateTime,System.Boolean,System.Int32,System.Int32,System.DateTimeOffset@)">
            <summary>
            Overflow-safe DateTimeOffset factory.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryCreateDateTimeOffset(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Int32,System.DateTimeOffset@)">
            <summary>
            Overflow-safe DateTimeOffset factory.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryCreateDateTimeOffsetInterpretingDataAsLocalTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeOffset@)">
            <summary>
            Overflow-safe DateTimeOffset/Local time conversion factory.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryCreateDateTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.DateTimeKind,System.DateTime@)">
            <summary>
            Overflow-safe DateTime factory.
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Decimal@,System.Int32@,System.Char)">
            <summary>
            Parses a Decimal at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g  (default)  
                F/f             12.45       Fixed point
                E/e             1.245000e1  Exponential
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Single@,System.Int32@,System.Char)">
            <summary>
            Parses a Single at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g  (default)  
                F/f             12.45       Fixed point
                E/e             1.245000e1  Exponential
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Double@,System.Int32@,System.Char)">
            <summary>
            Parses a Double at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g  (default)  
                F/f             12.45       Fixed point
                E/e             1.245000e1  Exponential
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Guid@,System.Int32@,System.Char)">
            <summary>
            Parses a Guid at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                D (default)     nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn
                B               {nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}
                P               (nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn)
                N               nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.SByte@,System.Int32@,System.Char)">
            <summary>
            Parses a SByte at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int16@,System.Int32@,System.Char)">
            <summary>
            Parses an Int16 at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int32@,System.Int32@,System.Char)">
            <summary>
            Parses an Int32 at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@,System.Int32@,System.Char)">
            <summary>
            Parses an Int64 at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@,System.Int32@,System.Char)">
            <summary>
            Parses a Byte at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt16@,System.Int32@,System.Char)">
            <summary>
            Parses a UInt16 at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@,System.Char)">
            <summary>
            Parses a UInt32 at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.UInt64@,System.Int32@,System.Char)">
            <summary>
            Parses a UInt64 at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                G/g (default)
                D/d             32767  
                N/n             32,767       
                X/x             7fff
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParse(System.ReadOnlySpan{System.Byte},System.TimeSpan@,System.Int32@,System.Char)">
            <summary>
            Parses a TimeSpan at the start of a Utf8 string.
            </summary>
            <param name="source">The Utf8 string to parse</param>
            <param name="value">Receives the parsed value</param>
            <param name="bytesConsumed">On a successful parse, receives the length in bytes of the substring that was parsed </param>
            <param name="standardFormat">Expected format of the Utf8 string</param>
            <returns>
            true for success. "bytesConsumed" contains the length in bytes of the substring that was parsed.
            false if the string was not syntactically valid or an overflow or underflow occurred. "bytesConsumed" is set to 0. 
            </returns>
            <remarks>
            Formats supported:
                c/t/T (default) [-][d.]hh:mm:ss[.fffffff]             (constant format)
                G               [-]d:hh:mm:ss.fffffff                 (general long)
                g               [-][d:]h:mm:ss[.f[f[f[f[f[f[f[]]]]]]] (general short)
            </remarks>
            <exceptions>
            <cref>System.FormatException</cref> if the format is not valid for this data type.
            </exceptions>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryParseTimeSpanFraction(System.ReadOnlySpan{System.Byte},System.UInt32@,System.Int32@)">
            <summary>
            Parse the fraction portion of a TimeSpan. Must be 1..7 digits. If fewer than 7, zeroes are implied to the right. If more than 7, the TimeSpan
            parser rejects the string (even if the extra digits are all zeroes.)
            </summary>
        </member>
        <member name="M:System.Buffers.Text.Utf8Parser.TryCreateTimeSpan(System.Boolean,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.TimeSpan@)">
            <summary>
            Overflow-safe TryCreateTimeSpan
            </summary>
        </member>
        <member name="T:System.Activator">
            <summary>
            Activator contains the Activation (CreateInstance/New) methods for late bound support.
            </summary>
        </member>
        <member name="T:System.AggregateException">
            <summary>Represents one or more errors that occur during application execution.</summary>
            <remarks>
            <see cref="T:System.AggregateException"/> is used to consolidate multiple failures into a single, throwable
            exception object.
            </remarks>
        </member>
        <member name="M:System.AggregateException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class.
            </summary>
        </member>
        <member name="M:System.AggregateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with
            a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.AggregateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with a specified error
            message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerException"/> argument
            is null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with
            references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.Exception[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with
            references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with a specified error
            message and references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.String,System.Exception[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with a specified error
            message and references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.String,System.Collections.Generic.IList{System.Exception})">
            <summary>
            Allocates a new aggregate exception with the specified message and list of inner exceptions.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.Collections.Generic.IEnumerable{System.Runtime.ExceptionServices.ExceptionDispatchInfo})">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with
            references to the inner exception dispatch info objects that represent the cause of this exception.
            </summary>
            <param name="innerExceptionInfos">
            Information about the exceptions that are the cause of the current exception.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptionInfos"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptionInfos"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Runtime.ExceptionServices.ExceptionDispatchInfo})">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with a specified error
            message and references to the inner exception dispatch info objects that represent the cause of 
            this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptionInfos">
            Information about the exceptions that are the cause of the current exception.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptionInfos"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptionInfos"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.String,System.Collections.Generic.IList{System.Runtime.ExceptionServices.ExceptionDispatchInfo})">
            <summary>
            Allocates a new aggregate exception with the specified message and list of inner 
            exception dispatch info objects.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptionInfos">
            Information about the exceptions that are the cause of the current exception.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptionInfos"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptionInfos"/> is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:System.AggregateException"/> class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> argument is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The exception could not be deserialized correctly.</exception>
        </member>
        <member name="M:System.AggregateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about
            the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds
            the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that
            contains contextual information about the source or destination. </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info"/> argument is null.</exception>
        </member>
        <member name="M:System.AggregateException.GetBaseException">
            <summary>
            Returns the <see cref="T:System.AggregateException"/> that is the root cause of this exception.
            </summary>
        </member>
        <member name="P:System.AggregateException.InnerExceptions">
            <summary>
            Gets a read-only collection of the <see cref="T:System.Exception"/> instances that caused the
            current exception.
            </summary>
        </member>
        <member name="M:System.AggregateException.Handle(System.Func{System.Exception,System.Boolean})">
            <summary>
            Invokes a handler on each <see cref="T:System.Exception"/> contained by this <see
            cref="T:System.AggregateException"/>.
            </summary>
            <param name="predicate">The predicate to execute for each exception. The predicate accepts as an
            argument the <see cref="T:System.Exception"/> to be processed and returns a Boolean to indicate
            whether the exception was handled.</param>
            <remarks>
            Each invocation of the <paramref name="predicate"/> returns true or false to indicate whether the
            <see cref="T:System.Exception"/> was handled. After all invocations, if any exceptions went
            unhandled, all unhandled exceptions will be put into a new <see cref="T:System.AggregateException"/>
            which will be thrown. Otherwise, the <see cref="M:System.AggregateException.Handle(System.Func{System.Exception,System.Boolean})"/> method simply returns. If any
            invocations of the <paramref name="predicate"/> throws an exception, it will halt the processing
            of any more exceptions and immediately propagate the thrown exception as-is.
            </remarks>
            <exception cref="T:System.AggregateException">An exception contained by this <see
            cref="T:System.AggregateException"/> was not handled.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="predicate"/> argument is
            null.</exception>
        </member>
        <member name="M:System.AggregateException.Flatten">
            <summary>
            Flattens the inner instances of <see cref="T:System.AggregateException"/> by expanding its contained <see cref="T:System.Exception"/> instances
            into a new <see cref="T:System.AggregateException"/>
            </summary>
            <returns>A new, flattened <see cref="T:System.AggregateException"/>.</returns>
            <remarks>
            If any inner exceptions are themselves instances of
            <see cref="T:System.AggregateException"/>, this method will recursively flatten all of them. The
            inner exceptions returned in the new <see cref="T:System.AggregateException"/>
            will be the union of all of the inner exceptions from exception tree rooted at the provided
            <see cref="T:System.AggregateException"/> instance.
            </remarks>
        </member>
        <member name="P:System.AggregateException.Message">
            <summary>Gets a message that describes the exception.</summary>
        </member>
        <member name="M:System.AggregateException.ToString">
            <summary>
            Creates and returns a string representation of the current <see cref="T:System.AggregateException"/>.
            </summary>
            <returns>A string representation of the current exception.</returns>
        </member>
        <member name="P:System.AggregateException.InnerExceptionCount">
            <summary>
            This helper property is used by the DebuggerDisplay.
            
            Note that we don't want to remove this property and change the debugger display to {InnerExceptions.Count} 
            because DebuggerDisplay should be a single property access or parameterless method call, so that the debugger 
            can use a fast path without using the expression evaluator.
            
            See https://docs.microsoft.com/en-us/visualstudio/debugger/using-the-debuggerdisplay-attribute
            </summary>
        </member>
        <member name="T:System.ComponentModel.DefaultValueAttribute">
            <summary>
            Specifies the default value for a property.
            </summary>
        </member>
        <member name="F:System.ComponentModel.DefaultValueAttribute._value">
            <summary>
            This is the default value.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class, converting the specified value to the specified type, and using the U.S. English
            culture as the translation context.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Char)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a Unicode character.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Byte)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using an 8-bit unsigned integer.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Int16)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a 16-bit signed integer.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a 32-bit signed integer.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a 64-bit signed integer.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a single-precision floating point number.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a double-precision floating point number.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a <see cref='T:System.Boolean'/> value.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a <see cref='T:System.String'/>.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.SByte)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a <see cref='T:System.SByte'/> value.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.UInt16)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a <see cref='T:System.UInt16'/> value.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a <see cref='T:System.UInt32'/> value.
            </summary>
        </member>
        <member name="M:System.ComponentModel.DefaultValueAttribute.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref='T:System.ComponentModel.DefaultValueAttribute'/>
            class using a <see cref='T:System.UInt64'/> value.
            </summary>
        </member>
        <member name="P:System.ComponentModel.DefaultValueAttribute.Value">
            <summary>
            Gets the default value of the property this attribute is bound to.
            </summary>
        </member>
        <member name="M:System.Convert.FromBase64String(System.String)">
            <summary>
            Converts the specified string, which encodes binary data as Base64 digits, to the equivalent byte array.
            </summary>
            <param name="s">The string to convert</param>
            <returns>The array of bytes represented by the specified Base64 string.</returns>
        </member>
        <member name="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)">
            <summary>
            Converts the specified range of a Char array, which encodes binary data as Base64 digits, to the equivalent byte array.     
            </summary>
            <param name="inArray">Chars representing Base64 encoding characters</param>
            <param name="offset">A position within the input array.</param>
            <param name="length">Number of element to convert.</param>
            <returns>The array of bytes represented by the specified Base64 encoding characters.</returns>
        </member>
        <member name="M:System.Convert.FromBase64CharPtr(System.Char*,System.Int32)">
            <summary>
            Convert Base64 encoding characters to bytes:
             - Compute result length exactly by actually walking the input;
             - Allocate new result array based on computation;
             - Decode input into the new array;
            </summary>
            <param name="inputPtr">Pointer to the first input char</param>
            <param name="inputLength">Number of input chars</param>
            <returns></returns>
        </member>
        <member name="M:System.Convert.FromBase64_ComputeResultLength(System.Char*,System.Int32)">
            <summary>
            Compute the number of bytes encoded in the specified Base 64 char array:
            Walk the entire input counting white spaces and padding chars, then compute result length
            based on 3 bytes per 4 chars.
            </summary>
        </member>
        <member name="M:System.Convert.TryDecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Int32@,System.Int32@)">
             <summary>
             Decode the span of UTF-16 encoded text represented as base 64 into binary data.
             If the input is not a multiple of 4, or contains illegal characters, it will decode as much as it can, to the largest possible multiple of 4.
             This invariant allows continuation of the parse with a slower, whitespace-tolerant algorithm.
            
             <param name="utf16">The input span which contains UTF-16 encoded text in base 64 that needs to be decoded.</param>
             <param name="bytes">The output span which contains the result of the operation, i.e. the decoded binary data.</param>
             <param name="consumed">The number of input bytes consumed during the operation. This can be used to slice the input for subsequent calls, if necessary.</param>
             <param name="written">The number of bytes written into the output span. This can be used to slice the output for subsequent calls, if necessary.</param>
             </summary> 
             <returns>Returns:
             - true  - The entire input span was successfully parsed.
             - false - Only a part of the input span was successfully parsed. Failure causes may include embedded or trailing whitespace, 
                       other illegal Base64 characters, trailing characters after an encoding pad ('='), an input span whose length is not divisible by 4
                       or a destination span that's too small. <paramref name="consumed"/> and <paramref name="written"/> are set so that 
                       parsing can continue with a slower whitespace-tolerant algorithm.
                       
             Note: This is a cut down version of the implementation of Base64.DecodeFromUtf8(), modified the accept UTF16 chars and act as a fast-path
             helper for the Convert routines when the input string contains no whitespace.
             </returns>
        </member>
        <member name="M:System.Double.IsFinite(System.Double)">
            <summary>Determines whether the specified value is finite (zero, subnormal, or normal).</summary>
        </member>
        <member name="M:System.Double.IsInfinity(System.Double)">
            <summary>Determines whether the specified value is infinite.</summary>
        </member>
        <member name="M:System.Double.IsNaN(System.Double)">
            <summary>Determines whether the specified value is NaN.</summary>
        </member>
        <member name="M:System.Double.IsNegative(System.Double)">
            <summary>Determines whether the specified value is negative.</summary>
        </member>
        <member name="M:System.Double.IsNegativeInfinity(System.Double)">
            <summary>Determines whether the specified value is negative infinity.</summary>
        </member>
        <member name="M:System.Double.IsNormal(System.Double)">
            <summary>Determines whether the specified value is normal.</summary>
        </member>
        <member name="M:System.Double.IsPositiveInfinity(System.Double)">
            <summary>Determines whether the specified value is positive infinity.</summary>
        </member>
        <member name="M:System.Double.IsSubnormal(System.Double)">
            <summary>Determines whether the specified value is subnormal.</summary>
        </member>
        <member name="T:System.FormattableString">
            <summary>
            A composite format string along with the arguments to be formatted. An instance of this
            type may result from the use of the C# or VB language primitive "interpolated string".
            </summary>
        </member>
        <member name="P:System.FormattableString.Format">
            <summary>
            The composite format string.
            </summary>
        </member>
        <member name="M:System.FormattableString.GetArguments">
            <summary>
            Returns an object array that contains zero or more objects to format. Clients should not
            mutate the contents of the array.
            </summary>
        </member>
        <member name="P:System.FormattableString.ArgumentCount">
            <summary>
            The number of arguments to be formatted.
            </summary>
        </member>
        <member name="M:System.FormattableString.GetArgument(System.Int32)">
            <summary>
            Returns one argument to be formatted from argument position <paramref name="index"/>.
            </summary>
        </member>
        <member name="M:System.FormattableString.ToString(System.IFormatProvider)">
            <summary>
            Format to a string using the given culture.
            </summary>
        </member>
        <member name="M:System.FormattableString.Invariant(System.FormattableString)">
            <summary>
            Format the given object in the invariant culture. This static method may be
            imported in C# by
            <code>
            using static System.FormattableString;
            </code>.
            Within the scope
            of that import directive an interpolated string may be formatted in the
            invariant culture by writing, for example,
            <code>
            Invariant($"{{ lat = {latitude}; lon = {longitude} }}")
            </code>
            </summary>
        </member>
        <member name="M:System.FormattableString.CurrentCulture(System.FormattableString)">
            <summary>
            Format the given object in the current culture. This static method may be
            imported in C# by
            <code>
            using static System.FormattableString;
            </code>.
            Within the scope
            of that import directive an interpolated string may be formatted in the
            current culture by writing, for example,
            <code>
            CurrentCulture($"{{ lat = {latitude}; lon = {longitude} }}")
            </code>
            </summary>
        </member>
        <member name="P:System.GCMemoryInfo.HighMemoryLoadThresholdBytes">
            <summary>
            High memory load threshold when the last GC occured
            </summary>
        </member>
        <member name="P:System.GCMemoryInfo.MemoryLoadBytes">
            <summary>
            Memory load when the last GC ocurred
            </summary>
        </member>
        <member name="P:System.GCMemoryInfo.TotalAvailableMemoryBytes">
             <summary>
             Total available memory for the GC to use when the last GC ocurred.
            
             If the environment variable COMPlus_GCHeapHardLimit is set,
             or "Server.GC.HeapHardLimit" is in runtimeconfig.json, this will come from that.
             If the program is run in a container, this will be an implementation-defined fraction of the container's size.
             Else, this is the physical memory on the machine that was available for the GC to use when the last GC occurred.
             </summary>
        </member>
        <member name="P:System.GCMemoryInfo.HeapSizeBytes">
            <summary>
            The total heap size when the last GC ocurred
            </summary>
        </member>
        <member name="P:System.GCMemoryInfo.FragmentedBytes">
             <summary>
             The total fragmentation when the last GC ocurred
            
             Let's take the example below:
              | OBJ_A |     OBJ_B     | OBJ_C |   OBJ_D   | OBJ_E |
            
             Let's say OBJ_B, OBJ_C and and OBJ_E are garbage and get collected, but the heap does not get compacted, the resulting heap will look like the following:
              | OBJ_A |           F           |   OBJ_D   |
            
             The memory between OBJ_A and OBJ_D marked `F` is considered part of the FragmentedBytes, and will be used to allocate new objects. The memory after OBJ_D will not be
             considered part of the FragmentedBytes, and will also be used to allocate new objects
             </summary>
        </member>
        <member name="T:System.Gen2GcCallback">
            <summary>
            Schedules a callback roughly every gen 2 GC (you may see a Gen 0 an Gen 1 but only once)
            (We can fix this by capturing the Gen 2 count at startup and testing, but I mostly don't care)
            </summary>
        </member>
        <member name="M:System.Gen2GcCallback.Register(System.Func{System.Boolean})">
            <summary>
            Schedule 'callback' to be called in the next GC.  If the callback returns true it is
            rescheduled for the next Gen 2 GC.  Otherwise the callbacks stop.
            </summary>
        </member>
        <member name="M:System.Gen2GcCallback.Register(System.Func{System.Object,System.Boolean},System.Object)">
            <summary>
            Schedule 'callback' to be called in the next GC.  If the callback returns true it is 
            rescheduled for the next Gen 2 GC.  Otherwise the callbacks stop. 
            
            NOTE: This callback will be kept alive until either the callback function returns false,
            or the target object dies.
            </summary>
        </member>
        <member name="M:System.DateTimeFormat.WriteTwoDecimalDigits(System.UInt32,System.Span{System.Char},System.Int32)">
            <summary>
            Writes a value [ 00 .. 99 ] to the buffer starting at the specified offset.
            This method performs best when the starting index is a constant literal.
            </summary>
        </member>
        <member name="M:System.DateTimeFormat.WriteFourDecimalDigits(System.UInt32,System.Span{System.Char},System.Int32)">
            <summary>
            Writes a value [ 0000 .. 9999 ] to the buffer starting at the specified offset.
            This method performs best when the starting index is a constant literal.
            </summary>
        </member>
        <member name="T:System.IAsyncDisposable">
            <summary>Provides a mechanism for releasing unmanaged resources asynchronously.</summary>
        </member>
        <member name="M:System.IAsyncDisposable.DisposeAsync">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or
            resetting unmanaged resources asynchronously.
            </summary>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.InsufficientMemoryException">
            <summary>
            Purpose: The exception class for running out of memory
            but most likely in a non-fatal way that shouldn't 
            be affected by escalation policy.  Use this for cases
            like MemoryFailPoint or a TryAllocate method, where you 
            expect OOM's with no shared state corruption and you
            want to recover from these errors.
            </summary>
        </member>
        <member name="T:System.IProgress`1">
            <summary>Defines a provider for progress updates.</summary>
            <typeparam name="T">The type of progress update value.</typeparam>
        </member>
        <member name="M:System.IProgress`1.Report(`0)">
            <summary>Reports a progress update.</summary>
            <param name="value">The value of the updated progress.</param>
        </member>
        <member name="T:System.LazyHelper">
            <summary>
            LazyHelper serves multiples purposes
            - minimizing code size of Lazy&lt;T&gt; by implementing as much of the code that is not generic
              this reduces generic code bloat, making faster class initialization
            - contains singleton objects that are used to handle threading primitives for PublicationOnly mode
            - allows for instantiation for ExecutionAndPublication so as to create an object for locking on
            - holds exception information.
            </summary>
        </member>
        <member name="M:System.LazyHelper.#ctor(System.LazyState)">
            <summary>
            Constructor that defines the state
            </summary>
        </member>
        <member name="M:System.LazyHelper.#ctor(System.Threading.LazyThreadSafetyMode,System.Exception)">
            <summary>
            Constructor used for exceptions
            </summary>
        </member>
        <member name="T:System.Lazy`1">
            <summary>
            Provides support for lazy initialization.
            </summary>
            <typeparam name="T">Specifies the type of element being lazily initialized.</typeparam>
            <remarks>
            <para>
            By default, all public and protected members of <see cref="T:System.Lazy`1"/> are thread-safe and may be used
            concurrently from multiple threads.  These thread-safety guarantees may be removed optionally and per instance
            using parameters to the type's constructors.
            </para>
            </remarks>
        </member>
        <member name="M:System.Lazy`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}"/> class that 
            uses <typeparamref name="T"/>'s default constructor for lazy initialization.
            </summary>
            <remarks>
            An instance created with this constructor may be used concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Lazy`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}"/> class that
            uses a pre-initialized specified value.
            </summary>
            <remarks>
            An instance created with this constructor should be usable by multiple threads
            concurrently.
            </remarks>
        </member>
        <member name="M:System.Lazy`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}"/> class that uses a
            specified initialization function.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}"/> invoked to produce the lazily-initialized value when it is
            needed.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is a null
            reference (Nothing in Visual Basic).</exception>
            <remarks>
            An instance created with this constructor may be used concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Lazy`1.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}"/>
            class that uses <typeparamref name="T"/>'s default constructor and a specified thread-safety mode.
            </summary>
            <param name="isThreadSafe">true if this instance should be usable by multiple threads concurrently; false if the instance will only be used by one thread at a time.
            </param>
        </member>
        <member name="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}"/>
            class that uses <typeparamref name="T"/>'s default constructor and a specified thread-safety mode.
            </summary>
            <param name="mode">The lazy thread-safety mode</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode"/> mode contains an invalid valuee</exception>
        </member>
        <member name="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}"/> class
            that uses a specified initialization function and a specified thread-safety mode.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}"/> invoked to produce the lazily-initialized value when it is needed.
            </param>
            <param name="isThreadSafe">true if this instance should be usable by multiple threads concurrently; false if the instance will only be used by one thread at a time.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is
            a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Threading.Lazy{T}"/> class
            that uses a specified initialization function and a specified thread-safety mode.
            </summary>
            <param name="valueFactory">
            The <see cref="T:System.Func{T}"/> invoked to produce the lazily-initialized value when it is needed.
            </param>
            <param name="mode">The lazy thread-safety mode.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is
            a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode"/> mode contains an invalid value.</exception>
        </member>
        <member name="M:System.Lazy`1.ToString">
            <summary>Creates and returns a string representation of this instance.</summary>
            <returns>The result of calling <see cref="M:System.Object.ToString"/> on the <see
            cref="P:System.Lazy`1.Value"/>.</returns>
            <exception cref="T:System.NullReferenceException">
            The <see cref="P:System.Lazy`1.Value"/> is null.
            </exception>
        </member>
        <member name="P:System.Lazy`1.ValueForDebugDisplay">
            <summary>Gets the value of the Lazy&lt;T&gt; for debugging display purposes.</summary>
        </member>
        <member name="P:System.Lazy`1.Mode">
            <summary>
            Gets a value indicating whether this instance may be used concurrently from multiple threads.
            </summary>
        </member>
        <member name="P:System.Lazy`1.IsValueFaulted">
            <summary>
            Gets whether the value creation is faulted or not
            </summary>
        </member>
        <member name="P:System.Lazy`1.IsValueCreated">
            <summary>Gets a value indicating whether the <see cref="T:System.Lazy{T}"/> has been initialized.
            </summary>
            <value>true if the <see cref="T:System.Lazy{T}"/> instance has been initialized;
            otherwise, false.</value>
            <remarks>
            The initialization of a <see cref="T:System.Lazy{T}"/> instance may result in either
            a value being produced or an exception being thrown.  If an exception goes unhandled during initialization, 
            <see cref="P:System.Lazy`1.IsValueCreated"/> will return false.
            </remarks>
        </member>
        <member name="P:System.Lazy`1.Value">
            <summary>Gets the lazily initialized value of the current <see
            cref="T:System.Threading.Lazy{T}"/>.</summary>
            <value>The lazily initialized value of the current <see
            cref="T:System.Threading.Lazy{T}"/>.</value>
            <exception cref="T:System.MissingMemberException">
            The <see cref="T:System.Threading.Lazy{T}"/> was initialized to use the default constructor 
            of the type being lazily initialized, and that type does not have a public, parameterless constructor.
            </exception>
            <exception cref="T:System.MemberAccessException">
            The <see cref="T:System.Threading.Lazy{T}"/> was initialized to use the default constructor 
            of the type being lazily initialized, and permissions to access the constructor were missing.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:System.Threading.Lazy{T}"/> was constructed with the <see cref="T:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication"/> or
            <see cref="T:System.Threading.LazyThreadSafetyMode.None"/>  and the initialization function attempted to access <see cref="P:System.Lazy`1.Value"/> on this instance.
            </exception>
            <remarks>
            If <see cref="P:System.Lazy`1.IsValueCreated"/> is false, accessing <see cref="P:System.Lazy`1.Value"/> will force initialization.
            Please <see cref="T:System.Threading.LazyThreadSafetyMode"/> for more information on how <see cref="T:System.Threading.Lazy{T}"/> will behave if an exception is thrown
            from initialization delegate.
            </remarks>
        </member>
        <member name="T:System.LazyDebugView`1">
            <summary>A debugger view of the Lazy&lt;T&gt; to surface additional debugging properties and 
            to ensure that the Lazy&lt;T&gt; does not become initialized if it was not already.</summary>
        </member>
        <member name="M:System.LazyDebugView`1.#ctor(System.Lazy{`0})">
            <summary>Constructs a new debugger view object for the provided Lazy object.</summary>
            <param name="lazy">A Lazy object to browse in the debugger.</param>
        </member>
        <member name="P:System.LazyDebugView`1.IsValueCreated">
            <summary>Returns whether the Lazy object is initialized or not.</summary>
        </member>
        <member name="P:System.LazyDebugView`1.Value">
            <summary>Returns the value of the Lazy object.</summary>
        </member>
        <member name="P:System.LazyDebugView`1.Mode">
            <summary>Returns the execution mode of the Lazy object</summary>
        </member>
        <member name="P:System.LazyDebugView`1.IsValueFaulted">
            <summary>Returns the execution mode of the Lazy object</summary>
        </member>
        <member name="M:System.Marvin.ComputeHash32(System.ReadOnlySpan{System.Byte},System.UInt64)">
            <summary>
            Compute a Marvin hash and collapse it into a 32-bit hash.
            </summary>
        </member>
        <member name="M:System.Marvin.ComputeHash32(System.Byte@,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Compute a Marvin hash and collapse it into a 32-bit hash.
            </summary>
        </member>
        <member name="M:System.Marvin.ComputeHash32OrdinalIgnoreCase(System.Char@,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Compute a Marvin OrdinalIgnoreCase hash and collapse it into a 32-bit hash.
            n.b. <paramref name="count"/> is specified as char count, not byte count.
            </summary>
        </member>
        <member name="T:System.Memory`1">
            <summary>
            Memory represents a contiguous region of arbitrary memory similar to <see cref="T:System.Span`1"/>.
            Unlike <see cref="T:System.Span`1"/>, it is not a byref-like type.
            </summary>
        </member>
        <member name="M:System.Memory`1.#ctor(`0[])">
            <summary>
            Creates a new memory over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.Memory`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.Memory`1.#ctor(System.Buffers.MemoryManager{`0},System.Int32)">
            <summary>
            Creates a new memory from a memory manager that provides specific method implementations beginning
            at 0 index and ending at 'end' index (exclusive).
            </summary>
            <param name="manager">The memory manager.</param>
            <param name="length">The number of items in the memory.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
            <remarks>For internal infrastructure only</remarks>
        </member>
        <member name="M:System.Memory`1.#ctor(System.Buffers.MemoryManager{`0},System.Int32,System.Int32)">
            <summary>
            Creates a new memory from a memory manager that provides specific method implementations beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="manager">The memory manager.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or <paramref name="length"/> is negative.
            </exception>
            <remarks>For internal infrastructure only</remarks>
        </member>
        <member name="M:System.Memory`1.op_Implicit(`0[])~System.Memory{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Memory`1.op_Implicit(System.ArraySegment{`0})~System.Memory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="M:System.Memory`1.op_Implicit(System.Memory{`0})~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.Memory`1"/> to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.Memory`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.Memory`1"/>
            </summary>
        </member>
        <member name="P:System.Memory`1.Length">
            <summary>
            The number of items in the memory.
            </summary>
        </member>
        <member name="P:System.Memory`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.Memory`1.ToString">
            <summary>
            For <see cref="T:System.Memory`1"/>, returns a new instance of string that represents the characters pointed to by the memory.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.Memory`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.Memory`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="P:System.Memory`1.Span">
            <summary>
            Returns a span from the memory.
            </summary>
        </member>
        <member name="M:System.Memory`1.CopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The Memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source.
             </exception>
             </summary>
        </member>
        <member name="M:System.Memory`1.TryCopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination is shorter than the source, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.Memory`1.Pin">
            <summary>
            Creates a handle for the memory.
            The GC will not move the memory until the returned <see cref="T:System.Buffers.MemoryHandle"/>
            is disposed, enabling taking and using the memory's address.
            <exception cref="T:System.ArgumentException">
            An instance with nonprimitive (non-blittable) members cannot be pinned.
            </exception>
            </summary>
        </member>
        <member name="M:System.Memory`1.ToArray">
            <summary>
            Copies the contents from the memory into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.Memory`1.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            Returns true if the object is Memory or ReadOnlyMemory and if both objects point to the same array and have the same length.
            </summary>
        </member>
        <member name="M:System.Memory`1.Equals(System.Memory{`0})">
            <summary>
            Returns true if the memory points to the same array and has the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Memory`1.GetHashCode">
            <summary>
            Serves as the default hash function.
            </summary>
        </member>
        <member name="T:System.MemoryExtensions">
            <summary>
            Extension methods for Span{T}, Memory{T}, and friends.
            </summary>
            <summary>
            Extension methods for Span{T}, Memory{T}, and friends.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})">
            <summary>
            Indicates whether the specified span contains only white-space characters.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)">
            <summary>
            Searches for the specified value and returns true if found. If not found, returns false. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns true if found. If not found, returns false. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T).
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its first occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Searches for the specified value and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The value to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the specified sequence and returns the index of its last occurrence. If not found, returns -1. Values are compared using IEquatable{T}.Equals(T).
            </summary>
            <param name="span">The span to search.</param>
            <param name="value">The sequence to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="value0">One of the values to search for.</param>
            <param name="value1">One of the values to search for.</param>
            <param name="value2">One of the values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator. If not found, returns -1.
            </summary>
            <param name="span">The span to search.</param>
            <param name="values">The set of values to search for.</param>
        </member>
        <member name="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines the relative order of the sequences being compared by comparing the elements using IComparable{T}.CompareTo(T).
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the start of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the start of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the end of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether the specified sequence appears at the end of the span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns an enumeration of <see cref="T:System.Text.Rune"/> from the provided span.
            </summary>
            <remarks>
            Invalid sequences will be represented in the enumeration by <see cref="P:System.Text.Rune.ReplacementChar"/>.
            </remarks>
        </member>
        <member name="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})">
            <summary>
            Returns an enumeration of <see cref="T:System.Text.Rune"/> from the provided span.
            </summary>
            <remarks>
            Invalid sequences will be represented in the enumeration by <see cref="P:System.Text.Rune.ReplacementChar"/>.
            </remarks>
        </member>
        <member name="M:System.MemoryExtensions.Reverse``1(System.Span{``0})">
            <summary>
            Reverses the sequence of the elements in the entire span.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[])">
            <summary>
            Creates a new span over the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <param name="length">The number of items in the Span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})">
            <summary>
            Creates a new span over the portion of the target array segment.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'startIndex' and ending at the end of the segment.
            </summary>
            <param name="segment">The target array.</param>
            <param name="startIndex">The index at which to begin the Span.</param>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new Span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the Span.</param>
            <param name="length">The number of items in the Span.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)">
            <summary>
            Creates a new Span over the portion of the target array using the range start and end indexes
            </summary>
            <param name="segment">The target array.</param>
            <param name="range">The range which has start and end indexes to use for slicing the array.</param>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[])">
            <summary>
            Creates a new memory over the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;array.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)">
            <summary>
            Creates a new memory over the portion of the target array starting from
            'startIndex' to the end of the array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)">
            <summary>
            Creates a new memory over the portion of the target array beginning at inclusive start index of the range
            and ending at the exclusive end index of the range.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})">
            <summary>
            Creates a new memory over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="segment">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="segment"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="segment"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;segment.Count).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})">
             <summary>
             Copies the contents of the array into the span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
            <param name="source">The array to copy items from.</param>
             <param name="destination">The span to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination Span is shorter than the source array.
             </exception>
             </summary>
        </member>
        <member name="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})">
             <summary>
             Copies the contents of the array into the memory. If the source
             and destinations overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
            <param name="source">The array to copy items from.</param>
             <param name="destination">The memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source array.
             </exception>
             </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences overlap in memory.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)">
            <summary>
            Determines whether two sequences overlap in memory and outputs the element offset.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Determines whether two sequences overlap in memory.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)">
            <summary>
            Determines whether two sequences overlap in memory and outputs the element offset.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for a value
            using the specified <see cref="T:System.IComparable`1"/> generic interface.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="comparable">The <see cref="T:System.IComparable`1"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for a value
            using the specified <typeparamref name="TComparable"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparable">The specific type of <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="comparable">The <typeparamref name="TComparable"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.Span`1"/> for the specified <paramref name="value"/>
            using the specified <typeparamref name="TComparer"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparer">The specific type of <see cref="T:System.Collections.Generic.IComparer`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.Span`1"/> to search.</param>
            <param name="value">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The <typeparamref name="TComparer"/> to use when comparing.</param>
            /// <returns>
            The zero-based index of <paramref name="value"/> in the sorted <paramref name="span"/>,
            if <paramref name="value"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="value"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.Span`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparer" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for a value
            using the specified <see cref="T:System.IComparable`1"/> generic interface.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="comparable">The <see cref="T:System.IComparable`1"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for a value
            using the specified <typeparamref name="TComparable"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparable">The specific type of <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="comparable">The <typeparamref name="TComparable"/> to use when comparing.</param>
            <returns>
            The zero-based index of <paramref name="comparable"/> in the sorted <paramref name="span"/>,
            if <paramref name="comparable"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="comparable"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparable" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)">
            <summary>
            Searches an entire sorted <see cref="T:System.ReadOnlySpan`1"/> for the specified <paramref name="value"/>
            using the specified <typeparamref name="TComparer"/> generic type.
            </summary>
            <typeparam name="T">The element type of the span.</typeparam>
            <typeparam name="TComparer">The specific type of <see cref="T:System.Collections.Generic.IComparer`1"/>.</typeparam>
            <param name="span">The sorted <see cref="T:System.ReadOnlySpan`1"/> to search.</param>
            <param name="value">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The <typeparamref name="TComparer"/> to use when comparing.</param>
            /// <returns>
            The zero-based index of <paramref name="value"/> in the sorted <paramref name="span"/>,
            if <paramref name="value"/> is found; otherwise, a negative number that is the bitwise complement
            of the index of the next element that is larger than <paramref name="value"/> or, if there is
            no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name = "comparer" /> is <see langword="null"/> .
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Returns a value indicating whether the specified <paramref name="value"/> occurs within the <paramref name="span"/>.
            <param name="span">The source span.</param>
            <param name="value">The value to seek within the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether this <paramref name="span"/> and the specified <paramref name="other"/> span have the same characters
            when compared using the specified <paramref name="comparisonType"/> option.
            <param name="span">The source span.</param>
            <param name="other">The value to compare with the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="other"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Compares the specified <paramref name="span"/> and <paramref name="other"/> using the specified <paramref name="comparisonType"/>,
            and returns an integer that indicates their relative position in the sort order.
            <param name="span">The source span.</param>
            <param name="other">The value to compare with the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="other"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified <paramref name="value"/> in the current <paramref name="span"/>.
            <param name="span">The source span.</param>
            <param name="value">The value to seek within the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Reports the zero-based index of the last occurrence of the specified <paramref name="value"/> in the current <paramref name="span"/>.
            <param name="span">The source span.</param>
            <param name="value">The value to seek within the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
            <summary>
            Copies the characters from the source span into the destination, converting each character to lowercase,
            using the casing rules of the specified culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <remarks>If <paramref name="culture"/> is null, <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/> will be used.</remarks>
            <returns>The number of characters written into the destination span. If the destination is too small, returns -1.</returns>
            <exception cref="T:System.InvalidOperationException">The source and destination buffers overlap.</exception>
        </member>
        <member name="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
            Copies the characters from the source span into the destination, converting each character to lowercase,
            using the casing rules of the invariant culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <returns>The number of characters written into the destination span. If the destination is too small, returns -1.</returns>
            <exception cref="T:System.InvalidOperationException">The source and destination buffers overlap.</exception>
        </member>
        <member name="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)">
            <summary>
            Copies the characters from the source span into the destination, converting each character to uppercase,
            using the casing rules of the specified culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <param name="culture">An object that supplies culture-specific casing rules.</param>
            <remarks>If <paramref name="culture"/> is null, <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/> will be used.</remarks>
            <returns>The number of characters written into the destination span. If the destination is too small, returns -1.</returns>
            <exception cref="T:System.InvalidOperationException">The source and destination buffers overlap.</exception>
        </member>
        <member name="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
            Copies the characters from the source span into the destination, converting each character to uppercase
            using the casing rules of the invariant culture.
            </summary>
            <param name="source">The source span.</param>
            <param name="destination">The destination span which contains the transformed characters.</param>
            <returns>The number of characters written into the destination span. If the destination is too small, returns -1.</returns>
            <exception cref="T:System.InvalidOperationException">The source and destination buffers overlap.</exception>
        </member>
        <member name="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether the end of the <paramref name="span"/> matches the specified <paramref name="value"/> when compared using the specified <paramref name="comparisonType"/> option.
            </summary>
            <param name="span">The source span.</param>
            <param name="value">The sequence to compare to the end of the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
        </member>
        <member name="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Determines whether the beginning of the <paramref name="span"/> matches the specified <paramref name="value"/> when compared using the specified <paramref name="comparisonType"/> option.
            </summary>
            <param name="span">The source span.</param>
            <param name="value">The sequence to compare to the beginning of the source span.</param>
            <param name="comparisonType">One of the enumeration values that determines how the <paramref name="span"/> and <paramref name="value"/> are compared.</param>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)">
            <summary>
            Creates a new span over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)">
            <summary>
            Creates a new span over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)">
            <summary>
            Creates a new span over the portion of the target array.
            </summary>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="text"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;text.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new readonly span over the portion of the target string.
            </summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index or <paramref name="length"/> is not in range.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;text.Length).
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Index)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="startIndex">The index at which to begin this slice.</param>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <remarks>Returns default when <paramref name="text"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index or <paramref name="length"/> is not in range.
            </exception>
        </member>
        <member name="M:System.MemoryExtensions.AsMemory(System.String,System.Range)">
            <summary>Creates a new <see cref="T:System.ReadOnlyMemory`1"/> over the portion of the target string.</summary>
            <param name="text">The target string.</param>
            <param name="range">The range used to indicate the start and length of the sliced string.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)">
            <summary>
            Removes all leading and trailing occurrences of a specified element from the memory.
            </summary>
            <param name="memory">The source memory from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)">
            <summary>
            Removes all leading occurrences of a specified element from the memory.
            </summary>
            <param name="memory">The source memory from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)">
            <summary>
            Removes all trailing occurrences of a specified element from the memory.
            </summary>
            <param name="memory">The source memory from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)">
            <summary>
            Removes all leading and trailing occurrences of a specified element from the memory.
            </summary>
            <param name="memory">The source memory from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)">
            <summary>
            Removes all leading occurrences of a specified element from the memory.
            </summary>
            <param name="memory">The source memory from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)">
            <summary>
            Removes all trailing occurrences of a specified element from the memory.
            </summary>
            <param name="memory">The source memory from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)">
            <summary>
            Removes all leading and trailing occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)">
            <summary>
            Removes all leading occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)">
            <summary>
            Removes all trailing occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Removes all leading and trailing occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Removes all leading occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Removes all trailing occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.ClampStart``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Delimits all leading occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.ClampEnd``1(System.ReadOnlySpan{``0},System.Int32,``0)">
            <summary>
            Delimits all trailing occurrences of a specified element from the span.
            </summary>
            <param name="span">The source span from which the element is removed.</param>
            <param name="start">The start index from which to being searching.</param>
            <param name="trimElement">The specified element to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading and trailing occurrences of a set of elements specified
            in a readonly span from the memory.
            </summary>
            <param name="memory">The source memory from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the memory is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading occurrences of a set of elements specified
            in a readonly span from the memory.
            </summary>
            <param name="memory">The source memory from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the memory is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all trailing occurrences of a set of elements specified
            in a readonly span from the memory.
            </summary>
            <param name="memory">The source memory from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the memory is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading and trailing occurrences of a set of elements specified
            in a readonly span from the memory.
            </summary>
            <param name="memory">The source memory from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the memory is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading occurrences of a set of elements specified
            in a readonly span from the memory.
            </summary>
            <param name="memory">The source memory from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the memory is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all trailing occurrences of a set of elements specified
            in a readonly span from the memory.
            </summary>
            <param name="memory">The source memory from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the memory is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading and trailing occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the span is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the span is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all trailing occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the span is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading and trailing occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the span is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all leading occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the span is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Removes all trailing occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
            <remarks>If <paramref name="trimElements"/> is empty, the span is returned unaltered.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.ClampStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Delimits all leading occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.ClampEnd``1(System.ReadOnlySpan{``0},System.Int32,System.ReadOnlySpan{``0})">
            <summary>
            Delimits all trailing occurrences of a set of elements specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the elements are removed.</param>
            <param name="start">The start index from which to being searching.</param>
            <param name="trimElements">The span which contains the set of elements to remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.Memory{System.Char})">
            <summary>
            Removes all leading and trailing white-space characters from the memory.
            </summary>
            <param name="memory">The source memory from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})">
            <summary>
            Removes all leading white-space characters from the memory.
            </summary>
            <param name="memory">The source memory from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})">
            <summary>
            Removes all trailing white-space characters from the memory.
            </summary>
            <param name="memory">The source memory from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})">
            <summary>
            Removes all leading and trailing white-space characters from the memory.
            </summary>
            <param name="memory">The source memory from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})">
            <summary>
            Removes all leading white-space characters from the memory.
            </summary>
            <param name="memory">The source memory from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})">
            <summary>
            Removes all trailing white-space characters from the memory.
            </summary>
            <param name="memory">The source memory from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading and trailing white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all trailing white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all leading and trailing occurrences of a specified character from the span.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all leading occurrences of a specified character from the span.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Removes all trailing occurrences of a specified character from the span.
            </summary>
            <param name="span">The source span from which the character is removed.</param>
            <param name="trimChar">The specified character to look for and remove.</param>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading and trailing occurrences of a set of characters specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all leading occurrences of a set of characters specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Removes all trailing occurrences of a set of characters specified
            in a readonly span from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="trimChars">The span which contains the set of characters to remove.</param>
            <remarks>If <paramref name="trimChars"/> is empty, white-space characters are removed instead.</remarks>
        </member>
        <member name="M:System.MemoryExtensions.Trim(System.Span{System.Char})">
            <summary>
            Removes all leading and trailing white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})">
            <summary>
            Removes all leading white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})">
            <summary>
            Removes all trailing white-space characters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.ClampStart(System.ReadOnlySpan{System.Char})">
            <summary>
            Delimits all leading occurrences of whitespace charecters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
        </member>
        <member name="M:System.MemoryExtensions.ClampEnd(System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
            Delimits all trailing occurrences of whitespace charecters from the span.
            </summary>
            <param name="span">The source span from which the characters are removed.</param>
            <param name="start">The start index from which to being searching.</param>
        </member>
        <member name="M:System.Number.FormatDouble(System.Text.ValueStringBuilder@,System.Double,System.ReadOnlySpan{System.Char},System.Globalization.NumberFormatInfo)">
            <summary>Formats the specified value according to the specified format and info.</summary>
            <returns>
            Non-null if an existing string can be returned, in which case the builder will be unmodified.
            Null if no existing string was returned, in which case the formatted output is in the builder.
            </returns>
        </member>
        <member name="M:System.Number.FormatSingle(System.Text.ValueStringBuilder@,System.Single,System.ReadOnlySpan{System.Char},System.Globalization.NumberFormatInfo)">
            <summary>Formats the specified value according to the specified format and info.</summary>
            <returns>
            Non-null if an existing string can be returned, in which case the builder will be unmodified.
            Null if no existing string was returned, in which case the formatted output is in the builder.
            </returns>
        </member>
        <member name="P:System.Number.CharToHexLookup">
            <summary>Map from an ASCII char to its hex value, e.g. arr['b'] == 11. 0xFF means it's not a hex digit.</summary>
        </member>
        <member name="M:System.Number.TryParseInt32IntegerStyle(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.Globalization.NumberFormatInfo,System.Int32@)">
            <summary>Parses int limited to styles that make up NumberStyles.Integer.</summary>
        </member>
        <member name="M:System.Number.TryParseInt64IntegerStyle(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.Globalization.NumberFormatInfo,System.Int64@)">
            <summary>Parses long inputs limited to styles that make up NumberStyles.Integer.</summary>
        </member>
        <member name="M:System.Number.TryParseUInt32IntegerStyle(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.Globalization.NumberFormatInfo,System.UInt32@)">
            <summary>Parses uint limited to styles that make up NumberStyles.Integer.</summary>
        </member>
        <member name="M:System.Number.TryParseUInt32HexNumberStyle(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.UInt32@)">
            <summary>Parses uint limited to styles that make up NumberStyles.HexNumber.</summary>
        </member>
        <member name="M:System.Number.TryParseUInt64IntegerStyle(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.Globalization.NumberFormatInfo,System.UInt64@)">
            <summary>Parses ulong limited to styles that make up NumberStyles.Integer.</summary>
        </member>
        <member name="M:System.Number.TryParseUInt64HexNumberStyle(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.UInt64@)">
            <summary>Parses ulong limited to styles that make up NumberStyles.HexNumber.</summary>
        </member>
        <member name="T:System.Numerics.BitOperations">
            <summary>
            Utility methods for intrinsic bit-twiddling operations.
            The methods use hardware intrinsics when available on the underlying platform,
            otherwise they use optimized software fallbacks.
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperations.LeadingZeroCount(System.UInt32)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.LeadingZeroCount(System.UInt64)">
            <summary>
            Count the number of leading zero bits in a mask.
            Similar in behavior to the x86 instruction LZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since Log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2(System.UInt64)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since Log(0) is undefined.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.Log2SoftwareFallback(System.UInt32)">
            <summary>
            Returns the integer (floor) log of the specified value, base 2.
            Note that by convention, input value 0 returns 0 since Log(0) is undefined.
            Does not directly use any hardware intrinsics, nor does it incur branching.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt32)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.PopCount(System.UInt64)">
            <summary>
            Returns the population count (number of bits set) of a mask.
            Similar in behavior to the x86 instruction POPCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)">
            <summary>
            Count the number of trailing zero bits in an integer value.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)">
            <summary>
            Count the number of trailing zero bits in a mask.
            Similar in behavior to the x86 instruction TZCNT.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateLeft(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateLeft(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateRight(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateRight(System.UInt64,System.Int32)">
            <summary>
            Rotates the specified value right by the specified number of bits.
            Similar in behavior to the x86 instruction ROR.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..63] is treated as congruent mod 64.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="T:System.Numerics.Register">
            <summary>
            A structure describing the layout of an SSE2-sized register.
            Contains overlapping fields representing the set of valid numeric types.
            Allows the generic Vector'T struct to contain an explicit field layout.
            </summary>
        </member>
        <member name="T:System.Numerics.Vector`1">
            <summary>
            A structure that represents a single Vector. The count of this Vector is fixed but CPU register dependent.
            This struct only supports numerical types. This type is intended to be used as a building block for vectorizing
            large algorithms. This type is immutable, individual elements cannot be modified.
            </summary>
        </member>
        <member name="P:System.Numerics.Vector`1.Count">
            <summary>
            Returns the number of elements stored in the vector. This value is hardware dependent.
            </summary>
        </member>
        <member name="P:System.Numerics.Vector`1.Zero">
            <summary>
            Returns a vector containing all zeroes.
            </summary>
        </member>
        <member name="P:System.Numerics.Vector`1.One">
            <summary>
            Returns a vector containing all ones.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.#ctor(`0)">
            <summary>
            Constructs a vector whose components are all <code>value</code>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.#ctor(`0[])">
            <summary>
            Constructs a vector from the given array. The size of the given array must be at least Vector'T.Count.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.#ctor(`0[],System.Int32)">
            <summary>
            Constructs a vector from the given array, starting from the given index.
            The array must contain at least Vector'T.Count from the given index.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Constructs a vector from the given <see cref="T:System.ReadOnlySpan`1"/>. The span must contain at least <see cref="P:System.Numerics.Vector`1.Count"/> elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Constructs a vector from the given <see cref="T:System.ReadOnlySpan`1"/>. The span must contain at least <see cref="P:System.Numerics.Vector`1.Count"/> elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.#ctor(System.Span{`0})">
            <summary>
            Constructs a vector from the given <see cref="T:System.Span`1"/>. The span must contain at least <see cref="P:System.Numerics.Vector`1.Count"/> elements.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.CopyTo(System.Span{System.Byte})">
            <summary>
            Copies the vector to the given <see cref="T:System.Span`1"/>. The destination span must be at least size <see cref="P:System.Numerics.Vector`1.Count"/>.
            </summary>
            <param name="destination">The destination span which the values are copied into</param>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination span</exception>
        </member>
        <member name="M:System.Numerics.Vector`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the vector to the given <see cref="T:System.Span`1"/>. The destination span must be at least size <see cref="P:System.Numerics.Vector`1.Count"/>.
            </summary>
            <param name="destination">The destination span which the values are copied into</param>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination span</exception>
        </member>
        <member name="M:System.Numerics.Vector`1.CopyTo(`0[])">
            <summary>
            Copies the vector to the given destination array. The destination array must be at least size Vector'T.Count.
            </summary>
            <param name="destination">The destination array which the values are copied into</param>
            <exception cref="T:System.ArgumentNullException">If the destination array is null</exception>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination array</exception>
        </member>
        <member name="M:System.Numerics.Vector`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the vector to the given destination array. The destination array must be at least size Vector'T.Count.
            </summary>
            <param name="destination">The destination array which the values are copied into</param>
            <param name="startIndex">The index to start copying to</param>
            <exception cref="T:System.ArgumentNullException">If the destination array is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is greater than end of the array or index is less than zero</exception>
            <exception cref="T:System.ArgumentException">If number of elements in source vector is greater than those available in destination array</exception>
        </member>
        <member name="P:System.Numerics.Vector`1.Item(System.Int32)">
            <summary>
            Returns the element at the given index.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector`1.Equals(System.Object)">
            <summary>
            Returns a boolean indicating whether the given Object is equal to this vector instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this vector; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.Equals(System.Numerics.Vector{`0})">
            <summary>
            Returns a boolean indicating whether the given vector is equal to this vector instance.
            </summary>
            <param name="other">The vector to compare this instance to.</param>
            <returns>True if the other vector is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.ToString">
            <summary>
            Returns a String representing this vector.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.ToString(System.String)">
            <summary>
            Returns a String representing this vector, using the specified format string to format individual elements.
            </summary>
            <param name="format">The format of individual elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.ToString(System.String,System.IFormatProvider)">
            <summary>
            Returns a String representing this vector, using the specified format string to format individual elements
            and the given IFormatProvider.
            </summary>
            <param name="format">The format of individual elements.</param>
            <param name="formatProvider">The format provider to use when formatting elements.</param>
            <returns>The string representation.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.TryCopyTo(System.Span{System.Byte})">
            <summary>
            Attempts to copy the vector to the given <see cref="T:System.Span`1"/>. The destination span must be at least size <see cref="P:System.Numerics.Vector`1.Count"/>.
            </summary>
            <param name="destination">The destination span which the values are copied into</param>
            <returns>True if the source vector was successfully copied to <paramref name="destination"/>. False if
            <paramref name="destination"/> is not large enough to hold the source vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.TryCopyTo(System.Span{`0})">
            <summary>
            Attempts to copy the vector to the given <see cref="T:System.Span`1"/>. The destination span must be at least size <see cref="P:System.Numerics.Vector`1.Count"/>.
            </summary>
            <param name="destination">The destination span which the values are copied into</param>
            <returns>True if the source vector was successfully copied to <paramref name="destination"/>. False if
            <paramref name="destination"/> is not large enough to hold the source vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Addition(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Adds two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Subtraction(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Subtracts the second vector from the first.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Multiply(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Multiplies two vectors together.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The product vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Multiply(System.Numerics.Vector{`0},`0)">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="value">The source vector.</param>
            <param name="factor">The scalar value.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Multiply(`0,System.Numerics.Vector{`0})">
            <summary>
            Multiplies a vector by the given scalar.
            </summary>
            <param name="factor">The scalar value.</param>
            <param name="value">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Division(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Divides the first vector by the second.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The vector resulting from the division.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_UnaryNegation(System.Numerics.Vector{`0})">
            <summary>
            Negates a given vector.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_BitwiseAnd(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Returns a new vector by performing a bitwise-and operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_BitwiseOr(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Returns a new vector by performing a bitwise-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_ExclusiveOr(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Returns a new vector by performing a bitwise-exclusive-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_OnesComplement(System.Numerics.Vector{`0})">
            <summary>
            Returns a new vector whose elements are obtained by taking the one's complement of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The one's complement vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Equality(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Returns a boolean indicating whether each pair of elements in the given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The first vector to compare.</param>
            <returns>True if all elements are equal; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Inequality(System.Numerics.Vector{`0},System.Numerics.Vector{`0})">
            <summary>
            Returns a boolean indicating whether any single pair of elements in the given vectors are not equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if left and right are not equal; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Byte}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.SByte}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt16}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int16}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt32}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int32}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.UInt64}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Int64}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Single}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector`1.op_Explicit(System.Numerics.Vector{`0})~System.Numerics.Vector{System.Double}">
            <summary>
            Reinterprets the bits of the given vector into those of another type.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="T:System.Numerics.Vector">
            <summary>
            Contains various methods useful for creating, manipulating, combining, and converting generic vectors with one another.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Byte},System.Numerics.Vector{System.UInt16}@,System.Numerics.Vector{System.UInt16}@)">
            <summary>
            Widens a Vector{Byte} into two Vector{UInt16}'s.
            <param name="source">The source vector whose elements are widened into the outputs.</param>
            <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
            <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.UInt16},System.Numerics.Vector{System.UInt32}@,System.Numerics.Vector{System.UInt32}@)">
            <summary>
            Widens a Vector{UInt16} into two Vector{UInt32}'s.
            <param name="source">The source vector whose elements are widened into the outputs.</param>
            <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
            <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.UInt32},System.Numerics.Vector{System.UInt64}@,System.Numerics.Vector{System.UInt64}@)">
            <summary>
            Widens a Vector{UInt32} into two Vector{UInt64}'s.
            <param name="source">The source vector whose elements are widened into the outputs.</param>
            <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
            <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.SByte},System.Numerics.Vector{System.Int16}@,System.Numerics.Vector{System.Int16}@)">
            <summary>
            Widens a Vector{SByte} into two Vector{Int16}'s.
            <param name="source">The source vector whose elements are widened into the outputs.</param>
            <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
            <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Int16},System.Numerics.Vector{System.Int32}@,System.Numerics.Vector{System.Int32}@)">
            <summary>
            Widens a Vector{Int16} into two Vector{Int32}'s.
            <param name="source">The source vector whose elements are widened into the outputs.</param>
            <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
            <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int64}@,System.Numerics.Vector{System.Int64}@)">
            <summary>
            Widens a Vector{Int32} into two Vector{Int64}'s.
            <param name="source">The source vector whose elements are widened into the outputs.</param>
            <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
            <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Widen(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Double}@,System.Numerics.Vector{System.Double}@)">
            <summary>
            Widens a Vector{Single} into two Vector{Double}'s.
            <param name="source">The source vector whose elements are widened into the outputs.</param>
            <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
            <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.UInt16},System.Numerics.Vector{System.UInt16})">
            <summary>
            Narrows two Vector{UInt16}'s into one Vector{Byte}.
            <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
            <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
            <returns>A Vector{Byte} containing elements narrowed from the source vectors.</returns>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.UInt32},System.Numerics.Vector{System.UInt32})">
            <summary>
            Narrows two Vector{UInt32}'s into one Vector{UInt16}.
            <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
            <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
            <returns>A Vector{UInt16} containing elements narrowed from the source vectors.</returns>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.UInt64},System.Numerics.Vector{System.UInt64})">
            <summary>
            Narrows two Vector{UInt64}'s into one Vector{UInt32}.
            <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
            <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
            <returns>A Vector{UInt32} containing elements narrowed from the source vectors.</returns>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Int16},System.Numerics.Vector{System.Int16})">
            <summary>
            Narrows two Vector{Int16}'s into one Vector{SByte}.
            <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
            <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
            <returns>A Vector{SByte} containing elements narrowed from the source vectors.</returns>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})">
            <summary>
            Narrows two Vector{Int32}'s into one Vector{Int16}.
            <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
            <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
            <returns>A Vector{Int16} containing elements narrowed from the source vectors.</returns>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})">
            <summary>
            Narrows two Vector{Int64}'s into one Vector{Int32}.
            <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
            <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
            <returns>A Vector{Int32} containing elements narrowed from the source vectors.</returns>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Narrow(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})">
            <summary>
            Narrows two Vector{Double}'s into one Vector{Single}.
            <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
            <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
            <returns>A Vector{Single} containing elements narrowed from the source vectors.</returns>
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToSingle(System.Numerics.Vector{System.Int32})">
            <summary>
            Converts a Vector{Int32} to a Vector{Single}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToSingle(System.Numerics.Vector{System.UInt32})">
            <summary>
            Converts a Vector{UInt32} to a Vector{Single}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToDouble(System.Numerics.Vector{System.Int64})">
            <summary>
            Converts a Vector{Int64} to a Vector{Double}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToDouble(System.Numerics.Vector{System.UInt64})">
            <summary>
            Converts a Vector{UInt64} to a Vector{Double}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToInt32(System.Numerics.Vector{System.Single})">
            <summary>
            Converts a Vector{Single} to a Vector{Int32}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToUInt32(System.Numerics.Vector{System.Single})">
            <summary>
            Converts a Vector{Single} to a Vector{UInt32}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToInt64(System.Numerics.Vector{System.Double})">
            <summary>
            Converts a Vector{Double} to a Vector{Int64}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConvertToUInt64(System.Numerics.Vector{System.Double})">
            <summary>
            Converts a Vector{Double} to a Vector{UInt64}.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The converted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConditionalSelect(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})">
            <summary>
            Creates a new vector with elements selected between the two given source vectors, and based on a mask vector.
            </summary>
            <param name="condition">The integral mask vector used to drive selection.</param>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The new vector with elements selected based on the mask.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConditionalSelect(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})">
            <summary>
            Creates a new vector with elements selected between the two given source vectors, and based on a mask vector.
            </summary>
            <param name="condition">The integral mask vector used to drive selection.</param>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The new vector with elements selected based on the mask.</returns>
        </member>
        <member name="M:System.Numerics.Vector.ConditionalSelect``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Creates a new vector with elements selected between the two given source vectors, and based on a mask vector.
            </summary>
            <param name="condition">The mask vector used to drive selection.</param>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The new vector with elements selected based on the mask.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Equals``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left and right were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether elements in the left and right floating point vectors were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left and right were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether elements in the left and right floating point vectors were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Equals(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left and right were equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.EqualsAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether each pair of elements in the given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The first vector to compare.</param>
            <returns>True if all elements are equal; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.EqualsAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether any single pair of elements in the given vectors are equal.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any element pairs are equal; False if no element pairs are equal.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThan``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThan(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether all of the elements in left are less than their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are less than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether any element in left is less than its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are less than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanOrEqual``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanOrEqual(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were less than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanOrEqualAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether all elements in left are less than or equal to their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are less than or equal to their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.LessThanOrEqualAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether any element in left is less than or equal to its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are less than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThan``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThan(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether all elements in left are greater than the corresponding elements in right.
            elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are greater than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether any element in left is greater than its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are greater than their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanOrEqual``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Single},System.Numerics.Vector{System.Single})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Int32},System.Numerics.Vector{System.Int32})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Int64},System.Numerics.Vector{System.Int64})">
            <summary>
            Returns a new vector whose elements signal whether the elements in left were greater than or equal to their
            corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanOrEqual(System.Numerics.Vector{System.Double},System.Numerics.Vector{System.Double})">
            <summary>
            Returns an integral vector whose elements signal whether the elements in left were greater than or equal to 
            their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>The resultant integral vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanOrEqualAll``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether all of the elements in left are greater than or equal to 
            their corresponding elements in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if all elements in left are greater than or equal to their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="M:System.Numerics.Vector.GreaterThanOrEqualAny``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a boolean indicating whether any element in left is greater than or equal to its corresponding element in right.
            </summary>
            <param name="left">The first vector to compare.</param>
            <param name="right">The second vector to compare.</param>
            <returns>True if any elements in left are greater than or equal to their corresponding elements in right; False otherwise.</returns>
        </member>
        <member name="P:System.Numerics.Vector.IsHardwareAccelerated">
            <summary>
            Returns whether or not vector operations are subject to hardware acceleration through JIT intrinsic support.
            </summary>
        </member>
        <member name="M:System.Numerics.Vector.Abs``1(System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the absolute values of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The absolute value vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Min``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the minimum of each pair of elements in the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The minimum vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Max``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the maximum of each pair of elements in the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The maximum vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Dot``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns the dot product of two vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:System.Numerics.Vector.SquareRoot``1(System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the square roots of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The square root vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Add``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Creates a new vector whose values are the sum of each pair of elements from the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Subtract``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Creates a new vector whose values are the difference between each pairs of elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The difference vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Multiply``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Creates a new vector whose values are the product of each pair of elements from the two given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The summed vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Multiply``1(System.Numerics.Vector{``0},``0)">
            <summary>
            Returns a new vector whose values are the values of the given vector each multiplied by a scalar value.
            </summary>
            <param name="left">The source vector.</param>
            <param name="right">The scalar factor.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Multiply``1(``0,System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose values are the values of the given vector each multiplied by a scalar value.
            </summary>
            <param name="left">The scalar factor.</param>
            <param name="right">The source vector.</param>
            <returns>The scaled vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Divide``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose values are the result of dividing the first vector's elements 
            by the corresponding elements in the second vector.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The divided vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Negate``1(System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are the given vector's elements negated.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.BitwiseAnd``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-and operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.BitwiseOr``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.OnesComplement``1(System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector whose elements are obtained by taking the one's complement of the given vector's elements.
            </summary>
            <param name="value">The source vector.</param>
            <returns>The one's complement vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.Xor``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-exclusive-or operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AndNot``1(System.Numerics.Vector{``0},System.Numerics.Vector{``0})">
            <summary>
            Returns a new vector by performing a bitwise-and-not operation on each of the elements in the given vectors.
            </summary>
            <param name="left">The first source vector.</param>
            <param name="right">The second source vector.</param>
            <returns>The resultant vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorByte``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of unsigned bytes.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorSByte``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed bytes.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorUInt16``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of 16-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorInt16``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed 16-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorUInt32``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of unsigned 32-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorInt32``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed 32-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorUInt64``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of unsigned 64-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorInt64``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of signed 64-bit integers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorSingle``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of 32-bit floating point numbers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="M:System.Numerics.Vector.AsVectorDouble``1(System.Numerics.Vector{``0})">
            <summary>
            Reinterprets the bits of the given vector into those of a vector of 64-bit floating point numbers.
            </summary>
            <param name="value">The source vector</param>
            <returns>The reinterpreted vector.</returns>
        </member>
        <member name="T:System.ObjectDisposedException">
            <summary>
            The exception that is thrown when accessing an object that was disposed.
            </summary>
        </member>
        <member name="P:System.ObjectDisposedException.Message">
            <summary>
            Gets the text for the message for this exception.
            </summary>
        </member>
        <member name="T:System.OutOfMemoryException">
            <summary>
            The exception class for OOM.
            </summary>
        </member>
        <member name="T:System.ParseNumbers">
            <summary>Methods for parsing numbers and strings.</summary>
        </member>
        <member name="M:System.PasteArguments.Paste(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Repastes a set of arguments into a linear string that parses back into the originals under pre- or post-2008 VC parsing rules.
            On Unix: the rules for parsing the executable name (argv[0]) are ignored.
            </summary>
        </member>
        <member name="T:System.Progress`1">
            <summary>
            Provides an IProgress{T} that invokes callbacks for each reported progress value.
            </summary>
            <typeparam name="T">Specifies the type of the progress report value.</typeparam>
            <remarks>
            Any handler provided to the constructor or event handlers registered with
            the <see cref="E:System.Progress`1.ProgressChanged"/> event are invoked through a 
            <see cref="T:System.Threading.SynchronizationContext"/> instance captured
            when the instance is constructed.  If there is no current SynchronizationContext
            at the time of construction, the callbacks will be invoked on the ThreadPool.
            </remarks>
        </member>
        <member name="F:System.Progress`1._synchronizationContext">
            <summary>The synchronization context captured upon construction.  This will never be null.</summary>
        </member>
        <member name="F:System.Progress`1._handler">
            <summary>The handler specified to the constructor.  This may be null.</summary>
        </member>
        <member name="F:System.Progress`1._invokeHandlers">
            <summary>A cached delegate used to post invocation to the synchronization context.</summary>
        </member>
        <member name="M:System.Progress`1.#ctor">
            <summary>Initializes the <see cref="T:System.Progress`1"/>.</summary>
        </member>
        <member name="M:System.Progress`1.#ctor(System.Action{`0})">
            <summary>Initializes the <see cref="T:System.Progress`1"/> with the specified callback.</summary>
            <param name="handler">
            A handler to invoke for each reported progress value.  This handler will be invoked
            in addition to any delegates registered with the <see cref="E:System.Progress`1.ProgressChanged"/> event.
            Depending on the <see cref="T:System.Threading.SynchronizationContext"/> instance captured by 
            the <see cref="T:System.Progress`1"/> at construction, it's possible that this handler instance
            could be invoked concurrently with itself.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="handler"/> is null (Nothing in Visual Basic).</exception>
        </member>
        <member name="E:System.Progress`1.ProgressChanged">
            <summary>Raised for each reported progress value.</summary>
            <remarks>
            Handlers registered with this event will be invoked on the 
            <see cref="T:System.Threading.SynchronizationContext"/> captured when the instance was constructed.
            </remarks>
        </member>
        <member name="M:System.Progress`1.OnReport(`0)">
            <summary>Reports a progress change.</summary>
            <param name="value">The value of the updated progress.</param>
        </member>
        <member name="M:System.Progress`1.System#IProgress{T}#Report(`0)">
            <summary>Reports a progress change.</summary>
            <param name="value">The value of the updated progress.</param>
        </member>
        <member name="M:System.Progress`1.InvokeHandlers(System.Object)">
            <summary>Invokes the action and event callbacks.</summary>
            <param name="state">The progress value.</param>
        </member>
        <member name="T:System.ProgressStatics">
            <summary>Holds static values for <see cref="T:System.Progress`1"/>.</summary>
            <remarks>This avoids one static instance per type T.</remarks>
        </member>
        <member name="F:System.ProgressStatics.DefaultContext">
            <summary>A default synchronization context that targets the ThreadPool.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.ReadOnlySpan`1">
            <summary>
            ReadOnlySpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
            <summary>
            ReadOnlySpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Length">
            <summary>
            The number of items in the read-only span.
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Inequality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Equals(System.Object)">
            <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetHashCode">
            <summary>
            This method is not supported as spans cannot be boxed.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Implicit(`0[])~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Implicit(System.ArraySegment{`0})~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Empty">
            <summary>
            Returns a 0-length read-only span whose base is the null pointer.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetEnumerator">
            <summary>Gets an enumerator for this span.</summary>
        </member>
        <member name="T:System.ReadOnlySpan`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.ReadOnlySpan`1"/>.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1.Enumerator._span">
            <summary>The span being enumerated.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1.Enumerator._index">
            <summary>The next index to yield.</summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.#ctor(System.ReadOnlySpan{`0})">
            <summary>Initialize the enumerator.</summary>
            <param name="span">The span to enumerate.</param>
        </member>
        <member name="M:System.ReadOnlySpan`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the span.</summary>
        </member>
        <member name="P:System.ReadOnlySpan`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1._pointer">
            <summary>A byref or a native ptr.</summary>
        </member>
        <member name="F:System.ReadOnlySpan`1._length">
            <summary>The number of elements this ReadOnlySpan contains.</summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(`0[])">
            <summary>
            Creates a new read-only span over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new read-only span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the read-only span.</param>
            <param name="length">The number of items in the read-only span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Creates a new read-only span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="P:System.ReadOnlySpan`1.Item(System.Int32)">
            <summary>
            Returns the specified element of the read-only span.
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to Length
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.CopyTo(System.Span{`0})">
             <summary>
             Copies the contents of this read-only span into destination span. If the source
             and destinations overlap, this method behaves as if the original values in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The span to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination Span is shorter than the source Span.
             </exception>
             </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this read-only span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
            <returns>If the destination span is shorter than the source span, this method
            return false and no data is written to the destination.</returns>
            <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.ReadOnlySpan`1.op_Equality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})">
            <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.ToString">
            <summary>
            For <see cref="T:System.ReadOnlySpan`1"/>, returns a new instance of string that represents the characters pointed to by the span.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given read-only span, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given read-only span, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlySpan`1.ToArray">
            <summary>
            Copies the contents of this read-only span into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="T:System.ReadOnlyMemory`1">
            <summary>
            Represents a contiguous region of memory, similar to <see cref="T:System.ReadOnlySpan`1"/>.
            Unlike <see cref="T:System.ReadOnlySpan`1"/>, it is not a byref-like type.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(`0[])">
            <summary>
            Creates a new memory over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new memory over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.#ctor(System.Object,System.Int32,System.Int32)">
            <summary>Creates a new memory over the existing object, start, and length. No validation is performed.</summary>
            <param name="obj">The target object.</param>
            <param name="start">The index at which to begin the memory.</param>
            <param name="length">The number of items in the memory.</param>
        </member>
        <member name="M:System.ReadOnlyMemory`1.op_Implicit(`0[])~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.op_Implicit(System.ArraySegment{`0})~System.ReadOnlyMemory{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.ReadOnlyMemory`1"/>
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Length">
            <summary>
            The number of items in the memory.
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemory`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.ToString">
            <summary>
            For <see cref="T:System.ReadOnlyMemory`1"/>, returns a new instance of string that represents the characters pointed to by the memory.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given memory, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="P:System.ReadOnlyMemory`1.Span">
            <summary>
            Returns a span from the memory.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.CopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the read-only memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <param name="destination">The Memory to copy items into.</param>
             <exception cref="T:System.ArgumentException">
             Thrown when the destination is shorter than the source.
             </exception>
             </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.TryCopyTo(System.Memory{`0})">
             <summary>
             Copies the contents of the readonly-only memory into the destination. If the source
             and destination overlap, this method behaves as if the original values are in
             a temporary location before the destination is overwritten.
            
             <returns>If the destination is shorter than the source, this method
             return false and no data is written to the destination.</returns>
             </summary>
             <param name="destination">The span to copy items into.</param>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Pin">
            <summary>
            Creates a handle for the memory.
            The GC will not move the memory until the returned <see cref="T:System.Buffers.MemoryHandle"/>
            is disposed, enabling taking and using the memory's address.
            <exception cref="T:System.ArgumentException">
            An instance with nonprimitive (non-blittable) members cannot be pinned.
            </exception>
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.ToArray">
            <summary>
            Copies the contents from the memory into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Equals(System.Object)">
            <summary>Determines whether the specified object is equal to the current object.</summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.Equals(System.ReadOnlyMemory{`0})">
            <summary>
            Returns true if the memory points to the same array and has the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.GetHashCode">
            <summary>Returns the hash code for this <see cref="T:System.ReadOnlyMemory`1"/></summary>
        </member>
        <member name="M:System.ReadOnlyMemory`1.GetObjectStartLength(System.Int32@,System.Int32@)">
            <summary>Gets the state of the memory as individual fields.</summary>
            <param name="start">The offset.</param>
            <param name="length">The count.</param>
            <returns>The object.</returns>
        </member>
        <member name="M:System.Single.IsFinite(System.Single)">
            <summary>Determines whether the specified value is finite (zero, subnormal, or normal).</summary>
        </member>
        <member name="M:System.Single.IsInfinity(System.Single)">
            <summary>Determines whether the specified value is infinite.</summary>
        </member>
        <member name="M:System.Single.IsNaN(System.Single)">
            <summary>Determines whether the specified value is NaN.</summary>
        </member>
        <member name="M:System.Single.IsNegative(System.Single)">
            <summary>Determines whether the specified value is negative.</summary>
        </member>
        <member name="M:System.Single.IsNegativeInfinity(System.Single)">
            <summary>Determines whether the specified value is negative infinity.</summary>
        </member>
        <member name="M:System.Single.IsNormal(System.Single)">
            <summary>Determines whether the specified value is normal.</summary>
        </member>
        <member name="M:System.Single.IsPositiveInfinity(System.Single)">
            <summary>Determines whether the specified value is positive infinity.</summary>
        </member>
        <member name="M:System.Single.IsSubnormal(System.Single)">
            <summary>Determines whether the specified value is subnormal.</summary>
        </member>
        <member name="T:System.Span`1">
            <summary>
            Span represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
            <summary>
            Span represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type- and memory-safe.
            </summary>
        </member>
        <member name="P:System.Span`1.Length">
            <summary>
            The number of items in the span.
            </summary>
        </member>
        <member name="P:System.Span`1.IsEmpty">
            <summary>
            Returns true if Length is 0.
            </summary>
        </member>
        <member name="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})">
            <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Span`1.Equals(System.Object)">
            <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.Span`1.GetHashCode">
            <summary>
            This method is not supported as spans cannot be boxed.
            <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}">
            <summary>
            Defines an implicit conversion of an array to a <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.ArraySegment`1"/> to a <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="P:System.Span`1.Empty">
            <summary>
            Returns an empty <see cref="T:System.Span`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.GetEnumerator">
            <summary>Gets an enumerator for this span.</summary>
        </member>
        <member name="T:System.Span`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.Span`1"/>.</summary>
        </member>
        <member name="F:System.Span`1.Enumerator._span">
            <summary>The span being enumerated.</summary>
        </member>
        <member name="F:System.Span`1.Enumerator._index">
            <summary>The next index to yield.</summary>
        </member>
        <member name="M:System.Span`1.Enumerator.#ctor(System.Span{`0})">
            <summary>Initialize the enumerator.</summary>
            <param name="span">The span to enumerate.</param>
        </member>
        <member name="M:System.Span`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next element of the span.</summary>
        </member>
        <member name="P:System.Span`1.Enumerator.Current">
            <summary>Gets the element at the current position of the enumerator.</summary>
        </member>
        <member name="F:System.Span`1._pointer">
            <summary>A byref or a native ptr.</summary>
        </member>
        <member name="F:System.Span`1._length">
            <summary>The number of elements this Span contains.</summary>
        </member>
        <member name="M:System.Span`1.#ctor(`0[])">
            <summary>
            Creates a new span over the entirety of the target array.
            </summary>
            <param name="array">The target array.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
        </member>
        <member name="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Creates a new span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
            <param name="array">The target array.</param>
            <param name="start">The index at which to begin the span.</param>
            <param name="length">The number of items in the span.</param>
            <remarks>Returns default when <paramref name="array"/> is null.</remarks>
            <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array"/> is covariant and array's type is not exactly T[].</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in the range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.Span`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Creates a new span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because we are creating arbitrarily typed T's
            out of a void*-typed block of memory.  And the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
            <param name="pointer">An unmanaged pointer to memory.</param>
            <param name="length">The number of <typeparamref name="T"/> elements the memory contains.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T"/> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="length"/> is negative.
            </exception>
        </member>
        <member name="P:System.Span`1.Item(System.Int32)">
            <summary>
            Returns a reference to specified element of the Span.
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to Length
            </exception>
        </member>
        <member name="M:System.Span`1.GetPinnableReference">
            <summary>
            Returns a reference to the 0th element of the Span. If the Span is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        </member>
        <member name="M:System.Span`1.Clear">
            <summary>
            Clears the contents of this span.
            </summary>
        </member>
        <member name="M:System.Span`1.Fill(`0)">
            <summary>
            Fills the contents of this span with the given value.
            </summary>
        </member>
        <member name="M:System.Span`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
            <param name="destination">The span to copy items into.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when the destination Span is shorter than the source Span.
            </exception>
        </member>
        <member name="M:System.Span`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies the contents of this span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
            <param name="destination">The span to copy items into.</param>
            <returns>If the destination span is shorter than the source span, this method
            return false and no data is written to the destination.</returns>
        </member>
        <member name="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})">
            <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        </member>
        <member name="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}">
            <summary>
            Defines an implicit conversion of a <see cref="T:System.Span`1"/> to a <see cref="T:System.ReadOnlySpan`1"/>
            </summary>
        </member>
        <member name="M:System.Span`1.ToString">
            <summary>
            For <see cref="T:System.Span`1"/>, returns a new instance of string that represents the characters pointed to by the span.
            Otherwise, returns a <see cref="T:System.String"/> with the name of the type and the number of elements.
            </summary>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32)">
            <summary>
            Forms a slice out of the given span, beginning at 'start'.
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice out of the given span, beginning at 'start', of given length
            </summary>
            <param name="start">The index at which to begin this slice.</param>
            <param name="length">The desired length for the slice (exclusive).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start"/> or end index is not in range (&lt;0 or &gt;Length).
            </exception>
        </member>
        <member name="M:System.Span`1.ToArray">
            <summary>
            Copies the contents of this span into a new array.  This heap
            allocates, so should generally be avoided, however it is sometimes
            necessary to bridge the gap with APIs written in terms of arrays.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.CachedData.GetCorrespondingKind(System.TimeZoneInfo)">
            <summary>
            Helper function that returns the corresponding DateTimeKind for this TimeZoneInfo.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetAmbiguousTimeOffsets(System.DateTimeOffset)">
            <summary>
            Returns an array of TimeSpan objects representing all of
            possible UTC offset values for this ambiguous time.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetAmbiguousTimeOffsets(System.DateTime)">
            <summary>
            Returns an array of TimeSpan objects representing all of
            possible UTC offset values for this ambiguous time.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetPreviousAdjustmentRule(System.TimeZoneInfo.AdjustmentRule,System.Nullable{System.Int32})">
            <summary>
            Gets the AdjustmentRule that is immediately preceding the specified rule.
            If the specified rule is the first AdjustmentRule, or it isn't in _adjustmentRules,
            then the specified rule is returned.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetUtcOffset(System.DateTimeOffset)">
            <summary>
            Returns the Universal Coordinated Time (UTC) Offset for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetUtcOffset(System.DateTime)">
            <summary>
            Returns the Universal Coordinated Time (UTC) Offset for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetUtcOffset(System.DateTime,System.TimeZoneInfoOptions)">
            <summary>
            Returns the Universal Coordinated Time (UTC) Offset for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsAmbiguousTime(System.DateTimeOffset)">
            <summary>
            Returns true if the time is during the ambiguous time period
            for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsAmbiguousTime(System.DateTime)">
            <summary>
            Returns true if the time is during the ambiguous time period
            for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsAmbiguousTime(System.DateTime,System.TimeZoneInfoOptions)">
            <summary>
            Returns true if the time is during the ambiguous time period
            for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTimeOffset)">
            <summary>
            Returns true if the time is during Daylight Saving time for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTime)">
            <summary>
            Returns true if the time is during Daylight Saving time for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsDaylightSavingTime(System.DateTime,System.TimeZoneInfoOptions)">
            <summary>
            Returns true if the time is during Daylight Saving time for the current TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsInvalidTime(System.DateTime)">
            <summary>
            Returns true when dateTime falls into a "hole in time".
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ClearCachedData">
            <summary>
            Clears data from static members.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId(System.DateTimeOffset,System.String)">
            <summary>
            Converts the value of a DateTime object from sourceTimeZone to destinationTimeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId(System.DateTime,System.String)">
            <summary>
            Converts the value of a DateTime object from sourceTimeZone to destinationTimeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTimeBySystemTimeZoneId(System.DateTime,System.String,System.String)">
            <summary>
            Converts the value of a DateTime object from sourceTimeZone to destinationTimeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTime(System.DateTimeOffset,System.TimeZoneInfo)">
            <summary>
            Converts the value of the dateTime object from sourceTimeZone to destinationTimeZone
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTime(System.DateTime,System.TimeZoneInfo)">
            <summary>
            Converts the value of the dateTime object from sourceTimeZone to destinationTimeZone
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTime(System.DateTime,System.TimeZoneInfo,System.TimeZoneInfo)">
            <summary>
            Converts the value of the dateTime object from sourceTimeZone to destinationTimeZone
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTime(System.DateTime,System.TimeZoneInfo,System.TimeZoneInfo,System.TimeZoneInfoOptions)">
            <summary>
            Converts the value of the dateTime object from sourceTimeZone to destinationTimeZone
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTimeFromUtc(System.DateTime,System.TimeZoneInfo)">
            <summary>
            Converts the value of a DateTime object from Coordinated Universal Time (UTC) to the destinationTimeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime)">
            <summary>
            Converts the value of a DateTime object to Coordinated Universal Time (UTC).
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfoOptions)">
            <summary>
            Converts the value of a DateTime object to Coordinated Universal Time (UTC).
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertTimeToUtc(System.DateTime,System.TimeZoneInfo)">
            <summary>
            Converts the value of a DateTime object to Coordinated Universal Time (UTC).
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.Equals(System.TimeZoneInfo)">
            <summary>
            Returns value equality. Equals does not compare any localizable
            String objects (DisplayName, StandardName, DaylightName).
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetSystemTimeZones">
            <summary>
            Returns a <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> containing all valid TimeZone's
            from the local machine. The entries in the collection are sorted by
            <see cref="P:System.TimeZoneInfo.DisplayName"/>.
            This method does *not* throw TimeZoneNotFoundException or InvalidTimeZoneException.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.HasSameRules(System.TimeZoneInfo)">
            <summary>
            Value equality on the "adjustmentRules" array
            </summary>
        </member>
        <member name="P:System.TimeZoneInfo.Local">
            <summary>
            Returns a TimeZoneInfo instance that represents the local time on the machine.
            Accessing this property may throw InvalidTimeZoneException or COMException
            if the machine is in an unstable or corrupt state.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ToString">
            <summary>
            Returns the <see cref="P:System.TimeZoneInfo.DisplayName"/>: "(GMT-08:00) Pacific Time (US &amp; Canada); Tijuana"
            </summary>
        </member>
        <member name="P:System.TimeZoneInfo.Utc">
            <summary>
            Returns a TimeZoneInfo instance that represents Universal Coordinated Time (UTC)
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.CreateCustomTimeZone(System.String,System.TimeSpan,System.String,System.String)">
            <summary>
            Returns a simple TimeZoneInfo instance that does not support Daylight Saving Time.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.CreateCustomTimeZone(System.String,System.TimeSpan,System.String,System.String,System.String,System.TimeZoneInfo.AdjustmentRule[])">
            <summary>
            Returns a TimeZoneInfo instance that may support Daylight Saving Time.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.CreateCustomTimeZone(System.String,System.TimeSpan,System.String,System.String,System.String,System.TimeZoneInfo.AdjustmentRule[],System.Boolean)">
            <summary>
            Returns a TimeZoneInfo instance that may support Daylight Saving Time.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.CompareAdjustmentRuleToDateTime(System.TimeZoneInfo.AdjustmentRule,System.TimeZoneInfo.AdjustmentRule,System.DateTime,System.DateTime,System.Boolean)">
            <summary>
            Determines if 'rule' is the correct AdjustmentRule for the given dateTime.
            </summary>
            <returns>
            A value less than zero if rule is for times before dateTime.
            Zero if rule is correct for dateTime.
            A value greater than zero if rule is for times after dateTime.
            </returns>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertToUtc(System.DateTime,System.TimeSpan,System.TimeSpan)">
            <summary>
            Converts the dateTime to UTC using the specified deltas.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertFromUtc(System.DateTime,System.TimeSpan,System.TimeSpan)">
            <summary>
            Converts the dateTime from UTC using the specified deltas.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertToFromUtc(System.DateTime,System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>
            Converts the dateTime to or from UTC using the specified deltas.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ConvertUtcToTimeZone(System.Int64,System.TimeZoneInfo,System.Boolean@)">
            <summary>
            Helper function that converts a dateTime from UTC into the destinationTimeZone
            - Returns DateTime.MaxValue when the converted value is too large.
            - Returns DateTime.MinValue when the converted value is too small.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetDaylightTime(System.Int32,System.TimeZoneInfo.AdjustmentRule,System.Nullable{System.Int32})">
            <summary>
            Helper function that returns a DaylightTime from a year and AdjustmentRule.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetIsDaylightSavings(System.DateTime,System.TimeZoneInfo.AdjustmentRule,System.Globalization.DaylightTimeStruct,System.TimeZoneInfoOptions)">
            <summary>
            Helper function that checks if a given dateTime is in Daylight Saving Time (DST).
            This function assumes the dateTime and AdjustmentRule are both in the same time zone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetDaylightSavingsStartOffsetFromUtc(System.TimeSpan,System.TimeZoneInfo.AdjustmentRule,System.Nullable{System.Int32})">
            <summary>
            Gets the offset that should be used to calculate DST start times from a UTC time.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetDaylightSavingsEndOffsetFromUtc(System.TimeSpan,System.TimeZoneInfo.AdjustmentRule)">
            <summary>
            Gets the offset that should be used to calculate DST end times from a UTC time.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetIsDaylightSavingsFromUtc(System.DateTime,System.Int32,System.TimeSpan,System.TimeZoneInfo.AdjustmentRule,System.Nullable{System.Int32},System.Boolean@,System.TimeZoneInfo)">
            <summary>
            Helper function that checks if a given dateTime is in Daylight Saving Time (DST).
            This function assumes the dateTime is in UTC and AdjustmentRule is in a different time zone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetIsAmbiguousTime(System.DateTime,System.TimeZoneInfo.AdjustmentRule,System.Globalization.DaylightTimeStruct)">
             <summary>
             Returns true when the dateTime falls into an ambiguous time range.
            
             For example, in Pacific Standard Time on Sunday, October 29, 2006 time jumps from
             2AM to 1AM.  This means the timeline on Sunday proceeds as follows:
             12AM ... [1AM ... 1:59:59AM -> 1AM ... 1:59:59AM] 2AM ... 3AM ...
            
             In this example, any DateTime values that fall into the [1AM - 1:59:59AM] range
             are ambiguous; as it is unclear if these times are in Daylight Saving Time.
             </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetIsInvalidTime(System.DateTime,System.TimeZoneInfo.AdjustmentRule,System.Globalization.DaylightTimeStruct)">
            <summary>
            Helper function that checks if a given DateTime is in an invalid time ("time hole")
            A "time hole" occurs at a DST transition point when time jumps forward;
            For example, in Pacific Standard Time on Sunday, April 2, 2006 time jumps from
            1:59:59.9999999 to 3AM.  The time range 2AM to 2:59:59.9999999AM is the "time hole".
            A "time hole" is not limited to only occurring at the start of DST, and may occur at
            the end of DST as well.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetUtcOffset(System.DateTime,System.TimeZoneInfo,System.TimeZoneInfoOptions)">
            <summary>
            Helper function that calculates the UTC offset for a dateTime in a timeZone.
            This function assumes that the dateTime is already converted into the timeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetUtcOffsetFromUtc(System.DateTime,System.TimeZoneInfo)">
            <summary>
            Helper function that calculates the UTC offset for a UTC-dateTime in a timeZone.
            This function assumes that the dateTime is represented in UTC and has *not* already been converted into the timeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetUtcOffsetFromUtc(System.DateTime,System.TimeZoneInfo,System.Boolean@)">
            <summary>
            Helper function that calculates the UTC offset for a UTC-dateTime in a timeZone.
            This function assumes that the dateTime is represented in UTC and has *not* already been converted into the timeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetUtcOffsetFromUtc(System.DateTime,System.TimeZoneInfo,System.Boolean@,System.Boolean@)">
            <summary>
            Helper function that calculates the UTC offset for a UTC-dateTime in a timeZone.
            This function assumes that the dateTime is represented in UTC and has *not* already been converted into the timeZone.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.TransitionTimeToDateTime(System.Int32,System.TimeZoneInfo.TransitionTime)">
            <summary>
            Helper function that converts a year and TransitionTime into a DateTime.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.TryGetTimeZone(System.String,System.Boolean,System.TimeZoneInfo@,System.Exception@,System.TimeZoneInfo.CachedData,System.Boolean)">
             <summary>
             Helper function for retrieving a TimeZoneInfo object by time_zone_name.
            
             This function may return null.
            
             assumes cachedData lock is taken
             </summary>
        </member>
        <member name="M:System.TimeZoneInfo.ValidateTimeZoneInfo(System.String,System.TimeSpan,System.TimeZoneInfo.AdjustmentRule[],System.Boolean@)">
            <summary>
            Helper function that performs all of the validation checks for the
            factory methods and deserialization callback.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.UtcOffsetOutOfRange(System.TimeSpan)">
            <summary>
            Helper function that validates the TimeSpan is within +/- 14.0 hours
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.IsValidAdjustmentRuleOffest(System.TimeSpan,System.TimeZoneInfo.AdjustmentRule)">
            <summary>
            Helper function that performs adjustment rule validation
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.NormalizeAdjustmentRuleOffset(System.TimeSpan,System.TimeZoneInfo.AdjustmentRule@)">
            <summary>
            Normalize adjustment rule offset so that it is within valid range
            This method should not be called at all but is here in case something changes in the future
            or if really old time zones are present on the OS (no combination is known at the moment)
            </summary>
        </member>
        <member name="P:System.TimeZoneInfo.AdjustmentRule.NoDaylightTransitions">
            <summary>
            Gets a value indicating that this AdjustmentRule fixes the time zone offset
            from DateStart to DateEnd without any daylight transitions in between.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.AdjustmentRule.ValidateAdjustmentRule(System.DateTime,System.DateTime,System.TimeSpan,System.TimeZoneInfo.TransitionTime,System.TimeZoneInfo.TransitionTime,System.Boolean)">
            <summary>
            Helper function that performs all of the validation checks for the factory methods and deserialization callback.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.AdjustmentRule.AdjustDaylightDeltaToExpectedRange(System.TimeSpan@,System.TimeSpan@)">
            <summary>
            Ensures the daylight delta is within [-12, 12] hours
            </summary>>
        </member>
        <member name="T:System.TimeZoneInfo.StringSerializer">
            <summary>
            Used to serialize and deserialize TimeZoneInfo objects based on the custom string serialization format.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetSerializedString(System.TimeZoneInfo)">
            <summary>
            Creates the custom serialized string representation of a TimeZoneInfo instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetDeserializedTimeZoneInfo(System.String)">
            <summary>
            Instantiates a TimeZoneInfo from a custom serialized string.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.SerializeSubstitute(System.String,System.Text.StringBuilder)">
             <summary>
             Appends the String to the StringBuilder with all of the reserved chars escaped.
            
             ";" -> "\;"
             "[" -> "\["
             "]" -> "\]"
             "\" -> "\\"
             </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.SerializeTransitionTime(System.TimeZoneInfo.TransitionTime,System.Text.StringBuilder)">
            <summary>
            Helper method to serialize a TimeZoneInfo.TransitionTime object.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.VerifyIsEscapableCharacter(System.Char)">
            <summary>
            Helper function to determine if the passed in string token is allowed to be preceded by an escape sequence token.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.SkipVersionNextDataFields(System.Int32)">
            <summary>
            Helper function that reads past "v.Next" data fields. Receives a "depth" parameter indicating the
            current relative nested bracket depth that _currentTokenStartIndex is at. The function ends
            successfully when "depth" returns to zero (0).
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetNextStringValue">
            <summary>
            Helper function that reads a string token from the serialized text. The function
            updates <see cref="F:System.TimeZoneInfo.StringSerializer._currentTokenStartIndex"/> to point to the next token on exit.
            Also <see cref="F:System.TimeZoneInfo.StringSerializer._state"/> is set to either <see cref="F:System.TimeZoneInfo.StringSerializer.State.StartOfToken"/> or
            <see cref="F:System.TimeZoneInfo.StringSerializer.State.EndOfLine"/> on exit.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetNextDateTimeValue(System.String)">
            <summary>
            Helper function to read a DateTime token.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetNextTimeSpanValue">
            <summary>
            Helper function to read a TimeSpan token.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetNextInt32Value">
            <summary>
            Helper function to read an Int32 token.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetNextAdjustmentRuleArrayValue">
            <summary>
            Helper function to read an AdjustmentRule[] token.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetNextAdjustmentRuleValue">
            <summary>
            Helper function to read an AdjustmentRule token.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.StringSerializer.GetNextTransitionTimeValue">
            <summary>
            Helper function to read a TransitionTime token.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.TransitionTime.ValidateTransitionTime(System.DateTime,System.Int32,System.Int32,System.Int32,System.DayOfWeek)">
            <summary>
            Helper function that validates a TransitionTime instance.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetAdjustmentRules">
            <summary>
            Returns a cloned array of AdjustmentRule objects
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetLocalTimeZone(System.TimeZoneInfo.CachedData)">
            <summary>
            Helper function for retrieving the local system time zone.
            May throw COMException, TimeZoneNotFoundException, InvalidTimeZoneException.
            Assumes cachedData lock is taken.
            </summary>
            <returns>A new TimeZoneInfo instance.</returns>
        </member>
        <member name="M:System.TimeZoneInfo.GetTimeZoneIds(System.String)">
            <summary>
            Returns a collection of TimeZone Id values from the zone.tab file in the timeZoneDirectory.
            </summary>
            <remarks>
            Lines that start with # are comments and are skipped.
            </remarks>
        </member>
        <member name="M:System.TimeZoneInfo.TryGetLocalTzFile(System.Byte[]@,System.String@)">
            <summary>
            Gets the tzfile raw data for the current 'local' time zone using the following rules.
            1. Read the TZ environment variable.  If it is set, use it.
            2. Look for the data in /etc/localtime.
            3. Look for the data in GetTimeZoneDirectory()/localtime.
            4. Use UTC if all else fails.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.FindTimeZoneIdUsingReadLink(System.String)">
            <summary>
            Finds the time zone id by using 'readlink' on the path to see if tzFilePath is
            a symlink to a file.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.EnumerateFilesRecursively(System.String,System.Predicate{System.String})">
            <summary>
            Enumerate files
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.FindTimeZoneId(System.Byte[])">
            <summary>
            Find the time zone id by searching all the tzfiles for the one that matches rawData
            and return its file name.
            </summary>
        </member>
        <member name="M:System.TimeZoneInfo.GetLocalTimeZoneFromTzFile">
             <summary>
             Helper function used by 'GetLocalTimeZone()' - this function wraps the call
             for loading time zone data from computers without Registry support.
            
             The TryGetLocalTzFile() call returns a Byte[] containing the compiled tzfile.
             </summary>
        </member>
        <member name="M:System.TimeZoneInfo.FindSystemTimeZoneById(System.String)">
             <summary>
             Helper function for retrieving a TimeZoneInfo object by time_zone_name.
             This function wraps the logic necessary to keep the private
             SystemTimeZones cache in working order
            
             This function will either return a valid TimeZoneInfo instance or
             it will throw 'InvalidTimeZoneException' / 'TimeZoneNotFoundException'.
             </summary>
        </member>
        <member name="M:System.TimeZoneInfo.TZif_GetEarlyDateTransitionType(System.TimeZoneInfo.TZifType[])">
            <summary>
            Gets the first standard-time transition type, or simply the first transition type
            if there are no standard transition types.
            </summary>>
            <remarks>
            from 'man tzfile':
            localtime(3)  uses the first standard-time ttinfo structure in the file
            (or simply the first ttinfo structure in the absence of a standard-time
            structure)  if  either tzh_timecnt is zero or the time argument is less
            than the first transition time recorded in the file.
            </remarks>
        </member>
        <member name="M:System.TimeZoneInfo.TZif_CreateAdjustmentRuleForPosixFormat(System.String,System.DateTime,System.TimeSpan)">
            <summary>
            Creates an AdjustmentRule given the POSIX TZ environment variable string.
            </summary>
            <remarks>
            See http://man7.org/linux/man-pages/man3/tzset.3.html for the format and semantics of this POSX string.
            </remarks>
        </member>
        <member name="M:System.TimeZoneInfo.TZif_ParseJulianDay(System.ReadOnlySpan{System.Char},System.Int32@,System.Int32@)">
            <summary>
            Parses a string like Jn or n into month and day values.
            </summary>
            <returns>
            true if the parsing succeeded; otherwise, false.
            </returns>
        </member>
        <member name="M:System.TimeZoneInfo.TZif_ParseMDateRule(System.ReadOnlySpan{System.Char},System.Int32@,System.Int32@,System.DayOfWeek@)">
            <summary>
            Parses a string like Mm.w.d into month, week and DayOfWeek values.
            </summary>
            <returns>
            true if the parsing succeeded; otherwise, false.
            </returns>
        </member>
        <member name="T:System.ITupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="P:System.Tuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.TupleExtensions">
            <summary>
            Provides extension methods for <see cref="T:System.Tuple"/> instances to interop with C# tuples features (deconstruction syntax, converting from and to <see cref="T:System.ValueTuple"/>).
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``1(System.Tuple{``0},``0@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 1 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``2(System.Tuple{``0,``1},``0@,``1@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 2 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``3(System.Tuple{``0,``1,``2},``0@,``1@,``2@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 3 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``4(System.Tuple{``0,``1,``2,``3},``0@,``1@,``2@,``3@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 4 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``5(System.Tuple{``0,``1,``2,``3,``4},``0@,``1@,``2@,``3@,``4@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 5 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``6(System.Tuple{``0,``1,``2,``3,``4,``5},``0@,``1@,``2@,``3@,``4@,``5@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 6 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``7(System.Tuple{``0,``1,``2,``3,``4,``5,``6},``0@,``1@,``2@,``3@,``4@,``5@,``6@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 7 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``8(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 8 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``9(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 9 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``10(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 10 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``11(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 11 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``12(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 12 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``13(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 13 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``14(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 14 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``15(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 15 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``16(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 16 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``17(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 17 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``18(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 18 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``19(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17,``18}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@,``18@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 19 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``20(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17,``18,``19}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@,``18@,``19@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 20 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.Deconstruct``21(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17,``18,``19,``20}}},``0@,``1@,``2@,``3@,``4@,``5@,``6@,``7@,``8@,``9@,``10@,``11@,``12@,``13@,``14@,``15@,``16@,``17@,``18@,``19@,``20@)">
            <summary>
            Deconstruct a properly nested <see cref="T:System.Tuple"/> with 21 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``1(System.Tuple{``0})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 1 element.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``2(System.Tuple{``0,``1})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 2 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``3(System.Tuple{``0,``1,``2})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 3 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``4(System.Tuple{``0,``1,``2,``3})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 4 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``5(System.Tuple{``0,``1,``2,``3,``4})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 5 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``6(System.Tuple{``0,``1,``2,``3,``4,``5})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 6 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``7(System.Tuple{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 7 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``8(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 8 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``9(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 9 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``10(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 10 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``11(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 11 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``12(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 12 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``13(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 13 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``14(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 14 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``15(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14}}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 15 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``16(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15}}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 16 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``17(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16}}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 17 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``18(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17}}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 18 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``19(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17,``18}}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 19 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``20(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17,``18,``19}}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 20 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToValueTuple``21(System.Tuple{``0,``1,``2,``3,``4,``5,``6,System.Tuple{``7,``8,``9,``10,``11,``12,``13,System.Tuple{``14,``15,``16,``17,``18,``19,``20}}})">
            <summary>
            Make a properly nested <see cref="T:System.ValueTuple"/> from a properly nested <see cref="T:System.Tuple"/> with 21 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``1(System.ValueTuple{``0})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 1 element.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``2(System.ValueTuple{``0,``1})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 2 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``3(System.ValueTuple{``0,``1,``2})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 3 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``4(System.ValueTuple{``0,``1,``2,``3})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 4 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``5(System.ValueTuple{``0,``1,``2,``3,``4})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 5 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``6(System.ValueTuple{``0,``1,``2,``3,``4,``5})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 6 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``7(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 7 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``8(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 8 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``9(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 9 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``10(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 10 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``11(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 11 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``12(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 12 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``13(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 13 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``14(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 14 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``15(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13,System.ValueTuple{``14}}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 15 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``16(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13,System.ValueTuple{``14,``15}}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 16 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``17(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13,System.ValueTuple{``14,``15,``16}}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 17 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``18(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13,System.ValueTuple{``14,``15,``16,``17}}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 18 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``19(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13,System.ValueTuple{``14,``15,``16,``17,``18}}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 19 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``20(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13,System.ValueTuple{``14,``15,``16,``17,``18,``19}}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 20 elements.
            </summary>
        </member>
        <member name="M:System.TupleExtensions.ToTuple``21(System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7,``8,``9,``10,``11,``12,``13,System.ValueTuple{``14,``15,``16,``17,``18,``19,``20}}})">
            <summary>
            Make a properly nested <see cref="T:System.Tuple"/> from a properly nested <see cref="T:System.ValueTuple"/> with 21 elements.
            </summary>
        </member>
        <member name="T:System.UnitySerializationHolder">
            <summary>
            Holds Null class for which we guarantee that there is only ever one instance of.
            This only exists for compatibility with .NET Framework.
            </summary>
        </member>
        <member name="M:System.UnitySerializationHolder.GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo,System.Int32)">
            <summary>
            A helper method that returns the SerializationInfo that a class utilizing 
            UnitySerializationHelper should return from a call to GetObjectData. It contains
            the unityType (defined above) and any optional data (used only for the reflection types).
            </summary>
        </member>
        <member name="T:System.IValueTupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:System.ValueTuple">
            <summary>
            The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
            Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
            The System.ValueTuple types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:System.ValueTuple"/>.</returns>
        </member>
        <member name="M:System.ValueTuple.Equals(System.ValueTuple)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:System.ValueTuple.CompareTo(System.ValueTuple)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Create">
            <summary>Creates a new struct 0-tuple.</summary>
            <returns>A 0-tuple.</returns>
        </member>
        <member name="M:System.ValueTuple.Create``1(``0)">
            <summary>Creates a new struct 1-tuple, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <returns>A 1-tuple (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``2(``0,``1)">
            <summary>Creates a new struct 2-tuple, or pair.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-tuple, or triple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-tuple, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-tuple, or quintuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-tuple, or sextuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-tuple, or septuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-tuple, or octuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <param name="item8">The value of the eighth component of the tuple.</param>
            <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:System.ValueTuple`1">
            <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the tuple's only component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`1.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`1"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.ValueTuple{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`1"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.CompareTo(System.ValueTuple{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <c>Item1</c> represents the value of <see cref="F:System.ValueTuple`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`2">
            <summary>
            Represents a 2-tuple, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`2.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`2.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's second component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`2"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:System.ValueTuple`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.ValueTuple{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified <see cref="T:System.ValueTuple`2"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`2.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object based on a specified comparison method.
             </summary>
             <param name="other">The object to compare with this instance.</param>
             <param name="comparer">An object that defines the method to use to evaluate whether the two objects are equal.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             This member is an explicit interface member implementation. It can be used only when the
              <see cref="T:System.ValueTuple`2"/> instance is cast to an <see cref="T:System.Collections.IStructuralEquatable"/> interface.
            
             The <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation is called only if <c>other</c> is not <see langword="null"/>,
              and if it can be successfully cast (in C#) or converted (in Visual Basic) to a <see cref="T:System.ValueTuple`2"/>
              whose components are of the same types as those of the current instance. The IStructuralEquatable.Equals(Object, IEqualityComparer) method
              first passes the <see cref="F:System.ValueTuple`2.Item1"/> values of the <see cref="T:System.ValueTuple`2"/> objects to be compared to the
              <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation. If this method call returns <see langword="true"/>, the method is
              called again and passed the <see cref="F:System.ValueTuple`2.Item2"/> values of the two <see cref="T:System.ValueTuple`2"/> instances.
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.CompareTo(System.ValueTuple{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <c>Item1</c> and <c>Item2</c> represent the values of the <see cref="F:System.ValueTuple`2.Item1"/>
            and <see cref="F:System.ValueTuple`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`3">
            <summary>
            Represents a 3-tuple, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`3.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`3"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.ValueTuple{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`3"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.CompareTo(System.ValueTuple{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`4">
            <summary>
            Represents a 4-tuple, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`4.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`4"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.ValueTuple{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`4"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.CompareTo(System.ValueTuple{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`5">
            <summary>
            Represents a 5-tuple, or quintuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`5.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`5"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`5"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`6">
            <summary>
            Represents a 6-tuple, or sixtuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`6.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`6"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`6"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`7">
            <summary>
            Represents a 7-tuple, or sentuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`7.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`7"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`7"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`8">
            <summary>
            Represents an 8-tuple, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
            <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`8.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Rest">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`8"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
            <param name="rest">The value of the tuple's eight component.</param>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`8"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.GetMessage(System.Int32)">
            <summary>
                Returns a string message for the specified Win32 error code.
            </summary>
        </member>
        <member name="T:Interop.BOOL">
            <summary>
            Blittable version of Windows BOOL type. It is convenient in situations where
            manual marshalling is required, or to avoid overhead of regular bool marshalling.
            </summary>
            <remarks>
            Some Windows APIs return arbitrary integer values although the return type is defined
            as BOOL. It is best to never compare BOOL to TRUE. Always use bResult != BOOL.FALSE
            or bResult == BOOL.FALSE .
            </remarks>
        </member>
        <member name="T:Interop.Error">
            <summary>Common Unix errno error codes.</summary>
        </member>
        <member name="M:Interop.Sys.FLock(System.IntPtr,Interop.Sys.LockOperations)">
            <summary>
            Exposing this for SafeFileHandle.ReleaseHandle() to call.
            Normal callers should use FLock(SafeFileHandle fd).
            </summary>
        </member>
        <member name="M:Interop.Sys.PosixFAdvise(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Int64,System.Int64,Interop.Sys.FileAdvice)">
            <summary>
            Notifies the OS kernel that the specified file will be accessed in a particular way soon; this allows the kernel to
            potentially optimize the access pattern of the file.
            </summary>
            <param name="fd">The file descriptor of the file</param>
            <param name="offset">The start of the region to advise about</param>
            <param name="length">The number of bytes of the region (until the end of the file if 0)</param>
            <param name="advice">The type of advice to give the kernel about the specified region</param>
            <returns>
            Returns 0 on success; otherwise, the error code is returned
            </returns>
        </member>
        <member name="M:Interop.Sys.Read(System.Runtime.InteropServices.SafeHandle,System.Byte*,System.Int32)">
            <summary>
            Reads a number of bytes from an open file descriptor into a specified buffer.
            </summary>
            <param name="fd">The open file descriptor to try to read from</param>
            <param name="buffer">The buffer to read info into</param>
            <param name="count">The size of the buffer</param>
            <returns>
            Returns the number of bytes read on success; otherwise, -1 is returned
            Note - on fail. the position of the stream may change depending on the platform; consult man 2 read for more info
            </returns>
        </member>
        <member name="M:Interop.Sys.ReadLink(System.String,System.Byte[],System.Int32)">
            <summary>
            Takes a path to a symbolic link and attempts to place the link target path into the buffer. If the buffer is too
            small, the path will be truncated. No matter what, the buffer will not be null terminated. 
            </summary>
            <param name="path">The path to the symlink</param>
            <param name="buffer">The buffer to hold the output path</param>
            <param name="bufferSize">The size of the buffer</param>
            <returns>
            Returns the number of bytes placed into the buffer on success; bufferSize if the buffer is too small; and -1 on error.
            </returns>
        </member>
        <member name="M:Interop.Sys.ReadLink(System.String)">
            <summary>
            Takes a path to a symbolic link and returns the link target path.
            </summary>
            <param name="path">The path to the symlink</param>
            <returns>
            Returns the link to the target path on success; and null otherwise.
            </returns>
        </member>
        <member name="M:Interop.Sys.SysLog(Interop.Sys.SysLogPriority,System.String,System.String)">
            <summary>
            Write a message to the system logger, which in turn writes the message to the system console, log files, etc. 
            See man 3 syslog for more info
            </summary>
            <param name="priority">
            The OR of a priority and facility in the SysLogPriority enum to declare the priority and facility of the log entry
            </param>
            <param name="message">The message to put in the log entry</param>
            <param name="arg1">Like printf, the argument is passed to the variadic part of the C++ function to wildcards in the message</param>
        </member>
        <member name="M:Interop.Sys.Write(System.Runtime.InteropServices.SafeHandle,System.Byte*,System.Int32)">
            <summary>
            Writes the specified buffer to the provided open file descriptor
            </summary>
            <param name="fd">The file descriptor to try and write to</param>
            <param name="buffer">The data to attempt to write</param>
            <param name="bufferSize">The amount of data to write, in bytes</param>
            <returns>
            Returns the number of bytes written on success; otherwise, returns -1 and sets errno
            </returns>
        </member>
        <member name="M:Interop.CheckIo(System.Int64,System.String,System.Boolean,System.Func{Interop.ErrorInfo,Interop.ErrorInfo})">
            <summary>
            Validates the result of system call that returns greater than or equal to 0 on success
            and less than 0 on failure, with errno set to the error code.
            If the system call failed for any reason, an exception is thrown. Otherwise, the system call succeeded.
            </summary>
            <param name="result">The result of the system call.</param>
            <param name="path">The path with which this error is associated.  This may be null.</param>
            <param name="isDirectory">true if the <paramref name="path"/> is known to be a directory; otherwise, false.</param>
            <param name="errorRewriter">Optional function to change an error code prior to processing it.</param>
            <returns>
            On success, returns the non-negative result long that was validated.
            </returns>
        </member>
        <member name="M:Interop.CheckIo(System.Int32,System.String,System.Boolean,System.Func{Interop.ErrorInfo,Interop.ErrorInfo})">
            <summary>
            Validates the result of system call that returns greater than or equal to 0 on success
            and less than 0 on failure, with errno set to the error code.
            If the system call failed for any reason, an exception is thrown. Otherwise, the system call succeeded.
            </summary>
            <returns>
            On success, returns the non-negative result int that was validated.
            </returns>
        </member>
        <member name="M:Interop.CheckIo(System.IntPtr,System.String,System.Boolean,System.Func{Interop.ErrorInfo,Interop.ErrorInfo})">
            <summary>
            Validates the result of system call that returns greater than or equal to 0 on success
            and less than 0 on failure, with errno set to the error code.
            If the system call failed for any reason, an exception is thrown. Otherwise, the system call succeeded.
            </summary>
            <returns>
            On success, returns the non-negative result IntPtr that was validated.
            </returns>
        </member>
        <member name="M:Interop.CheckIo``1(``0,System.String,System.Boolean,System.Func{Interop.ErrorInfo,Interop.ErrorInfo})">
            <summary>
            Validates the result of system call that returns greater than or equal to 0 on success
            and less than 0 on failure, with errno set to the error code.
            If the system call failed for any reason, an exception is thrown. Otherwise, the system call succeeded.
            </summary>
            <returns>
            On success, returns the valid SafeFileHandle that was validated.
            </returns>
        </member>
        <member name="M:Interop.GetExceptionForIoErrno(Interop.ErrorInfo,System.String,System.Boolean)">
            <summary>
            Gets an Exception to represent the supplied error info.
            </summary>
            <param name="errorInfo">The error info</param>
            <param name="path">The path with which this error is associated.  This may be null.</param>
            <param name="isDirectory">true if the <paramref name="path"/> is known to be a directory; otherwise, false.</param>
            <returns></returns>
        </member>
        <member name="M:Interop.CallStringMethod``3(System.Buffers.SpanFunc{System.Char,``0,``1,``2,Interop.Globalization.ResultCode},``0,``1,``2,System.String@)">
            <summary>
            Helper for making interop calls that return a string, but we don't know
            the correct size of buffer to make. So invoke the interop call with an
            increasing buffer until the size is big enough.
            </summary>
        </member>
    </members>
</doc>
