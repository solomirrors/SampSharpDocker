<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Collections.Concurrent</name>
    </assembly>
    <members>
        <member name="T:System.Collections.Concurrent.BlockingCollection`1">
            <summary> 
            Provides blocking and bounding capabilities for thread-safe collections that 
            implement <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>. 
            </summary>
            <remarks>
            <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/> represents a collection
            that allows for thread-safe adding and removing of data. 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> is used as a wrapper
            for an <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/> instance, allowing
            removal attempts from the collection to block until data is available to be removed.  Similarly,
            a <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> can be created to enforce
            an upper-bound on the number of data elements allowed in the 
            <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>; addition attempts to the
            collection may then block until space is available to store the added items.  In this manner,
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> is similar to a traditional
            blocking queue data structure, except that the underlying data storage mechanism is abstracted
            away as an <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>. 
            </remarks>
            <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
        </member>
        <member name="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity">
            <summary>Gets the bounded capacity of this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</summary>
            <value>The bounded capacity of this collection, or -1 if no bound was supplied.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted">
            <summary>Gets whether this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked as complete for adding.</summary>
            <value>Whether this collection has been marked as complete for adding.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted">
            <summary>Gets whether this <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked as complete for adding and is empty.</summary>
            <value>Whether this collection has been marked as complete for adding and is empty.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.BlockingCollection`1.Count">
            <summary>Gets the number of items contained in the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.</summary>
            <value>The number of items contained in the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.</value>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is synchronized.</summary>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor">
            <summary>Initializes a new instance of the 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>
            class without an upper-bound.
            </summary>
            <remarks>
            The default underlying collection is a <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1">ConcurrentQueue&lt;T&gt;</see>.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>
            class with the specified upper-bound.
            </summary>
            <param name="boundedCapacity">The bounded size of the collection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="boundedCapacity"/> is
            not a positive value.</exception>
            <remarks>
            The default underlying collection is a <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1">ConcurrentQueue&lt;T&gt;</see>.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>
            class with the specified upper-bound and using the provided 
            <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/> as its underlying data store.</summary>
            <param name="collection">The collection to use as the underlying data store.</param>
            <param name="boundedCapacity">The bounded size of the collection.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="boundedCapacity"/> is not a positive value.</exception>
            <exception cref="T:System.ArgumentException">The supplied <paramref name="collection"/> contains more values 
            than is permitted by <paramref name="boundedCapacity"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>Initializes a new instance of the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>
            class without an upper-bound and using the provided 
            <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/> as its underlying data store.</summary>
            <param name="collection">The collection to use as the underlying data store.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.Initialize(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32,System.Int32)">
            <summary>Initializes the BlockingCollection instance.</summary>
            <param name="collection">The collection to use as the underlying data store.</param>
            <param name="boundedCapacity">The bounded size of the collection.</param>
            <param name="collectionCount">The number of items currently in the underlying collection.</param>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)">
            <summary>
            Adds the item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection. The value can be a null reference.</param>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
            <remarks>
            If a bounded capacity was specified when this instance of 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> was initialized, 
            a call to Add may block until space is available to store the provided item.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)">
            <summary>
            Adds the item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled.
            </summary>
            <param name="item">The item to be added to the collection. The value can be a null reference.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
            <remarks>
            If a bounded capacity was specified when this instance of 
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> was initialized, 
            a call to <see cref="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)"/> may block until space is available to store the provided item.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)">
            <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection.</param>
            <returns>true if the <paramref name="item"/> could be added; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)">
            <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if the <paramref name="item"/> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)">
            <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item to be added to the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if the <paramref name="item"/> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Attempts to add the specified item to the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled.
            </summary>
            <param name="item">The item to be added to the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <returns>true if the <paramref name="item"/> could be added to the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.InvalidOperationException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddWithNoTimeValidation(`0,System.Int32,System.Threading.CancellationToken)">
            <summary>Adds an item into the underlying data store using its IProducerConsumerCollection&lt;T&gt;.Add 
            method. If a bounded capacity was specified and the collection was full, 
            this method will wait for, at most, the timeout period trying to add the item. 
            If the timeout period was exhausted before successfully adding the item this method will 
            return false.</summary>
            <param name="item">The item to be added to the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for the collection to accept the item,
            or Timeout.Infinite to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <returns>False if the collection remained full till the timeout period was exhausted.True otherwise.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.InvalidOperationException">the collection has already been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection didn't accept the item.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take">
            <summary>Takes an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.</summary>
            <returns>The item removed from the collection.</returns>
            <exception cref="T:System.OperationCanceledException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> is empty and has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <remarks>A call to <see cref="M:System.Collections.Concurrent.BlockingCollection`1.Take"/> may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)">
            <summary>Takes an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.</summary>
            <returns>The item removed from the collection.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is
            canceled or the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> is empty and has been marked
            as complete with regards to additions.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <remarks>A call to <see cref="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)"/> may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)">
            <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <returns>true if an item could be removed; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)">
            <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)">
            <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Attempts to remove an item from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/>.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <returns>true if an item could be removed from the collection within 
            the alloted time; otherwise, false.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">The underlying collection was modified
            outside of this <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeWithNoTimeValidation(`0@,System.Int32,System.Threading.CancellationToken,System.Threading.CancellationTokenSource)">
            <summary>Takes an item from the underlying data store using its IProducerConsumerCollection&lt;T&gt;.Take 
            method. If the collection was empty, this method will wait for, at most, the timeout period (if AddingIsCompleted is false)
            trying to remove an item. If the timeout period was exhausted before successfully removing an item 
            this method will return false.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled.
            </summary>
            <param name="item">The item removed from the collection.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for the collection to have an item available 
            for removal, or Timeout.Infinite to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <param name="combinedTokenSource">A combined cancellation token if created, it is only created by GetConsumingEnumerable to avoid creating the linked token 
            multiple times.</param>
            <returns>False if the collection remained empty till the timeout period was exhausted. True otherwise.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
            <summary>
            Adds the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array to which the item was added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
            <remarks>
            If a bounded capacity was specified when all of the
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances were initialized, 
            a call to AddToAny may block until space is available in one of the collections
            to store the provided item.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)">
            <summary>
            Adds the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled. 
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array to which the item was added.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
            <remarks>
            If a bounded capacity was specified when all of the
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances were initialized, 
            a call to AddToAny may block until space is available in one of the collections
            to store the provided item.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
            <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> 
            array to which the item was added, or -1 if the item could not be added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)">
            <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>The index of the collection in the <paramref name="collections"/> 
            array to which the item was added, or -1 if the item could not be added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)">
            <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>        /// <returns>The index of the collection in the <paramref name="collections"/> 
            array to which the item was added, or -1 if the item could not be added.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Attempts to add the specified item to any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item to be added to one of the collections.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>        
            <returns>The index of the collection in the <paramref name="collections"/> 
            array to which the item was added, or -1 if the item could not be added.</returns>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element, or at least one of collections has been
            marked as complete for adding.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">At least one underlying collection didn't accept the item.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAnyCore(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)">
            <summary>Adds an item to anyone of the specified collections.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled. 
            </summary>
            <param name="collections">The collections into which the item can be added.</param>
            <param name="item">The item to be added .</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for a collection to accept the 
            operation, or -1 to wait indefinitely.</param>
            <param name="externalCancellationToken">A cancellation token to observe.</param>
            <returns>The index into collections for the collection which accepted the 
            adding of the item; -1 if the item could not be added.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
            <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if at least one of the collections has been marked complete for adds.</exception>
            <exception cref="T:System.ObjectDisposedException">If at least one of the collections has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAnyFast(System.Collections.Concurrent.BlockingCollection{`0}[],`0)">
            <summary>
            Fast path for TryAddToAny to find a non bounded collection and add the items in it
            </summary>
            <param name="collections">The collections list</param>
            <param name="item">The item to be added</param>
            <returns>The index which the item has been added, -1 if failed</returns>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetHandles(System.Collections.Concurrent.BlockingCollection{`0}[],System.Threading.CancellationToken,System.Boolean,System.Threading.CancellationToken[]@)">
            <summary>
            Local static method, used by TryAddTakeAny to get the wait handles for the collection, with exclude option to exclude the Completed collections
            </summary>
            <param name="collections">The blocking collections</param>
            <param name="externalCancellationToken">The original CancellationToken</param>
            <param name="isAddOperation">True if Add or TryAdd, false if Take or TryTake</param>
            <param name="cancellationTokens">Complete list of cancellationTokens to observe</param>
            <returns>The collections wait handles</returns>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.UpdateTimeOut(System.UInt32,System.Int32)">
            <summary>
            Helper function to measure and update the wait time
            </summary>
            <param name="startTime"> The first time (in milliseconds) observed when the wait started</param>
            <param name="originalWaitMillisecondsTimeout">The original wait timeoutout in milliseconds</param>
            <returns>The new wait time in milliseconds, -1 if the time expired</returns>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
            <summary>
            Takes an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
            <remarks>A call to TakeFromAny may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)">
            <summary>
            Takes an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of 
            62 for STA and 63 for MTA.</exception>
            <remarks>A call to TakeFromAny may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)">
            <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
            <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)">
            <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <param name="timeout">A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds
            to wait, or a <see cref="T:System.TimeSpan"/> that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
            <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)">
            <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
            <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Attempts to remove an item from any one of the specified
            <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled. 
            </summary>
            <param name="collections">The array of collections.</param>
            <param name="item">The item removed from one of the collections.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <returns>The index of the collection in the <paramref name="collections"/> array from which 
            the item was removed, or -1 if an item could not be removed.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collections"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="collections"/> argument is
            a 0-length array or contains a null element.</exception>
            <exception cref="T:System.ObjectDisposedException">At least one of the <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances has been disposed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
            <exception cref="T:System.InvalidOperationException">At least one of the underlying collections was modified
            outside of its <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The count of <paramref name="collections"/> is greater than the maximum size of
            62 for STA and 63 for MTA.</exception>
            <remarks>A call to TryTakeFromAny may block until an item is available to be removed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAnyCore(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>Takes an item from anyone of the specified collections.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled. 
            </summary>
            <param name="collections">The collections from which the item can be removed.</param>
            <param name="item">The item removed and returned to the caller.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for a collection to accept the 
            operation, or -1 to wait indefinitely.</param>
            <param name="isTakeOperation">True if Take, false if TryTake.</param>
            <param name="externalCancellationToken">A cancellation token to observe.</param>
            <returns>The index into collections for the collection which accepted the 
            removal of the item; -1 if the item could not be removed.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
            <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if at least one of the collections has been marked complete for adds.</exception>
            <exception cref="T:System.ObjectDisposedException">If at least one of the collections has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAnyCoreSlow(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>Takes an item from anyone of the specified collections.
            A <see cref="T:System.OperationCanceledException"/> is thrown if the <see cref="T:System.Threading.CancellationToken"/> is
            canceled. 
            </summary>
            <param name="collections">The collections copy from which the item can be removed.</param>
            <param name="item">The item removed and returned to the caller.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait for a collection to accept the 
            operation, or -1 to wait indefinitely.</param>
            <param name="isTakeOperation">True if Take, false if TryTake.</param>
            <param name="externalCancellationToken">A cancellation token to observe.</param>
            <returns>The index into collections for the collection which accepted the 
            removal of the item; -1 if the item could not be removed.</returns>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
            <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
            <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if at least one of the collections has been marked complete for adds.</exception>
            <exception cref="T:System.ObjectDisposedException">If at least one of the collections has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding">
            <summary>
            Marks the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instances
            as not accepting any more additions.  
            </summary>
            <remarks>
            After a collection has been marked as complete for adding, adding to the collection is not permitted 
            and attempts to remove from the collection will not wait when the collection is empty.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.CancelWaitingConsumers">
            <summary>Cancels the semaphores.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose">
            <summary>
            Releases resources used by the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)">
            <summary>
            Releases resources used by the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance.
            </summary>
            <param name="disposing">Whether being disposed explicitly (true) or due to a finalizer (false).</param>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.ToArray">
            <summary>Copies the items from the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance into a new array.</summary>
            <returns>An array containing copies of the elements of the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <remarks>
            The copied elements are not removed from the collection.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)">
            <summary>Copies all of the items in the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance 
            to a compatible one-dimensional array, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from 
            the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance. The array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="array"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index"/> argument is less than zero.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="index"/> argument is equal to or greater 
            than the length of the <paramref name="array"/>.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies all of the items in the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance 
            to a compatible one-dimensional array, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from 
            the <see cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> instance. The array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="array"/> argument is
            null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index"/> argument is less than zero.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="index"/> argument is equal to or greater 
            than the length of the <paramref name="array"/>, the array is multidimensional, or the type parameter for the collection 
            cannot be cast automatically to the type of the destination array.</exception>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable">
            <summary>Provides a consuming <see cref="T:System.Collections.Generics.IEnumerable{T}"/> for items in the collection.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IEnumerable{T}"/> that removes and returns items from the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)">
            <summary>Provides a consuming <see cref="T:System.Collections.Generics.IEnumerable{T}"/> for items in the collection.
            Calling MoveNext on the returned enumerable will block if there is no data available, or will
            throw an <see cref="T:System.OperationCanceledException"/> if the <see cref="T:System.Threading.CancellationToken"/> is canceled.
            </summary>
            <param name="cancellationToken">A cancellation token to observe.</param>
            <returns>An <see cref="T:System.Collections.Generics.IEnumerable{T}"/> that removes and returns items from the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
            <exception cref="T:System.OperationCanceledException">If the <see cref="T:System.Threading.CancellationToken"/> is canceled.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for items in the collection.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IEnumerator{T}"/> for the items in the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.IEnumerator"/> for items in the collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for the items in the collection.</returns>
            <exception cref="T:System.ObjectDisposedException">The <see
            cref="T:System.Collections.Concurrent.BlockingCollection{T}"/> has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.ValidateCollectionsArray(System.Collections.Concurrent.BlockingCollection{`0}[],System.Boolean)">
            <summary>Centralizes the logic for validating the BlockingCollections array passed to TryAddToAny()
            and TryTakeFromAny().</summary>
            <param name="collections">The collections to/from which an item should be added/removed.</param>
            <param name="isAddOperation">Indicates whether this method is called to Add or Take.</param>
            <exception cref="T:System.ArgumentNullException">If the collections argument is null.</exception>
            <exception cref="T:System.ArgumentException">If the collections argument is a 0-length array or contains a 
            null element. Also, if at least one of the collections has been marked complete for adds.</exception>
            <exception cref="T:System.ObjectDisposedException">If at least one of the collections has been disposed.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.ValidateTimeout(System.TimeSpan)">
            <summary>Centralizes the logic of validating the timeout input argument.</summary>
            <param name="timeout">The TimeSpan to wait for to successfully complete an operation on the collection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the number of milliseconds represented by the timeout 
            TimeSpan is less than 0 or is larger than Int32.MaxValue and not Timeout.Infinite</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.ValidateMillisecondsTimeout(System.Int32)">
            <summary>Centralizes the logic of validating the millisecondsTimeout input argument.</summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait for to successfully complete an 
            operation on the collection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the number of milliseconds is less than 0 and not 
            equal to Timeout.Infinite.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollection`1.CheckDisposed">
            <summary>Throws a System.ObjectDisposedException if the collection was disposed</summary>
            <exception cref="T:System.ObjectDisposedException">If the collection has been disposed.</exception>
        </member>
        <member name="T:System.Collections.Concurrent.BlockingCollectionDebugView`1">
            <summary>A debugger view of the blocking collection that makes it simple to browse the
            collection's contents at a point in time.</summary>
            <typeparam name="T">The type of element that the BlockingCollection will hold.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.BlockingCollectionDebugView`1.#ctor(System.Collections.Concurrent.BlockingCollection{`0})">
            <summary>Constructs a new debugger view object for the provided blocking collection object.</summary>
            <param name="collection">A blocking collection to browse in the debugger.</param>
        </member>
        <member name="P:System.Collections.Concurrent.BlockingCollectionDebugView`1.Items">
            <summary>Returns a snapshot of the underlying collection's elements.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.CDSCollectionETWBCLProvider">
            <summary>Provides an event source for tracing CDS collection information.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.CDSCollectionETWBCLProvider.Log">
            <summary>
            Defines the singleton instance for the collection ETW provider.
            The collection provider GUID is {35167F8E-49B2-4b96-AB86-435B59336B5E}.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.CDSCollectionETWBCLProvider.#ctor">
            <summary>Prevent external instantiation.  All logging should go through the Log instance.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.CDSCollectionETWBCLProvider.ALL_KEYWORDS">
            <summary>Enabled for all keywords.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1">
            <summary>
            Represents a thread-safe, unordered collection of objects. 
            </summary>
            <typeparam name="T">Specifies the type of elements in the bag.</typeparam>
            <remarks>
            <para>
            Bags are useful for storing objects when ordering doesn't matter, and unlike sets, bags support
            duplicates. <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is a thread-safe bag implementation, optimized for
            scenarios where the same thread will be both producing and consuming data stored in the bag.
            </para>
            <para>
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> accepts null reference (Nothing in Visual Basic) as a valid 
            value for reference types.
            </para>
            <para>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1._locals">
            <summary>The per-bag, per-thread work-stealing queues.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1._workStealingQueues">
            <summary>The head work stealing queue in a linked list of queues.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1._emptyToNonEmptyListTransitionCount">
            <summary>Number of times any list transitions from empty to non-empty.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> class.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>
            class that contains elements copied from the specified collection.
            </summary>
            <param name="collection">The collection whose elements are copied to the new <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Add(`0)">
            <summary>
            Adds an object to the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <param name="item">The object to be added to the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The value can be a null reference
            (Nothing in Visual Basic) for reference types.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <param name="item">The object to be added to the 
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The value can be a null reference
            (Nothing in Visual Basic) for reference types.</param>
            <returns>Always returns true</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains the object
            removed from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> or the default value
            of <typeparamref name="T"/> if the operation failed.</param>
            <returns>true if an object was removed successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> without removing it.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains an object from
            the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> or the default value of
            <typeparamref name="T"/> if the operation failed.</param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetCurrentThreadWorkStealingQueue(System.Boolean)">
            <summary>Gets the work-stealing queue data structure for the current thread.</summary>
            <param name="forceCreate">Whether to create a new queue if this thread doesn't have one.</param>
            <returns>The local queue object, or null if the thread doesn't have one.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetUnownedWorkStealingQueue">
            <summary>
            Try to reuse an unowned queue.  If a thread interacts with the bag and then exits,
            the bag purposefully retains its queue, as it contains data associated with the bag.
            </summary>
            <returns>The queue object, or null if no unowned queue could be gathered.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TrySteal(`0@,System.Boolean)">
            <summary>Local helper method to steal an item from any other non empty thread.</summary>
            <param name="result">To receive the item retrieved from the bag</param>
            <param name="take">Whether to remove or peek.</param>
            <returns>True if succeeded, false otherwise.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.TryStealFromTo(System.Collections.Concurrent.ConcurrentBag{`0}.WorkStealingQueue,System.Collections.Concurrent.ConcurrentBag{`0}.WorkStealingQueue,`0@,System.Boolean)">
            <summary>
            Attempts to steal from each queue starting from <paramref name="startInclusive"/> to <paramref name="endExclusive"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> elements to an existing
            one-dimensional <see cref="T:System.Array">Array</see>, starting at the specified array
            index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The <see
            cref="T:System.Array">Array</see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- the number of elements in the source <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is greater than the available space from
            <paramref name="index"/> to the end of the destination <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.CopyFromEachQueueToArray(`0[],System.Int32)">
            <summary>Copies from each queue to the target array, starting at the specified index.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
            cref="T:System.Array"/>, starting at a particular
            <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>. The <see
            cref="T:System.Array">Array</see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see
            cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.ToArray">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> elements to a new array.
            </summary>
            <returns>A new array containing a snapshot of elements copied from the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.Clear">
            <summary>
            Removes all values from the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <returns>An enumerator for the contents of the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the bag.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <returns>An enumerator for the contents of the <see
            cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</returns>
            <remarks>
            The items enumerated represent a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any update to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>.</value>
            <remarks>
            The count returned represents a moment-in-time snapshot of the contents
            of the bag.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.DangerousCount">
            <summary>Gets the number of items stored in the bag.</summary>
            <remarks>Only provides a stable result when the bag is frozen.</remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/> is empty; otherwise, false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.GlobalQueuesLock">
            <summary>Global lock used to synchronize the queues pointer and all bag-wide operations (e.g. ToArray, Count, etc.).</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.FreezeBag(System.Boolean@)">
            <summary>"Freezes" the bag, such that no concurrent operations will be mutating the bag when it returns.</summary>
            <param name="lockTaken">true if the global lock was taken; otherwise, false.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.UnfreezeBag(System.Boolean)">
            <summary>"Unfreezes" a bag frozen with <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.FreezeBag(System.Boolean@)"/>.</summary>
            <param name="lockTaken">The result of the <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.FreezeBag(System.Boolean@)"/> method.</param>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue">
            <summary>Provides a work-stealing queue data structure stored per thread.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.InitialSize">
            <summary>Initial size of the queue's array.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.StartIndex">
            <summary>Starting index for the head and tail indices.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._headIndex">
            <summary>Head index from which to steal.  This and'd with the <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._mask"/> is the index into <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array"/>.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._tailIndex">
            <summary>Tail index at which local pushes/pops happen. This and'd with the <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._mask"/> is the index into <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array"/>.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array">
            <summary>The array storing the queue's data.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._mask">
            <summary>Mask and'd with <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._headIndex"/> and <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._tailIndex"/> to get an index into <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._array"/>.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._addTakeCount">
            <summary>Numbers of elements in the queue from the local perspective; needs to be combined with <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._stealCount"/> to get an actual Count.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._stealCount">
            <summary>Number of steals; needs to be combined with <see cref="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._addTakeCount"/> to get an actual Count.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._currentOp">
            <summary>The current queue operation. Used to quiesce before performing operations from one thread onto another.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._frozen">
            <summary>true if this queue's lock is held as part of a global freeze.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._nextQueue">
            <summary>Next queue in the <see cref="T:System.Collections.Concurrent.ConcurrentBag`1"/>'s set of thread-local queues.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue._ownerThreadId">
            <summary>Thread ID that owns this queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.#ctor(System.Collections.Concurrent.ConcurrentBag{`0}.WorkStealingQueue)">
            <summary>Initialize the WorkStealingQueue.</summary>
            <param name="nextQueue">The next queue in the linked list of work-stealing queues.</param>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.IsEmpty">
            <summary>Gets whether the queue is empty.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.LocalPush(`0,System.Int64@)">
            <summary>
            Add new item to the tail of the queue.
            </summary>
            <param name="item">The item to add.</param>
            <param name="emptyToNonEmptyListTransitionCount"></param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.LocalClear">
            <summary>Clears the contents of the local queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.TryLocalPop(`0@)">
            <summary>Remove an item from the tail of the queue.</summary>
            <param name="result">The removed item</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.TryLocalPeek(`0@)">
            <summary>Peek an item from the tail of the queue.</summary>
            <param name="result">the peeked item</param>
            <returns>True if succeeded, false otherwise</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.TrySteal(`0@,System.Boolean)">
            <summary>Steal an item from the head of the queue.</summary>
            <param name="result">the removed item</param>
            <param name="take">true to take the item; false to simply peek at it</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.DangerousCopyTo(`0[],System.Int32)">
            <summary>Copies the contents of this queue to the target array starting at the specified index.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentBag`1.WorkStealingQueue.DangerousCount">
            <summary>Gets the total number of items in the queue.</summary>
            <remarks>
            This is not thread safe, only providing an accurate result either from the owning
            thread while its lock is held or from any thread while the bag is frozen.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1.Operation">
            <summary>Lock-free operations performed on a queue.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentBag`1.Enumerator">
            <summary>Provides an enumerator for the bag.</summary>
            <remarks>
            The original implementation of ConcurrentBag used a <see cref="T:System.Collections.Generic.List`1"/> as part of
            the GetEnumerator implementation.  That list was then changed to be an array, but array's
            GetEnumerator has different behavior than does list's, in particular for the case where
            Current is used after MoveNext returns false.  To avoid any concerns around compatibility,
            we use a custom enumerator rather than just returning array's. This enumerator provides
            the essential elements of both list's and array's enumerators.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2">
            <summary>
            Represents a thread-safe collection of keys and values.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Tables">
             <summary>
             Tables that hold the internal state of the ConcurrentDictionary
            
             Wrapping the three tables in a single object allows us to atomically
             replace all tables at once.
             </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.IsValueWriteAtomic">
            <summary>
            Determines whether type TValue can be written atomically
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the default concurrency level, has the default initial capacity, and
            uses the default comparer for the key type.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level and capacity, and uses the default
            comparer for the key type.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            can contain.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="concurrencyLevel"/> is
            less than 1.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="capacity"/> is less than
            0.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see
            cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/>, has the default concurrency
            level, has the default initial capacity, and uses the default comparer for the key type.
            </summary>
            <param name="collection">The <see
            cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to
            the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> contains one or more
            duplicate keys.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level and capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>
            implementation to use when comparing keys.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see
            cref="T:System.Collections.IEnumerable"/>, has the default concurrency level, has the default
            initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="collection">The <see
            cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to
            the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>
            implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable"/>,
            has the specified concurrency level, has the specified initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="collection">The <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/> implementation to use
            when comparing keys.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="concurrencyLevel"/> is less than 1.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> contains one or more duplicate keys.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level, has the specified initial capacity, and
            uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>
            implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="concurrencyLevel"/> is less than 1. -or-
            <paramref name="capacity"/> is less than 0.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the specified key and value to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be a null reference (Nothing
            in Visual Basic) for reference types.</param>
            <returns>true if the key/value pair was added to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            contains too many elements.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> contains the specified
            key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <returns>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> contains an element with
            the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the value with the specified key from the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove and return.</param>
            <param name="value">When this method returns, <paramref name="value"/> contains the object removed from the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> or the default value of <typeparamref
            name="TValue"/>
            if the operation failed.</param>
            <returns>true if an object was removed successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemoveInternal(`0,`1@,System.Boolean,`1)">
            <summary>
            Removes the specified key from the dictionary if it exists and returns its associated value.
            If matchValue flag is set, the key will be removed only if is associated with a particular
            value.
            </summary>
            <param name="key">The key to search for and remove if it exists.</param>
            <param name="value">The variable into which the removed value, if found, is stored.</param>
            <param name="matchValue">Whether removal of the key is conditional on its value.</param>
            <param name="oldValue">The conditional value to compare against if <paramref name="matchValue"/> is true</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with the specified key from the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, <paramref name="value"/> contains the object from
            the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> with the specified key or the default value of
            <typeparamref name="TValue"/>, if the operation failed.</param>
            <returns>true if the key was found in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
            <summary>
            Updates the value associated with <paramref name="key"/> to <paramref name="newValue"/> if the existing value is equal
            to <paramref name="comparisonValue"/>.
            </summary>
            <param name="key">The key whose value is compared with <paramref name="comparisonValue"/> and
            possibly replaced.</param>
            <param name="newValue">The value that replaces the value of the element with <paramref
            name="key"/> if the comparison results in equality.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with
            <paramref name="key"/>.</param>
            <returns>true if the value with <paramref name="key"/> was equal to <paramref
            name="comparisonValue"/> and replaced with <paramref name="newValue"/>; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null
            reference.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdateInternal(`0,System.Int32,`1,`1)">
            <summary>
            Updates the value associated with <paramref name="key"/> to <paramref name="newValue"/> if the existing value is equal
            to <paramref name="comparisonValue"/>.
            </summary>
            <param name="key">The key whose value is compared with <paramref name="comparisonValue"/> and
            possibly replaced.</param>
            <param name="hashcode">The hashcode computed for <paramref name="key"/>.</param>
            <param name="newValue">The value that replaces the value of the element with <paramref
            name="key"/> if the comparison results in equality.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with
            <paramref name="key"/>.</param>
            <returns>true if the value with <paramref name="key"/> was equal to <paramref
            name="comparisonValue"/> and replaced with <paramref name="newValue"/>; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null
            reference.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
            <summary>
            Removes all keys and values from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection"/> to an array of
            type <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>, starting at the
            specified array index.
            </summary>
            <param name="array">The one-dimensional array of type <see
            cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            that is the destination of the <see
            cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/> elements copied from the <see
            cref="T:System.Collections.ICollection"/>. The array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than
            the length of the <paramref name="array"/>. -or- The number of elements in the source <see
            cref="T:System.Collections.ICollection"/>
            is greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
            <summary>
            Copies the key and value pairs stored in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> to a
            new array.
            </summary>
            <returns>A new array containing a snapshot of key and value pairs copied from the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToPairs(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
             <summary>
             Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
             Important: the caller must hold all locks in _locks before calling CopyToPairs.
             </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToEntries(System.Collections.DictionaryEntry[],System.Int32)">
             <summary>
             Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
             Important: the caller must hold all locks in _locks before calling CopyToEntries.
             </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToObjects(System.Object[],System.Int32)">
             <summary>
             Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
             Important: the caller must hold all locks in _locks before calling CopyToObjects.
             </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
            <remarks>
            The enumerator returned from the dictionary is safe to use concurrently with
            reads and writes to the dictionary, however it does not represent a moment-in-time snapshot
            of the dictionary.  The contents exposed through the enumerator may contain modifications
            made to the dictionary after <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAddInternal(`0,System.Int32,`1,System.Boolean,System.Boolean,`1@)">
            <summary>
            Shared internal implementation for inserts and updates.
            If key exists, we always return false; and if updateIfExists == true we force update with value;
            If key doesn't exist, we always add value and return true;
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <value>The value associated with the specified key. If the specified key is not found, a get
            operation throws a
            <see cref="T:System.Collections.Generic.KeyNotFoundException"/>, and a set operation creates a new
            element with the specified key.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and
            <paramref name="key"/>
            does not exist in the collection.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <value>The number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</value>
            <remarks>Count has snapshot semantics and represents the number of items in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            at the moment when Count was accessed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetCountInternal">
            <summary>
            Gets the number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>. Should only be used after all locks
            have been acquired.
            </summary>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <value>The number of key/value pairs contained in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</value>
            <remarks>Count has snapshot semantics and represents the number of items in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            at the moment when Count was accessed.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <param name="factoryArgument">An argument value to pass into <paramref name="valueFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">the value to be added, if the key does not already exist</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate``1(`0,System.Func{`0,``0,`1},System.Func{`0,`1,``0,`1},``0)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValueFactory">The function used to generate a value for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key
            based on the key's existing value</param>
            <param name="factoryArgument">An argument to pass into <paramref name="addValueFactory"/> and <paramref name="updateValueFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="addValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either be the result of addValueFactory (if the key was
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValueFactory">The function used to generate a value for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key
            based on the key's existing value</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="addValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either the result of addValueFactory (if the key was
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValue">The value to be added for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key based on
            the key's existing value</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either the value of addValue (if the key was
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> is empty; otherwise,
            false.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            Adds the specified key and value to the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <exception cref="T:System.ArgumentException">
            An element with the same key already exists in the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the element is successfully remove; otherwise false. This method also returns
            false if
            <paramref name="key"/> was not found in the original <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
            <summary>
            Gets a collection containing the keys in the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.ICollection{TKey}"/> containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable{TKey}"/> containing the keys of
            the <see cref="T:System.Collections.Generic.IReadOnlyDictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.IEnumerable{TKey}"/> containing the keys of
            the <see cref="T:System.Collections.Generic.IReadOnlyDictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
            <summary>
            Gets a collection containing the values in the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.ICollection{TValue}"/> containing the values in
            the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey,TValue}#Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable{TValue}"/> containing the values
            in the <see cref="T:System.Collections.Generic.IReadOnlyDictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.IEnumerable{TValue}"/> containing the
            values in the <see cref="T:System.Collections.Generic.IReadOnlyDictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds the specified value to the <see cref="T:System.Collections.Generic.ICollection{TValue}"/>
            with the specified key.
            </summary>
            <param name="keyValuePair">The <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            structure representing the key and value to add to the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="keyValuePair"/> of <paramref
            name="keyValuePair"/> is null.</exception>
            <exception cref="T:System.OverflowException">The <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>
            contains too many elements.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/></exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection{TKey,TValue}"/>
            contains a specific key and value.
            </summary>
            <param name="keyValuePair">The <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            structure to locate in the <see
            cref="T:System.Collections.Generic.ICollection{TValue}"/>.</param>
            <returns>true if the <paramref name="keyValuePair"/> is found in the <see
            cref="T:System.Collections.Generic.ICollection{TKey,TValue}"/>; otherwise, false.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>
            Gets a value indicating whether the dictionary is read-only.
            </summary>
            <value>true if the <see cref="T:System.Collections.Generic.ICollection{TKey,TValue}"/> is
            read-only; otherwise, false. For <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>, this property always returns
            false.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="keyValuePair">The <see
            cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            structure representing the key and value to remove from the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</param>
            <returns>true if the key and value represented by <paramref name="keyValuePair"/> is successfully
            found and removed; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">The Key property of <paramref
            name="keyValuePair"/> is a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
            <remarks>
            The enumerator returned from the dictionary is safe to use concurrently with
            reads and writes to the dictionary, however it does not represent a moment-in-time snapshot
            of the dictionary.  The contents exposed through the enumerator may contain modifications
            made to the dictionary after <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">The object to use as the key.</param>
            <param name="value">The object to use as the value.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="key"/> is of a type that is not assignable to the key type <typeparamref
            name="TKey"/> of the <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>. -or-
            <paramref name="value"/> is of a type that is not assignable to <typeparamref name="TValue"/>,
            the type of values in the <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            -or- A value with the same key already exists in the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Gets whether the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> contains an
            element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> contains
            an element with the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"> <paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.Generics.IDictionaryEnumerator"/> for the
            <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IDictionaryEnumerator"/> for the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> has a fixed size.
            </summary>
            <value>true if the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> has a
            fixed size; otherwise, false. For <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> is read-only.
            </summary>
            <value>true if the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> is
            read-only; otherwise, false. For <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing the keys of the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing the keys of the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see
            cref="T:System.Collections.IDictionary"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing the values in the <see
            cref="T:System.Collections.IDictionary"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing the values in the <see
            cref="T:System.Collections.IDictionary"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <value>The value associated with the specified key, or a null reference (Nothing in Visual Basic)
            if <paramref name="key"/> is not in the dictionary or <paramref name="key"/> is of a type that is
            not assignable to the key type <typeparamref name="TKey"/> of the <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">
            A value is being assigned, and <paramref name="key"/> is of a type that is not assignable to the
            key type <typeparamref name="TKey"/> of the <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>. -or- A value is being
            assigned, and <paramref name="key"/> is of a type that is not assignable to the value type
            <typeparamref name="TValue"/> of the <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an array, starting
            at the specified array index.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from
            the <see cref="T:System.Collections.ICollection"/>. The array must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than
            the length of the <paramref name="array"/>. -or- The number of elements in the source <see
            cref="T:System.Collections.ICollection"/>
            is greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            (thread safe); otherwise, false. For <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary{TKey,TValue}"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GrowTable(System.Collections.Concurrent.ConcurrentDictionary{`0,`1}.Tables)">
            <summary>
            Replaces the bucket table with a larger one. To prevent multiple threads from resizing the
            table as a result of races, the Tables instance that holds the table of buckets deemed too
            small is passed in as an argument to GrowTable(). GrowTable() obtains a lock, and then checks
            the Tables instance has been replaced in the meantime or not.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetBucket(System.Int32,System.Int32)">
            <summary>
            Computes the bucket for a particular key.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetBucketAndLockNo(System.Int32,System.Int32@,System.Int32@,System.Int32,System.Int32)">
            <summary>
            Computes the bucket and lock number for a particular key.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.DefaultConcurrencyLevel">
            <summary>
            The number of concurrent writes for which to optimize by default.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireAllLocks(System.Int32@)">
            <summary>
            Acquires all locks for this hash table, and increments locksAcquired by the number
            of locks that were successfully acquired. The locks are acquired in an increasing
            order.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireLocks(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Acquires a contiguous range of locks for this hash table, and increments locksAcquired
            by the number of locks that were successfully acquired. The locks are acquired in an
            increasing order.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ReleaseLocks(System.Int32,System.Int32)">
            <summary>
            Releases a contiguous range of locks.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetKeys">
            <summary>
            Gets a collection containing the keys in the dictionary.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetValues">
            <summary>
            Gets a collection containing the values in the dictionary.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Node">
            <summary>
            A node in a singly-linked list representing a particular hash table bucket.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.DictionaryEnumerator">
            <summary>
            A private class to represent enumeration over the dictionary that implements the
            IDictionaryEnumerator interface.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentStack`1">
            <summary>
            Represents a thread-safe last-in, first-out collection of objects.
            </summary>
            <typeparam name="T">Specifies the type of elements in the stack.</typeparam>
            <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentStack`1.Node">
            <summary>
            A simple (internal) node type used to store elements of concurrent stacks and queues.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Node.#ctor(`0)">
            <summary>
            Constructs a new node with the specified value and no next node.
            </summary>
            <param name="value">The value of the node.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            class.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            class that contains elements copied from the specified collection
            </summary>
            <param name="collection">The collection whose elements are copied to the new <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.InitializeFromCollection(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes the contents of the stack from an existing collection.
            </summary>
            <param name="collection">A collection from which to copy elements.</param>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> is empty; otherwise, false.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.Count"/> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty"/> returns, thus invalidating
            the result.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</value>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty"/>
            property is recommended rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentStack`1.Count"/>
            property and comparing it to 0.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Clear">
            <summary>
            Removes all objects from the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
            cref="T:System.Array"/>, starting at a particular
            <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
            the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>. The <see cref="T:System.Array"/> must
            have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see
            cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> elements to an existing one-dimensional <see
            cref="T:System.Array"/>, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
            the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>. The <see cref="T:System.Array"/> must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref
            name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)">
            <summary>
            Inserts an object at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <param name="item">The object to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>. The value can be
            a null reference (Nothing in Visual Basic) for reference types.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])">
            <summary>
            Inserts multiple objects at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> atomically.
            </summary>
            <param name="items">The objects to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <remarks>
            When adding multiple items to the stack, using PushRange is a more efficient
            mechanism than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)"/> one item at a time.  Additionally, PushRange
            guarantees that all of the elements will be added atomically, meaning that no other threads will
            be able to inject elements between the elements being pushed.  Items at lower indices in
            the <paramref name="items"/> array will be pushed before items at higher indices.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)">
            <summary>
            Inserts multiple objects at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> atomically.
            </summary>
            <param name="items">The objects to push onto the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <param name="startIndex">The zero-based offset in <paramref name="items"/> at which to begin
            inserting elements onto the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <param name="count">The number of elements to be inserted onto the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> or <paramref
            name="count"/> is negative. Or <paramref name="startIndex"/> is greater than or equal to the length 
            of <paramref name="items"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="startIndex"/> + <paramref name="count"/> is
            greater than the length of <paramref name="items"/>.</exception>
            <remarks>
            When adding multiple items to the stack, using PushRange is a more efficient
            mechanism than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)"/> one item at a time. Additionally, PushRange
            guarantees that all of the elements will be added atomically, meaning that no other threads will
            be able to inject elements between the elements being pushed. Items at lower indices in the
            <paramref name="items"/> array will be pushed before items at higher indices.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.PushCore(System.Collections.Concurrent.ConcurrentStack{`0}.Node,System.Collections.Concurrent.ConcurrentStack{`0}.Node)">
            <summary>
            Push one or many nodes into the stack, if head and tails are equal then push one node to the stack other wise push the list between head
            and tail to the stack
            </summary>
            <param name="head">The head pointer to the new list</param>
            <param name="tail">The tail pointer to the new list</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ValidatePushPopRangeInput(`0[],System.Int32,System.Int32)">
            <summary>
            Local helper function to validate the Pop Push range methods input
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
            </summary>
            <param name="item">The object to add to the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>. The value can be a null
            reference (Nothing in Visual Basic) for reference types.
            </param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>, this operation
            will always insert the object onto the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            and return true.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            without removing it.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains an object from
            the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack{T}"/> or an
            unspecified value if the operation failed.</param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)">
            <summary>
            Attempts to pop and return the object at the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <param name="result">
            When this method returns, if the operation was successful, <paramref name="result"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])">
            <summary>
            Attempts to pop and return multiple objects from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            atomically.
            </summary>
            <param name="items">
            The <see cref="T:System.Array"/> to which objects popped from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> will be added.
            </param>
            <returns>The number of objects successfully popped from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> and inserted in
            <paramref name="items"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null argument (Nothing
            in Visual Basic).</exception>
            <remarks>
            When popping multiple items, if there is little contention on the stack, using
            TryPopRange can be more efficient than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)"/>
            once per item to be removed.  Nodes fill the <paramref name="items"/>
            with the first node to be popped at the startIndex, the second node to be popped
            at startIndex + 1, and so on.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)">
            <summary>
            Attempts to pop and return multiple objects from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>
            atomically.
            </summary>
            <param name="items">
            The <see cref="T:System.Array"/> to which objects popped from the top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> will be added.
            </param>
            <param name="startIndex">The zero-based offset in <paramref name="items"/> at which to begin
            inserting elements from the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</param>
            <param name="count">The number of elements to be popped from top of the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> and inserted into <paramref name="items"/>.</param>
            <returns>The number of objects successfully popped from the top of 
            the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> and inserted in <paramref name="items"/>.</returns>        
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> or <paramref
            name="count"/> is negative. Or <paramref name="startIndex"/> is greater than or equal to the length 
            of <paramref name="items"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="startIndex"/> + <paramref name="count"/> is
            greater than the length of <paramref name="items"/>.</exception>
            <remarks>
            When popping multiple items, if there is little contention on the stack, using
            TryPopRange can be more efficient than using <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)"/>
            once per item to be removed.  Nodes fill the <paramref name="items"/>
            with the first node to be popped at the startIndex, the second node to be popped
            at startIndex + 1, and so on.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopCore(`0@)">
            <summary>
            Local helper function to Pop an item from the stack, slow path
            </summary>
            <param name="result">The popped item</param>
            <returns>True if succeeded, false otherwise</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopCore(System.Int32,System.Collections.Concurrent.ConcurrentStack{`0}.Node@)">
            <summary>
            Slow path helper for TryPop. This method assumes an initial attempt to pop an element
            has already occurred and failed, so it begins spinning right away.
            </summary>
            <param name="count">The number of items to pop.</param>
            <param name="poppedHead">
            When this method returns, if the pop succeeded, contains the removed object. If no object was
            available to be removed, the value is unspecified. This parameter is passed uninitialized.
            </param>
            <returns>The number of objects successfully popped from the top of
            the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.CopyRemovedItems(System.Collections.Concurrent.ConcurrentStack{`0}.Node,`0[],System.Int32,System.Int32)">
            <summary>
            Local helper function to copy the popped elements into a given collection
            </summary>
            <param name="head">The head of the list to be copied</param>
            <param name="collection">The collection to place the popped items in</param>
            <param name="startIndex">the beginning of index of where to place the popped items</param>
            <param name="nodesCount">The number of nodes.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see
            cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
            </summary>
            <param name="item">
            When this method returns, if the operation was successful, <paramref name="item"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>, this operation will attempt to pope the object at
            the top of the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToArray">
            <summary>
            Copies the items stored in the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/> to a new array.
            </summary>
            <returns>A new array containing a snapshot of elements copied from the <see
            cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToList">
            <summary>
            Returns an array containing a snapshot of the list's contents, using
            the target list node as the head of a region in the list.
            </summary>
            <returns>A list of the stack's contents.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.ToList(System.Collections.Concurrent.ConcurrentStack{`0}.Node)">
            <summary>
            Returns an array containing a snapshot of the list's contents starting at the specified node.
            </summary>
            <returns>A list of the stack's contents starting at the specified node.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.
            </summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentStack`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the stack.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the stack.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through
            the collection.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents of the stack. It does not
            reflect any updates to the collection after
            <see cref="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator"/> was called. The enumerator is safe to use concurrently with reads
            from and writes to the stack.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.OrderablePartitioner`1">
            <summary>
            Represents a particular manner of splitting an orderable data source into multiple partitions.
            </summary>
            <typeparam name="TSource">Type of the elements in the collection.</typeparam>
            <remarks>
            <para>
            Each element in each partition has an integer index associated with it, which determines the relative
            order of that element against elements in other partitions.
            </para>
            <para>
            Inheritors of <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1"/> must adhere to the following rules:
            <ol>
            <li>All indices must be unique, such that there may not be duplicate indices. If all indices are not
            unique, the output ordering may be scrambled.</li>
            <li>All indices must be non-negative. If any indices are negative, consumers of the implementation
            may throw exceptions.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/> should throw a
            <see cref="T:System.ArgumentOutOfRangeException"/> if the requested partition count is less than or
            equal to zero.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/> should always return a number
            of enumerables equal to the requested partition count. If the partitioner runs out of data and cannot
            create as many partitions as requested, an empty enumerator should be returned for each of the
            remaining partitions. If this rule is not followed, consumers of the implementation may throw a <see
            cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/>, <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/>,
            <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions"/>, and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/>
            should never return null. If null is returned, a consumer of the implementation may throw a
            <see cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)"/>, <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/>,
            <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions"/>, and <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/>
            should always return partitions that can fully and uniquely enumerate the input data source. All of
            the data and only the data contained in the input source should be enumerated, with no duplication
            that was not already in the input, unless specifically required by the particular partitioner's
            design. If this is not followed, the output ordering may be scrambled.</li>
            <li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition"/> returns true, each partition must return elements
            with increasing key indices.</li>
            <li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions"/> returns true, all the keys in partition numbered N
            must be larger than all the keys in partition numbered N-1.</li>
            <li>If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized"/> returns true, all indices must be monotonically increasing from
            0, though not necessarily within a single partition.</li>
            </ol>
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1"/> class with the
            specified constraints on the index keys.
            </summary>
            <param name="keysOrderedInEachPartition">
            Indicates whether the elements in each partition are yielded in the order of
            increasing keys.
            </param>
            <param name="keysOrderedAcrossPartitions">
            Indicates whether elements in an earlier partition always come before
            elements in a later partition. If true, each element in partition 0 has a smaller order key than
            any element in partition 1, each element in partition 1 has a smaller order key than any element
            in partition 2, and so on.
            </param>
            <param name="keysNormalized">
            Indicates whether keys are normalized. If true, all order keys are distinct
            integers in the range [0 .. numberOfElements-1]. If false, order keys must still be distinct, but
            only their relative order is considered, not their absolute values.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)">
            <summary>
            Partitions the underlying collection into the specified number of orderable partitions.
            </summary>
            <remarks>
            Each partition is represented as an enumerator over key-value pairs.
            The value of the pair is the element itself, and the key is an integer which determines
            the relative ordering of this element against other elements in the data source.
            </remarks>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
            <remarks>
            <para>
            The returned object implements the <see
            cref="T:System.Collections.Generic.IEnumerable{TSource}"/> interface. Calling <see
            cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
            <para>
            Each partition is represented as an enumerator over key-value pairs. The value in the pair is the element
            itself, and the key is an integer which determines the relative ordering of this element against
            other elements.
            </para>
            <para>
            The <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/> method is only supported if the <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">SupportsDynamicPartitions</see>
            property returns true.
            </para>
            </remarks>
            <returns>An object that can create partitions over the underlying data source.</returns>
            <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition">
            <summary>
            Gets whether elements in each partition are yielded in the order of increasing keys.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions">
            <summary>
            Gets whether elements in an earlier partition always come before elements in a later partition.
            </summary>
            <remarks>
            If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions"/> returns true, each element in partition 0 has a
            smaller order key than any element in partition 1, each element in partition 1 has a smaller
            order key than any element in partition 2, and so on.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized">
            <summary>
            Gets whether order keys are normalized.
            </summary>
            <remarks>
            If <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized"/> returns true, all order keys are distinct integers in the range
            [0 .. numberOfElements-1]. If the property returns false, order keys must still be distinct, but
            only their relative order is considered, not their absolute values.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions(System.Int32)">
            <summary>
            Partitions the underlying collection into the given number of ordered partitions.
            </summary>
            <remarks>
            The default implementation provides the same behavior as <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions(System.Int32)"/> except
            that the returned set of partitions does not provide the keys for the elements.
            </remarks>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
            <remarks>
            <para>
            The returned object implements the <see
            cref="T:System.Collections.Generic.IEnumerable{TSource}"/> interface. Calling <see
            cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
            <para>
            The default implementation provides the same behavior as <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions"/> except
            that the returned set of partitions does not provide the keys for the elements.
            </para>
            <para>
            The <see cref="M:System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions"/> method is only supported if the <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/>
            property returns true.
            </para>
            </remarks>
            <returns>An object that can create partitions over the underlying data source.</returns>
            <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
        </member>
        <member name="T:System.Collections.Concurrent.OrderablePartitioner`1.EnumerableDropIndices">
            <summary>
            Converts an enumerable over key-value pairs to an enumerable over values.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner`1">
            <summary>
            Represents a particular manner of splitting a data source into multiple partitions.
            </summary>
            <typeparam name="TSource">Type of the elements in the collection.</typeparam>
            <remarks>
            <para>
            Inheritors of <see cref="T:System.Collections.Concurrent.Partitioner`1"/> must adhere to the following rules:
            <ol>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> should throw a
            <see cref="T:System.ArgumentOutOfRangeException"/> if the requested partition count is less than or
            equal to zero.</li>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> should always return a number of enumerables equal to the requested
            partition count. If the partitioner runs out of data and cannot create as many partitions as 
            requested, an empty enumerator should be returned for each of the remaining partitions. If this rule
            is not followed, consumers of the implementation may throw a <see
            cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/>
            should never return null. If null is returned, a consumer of the implementation may throw a
            <see cref="T:System.InvalidOperationException"/>.</li>
            <li><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)"/> and <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/> should always return
            partitions that can fully and uniquely enumerate the input data source. All of the data and only the
            data contained in the input source should be enumerated, with no duplication that was not already in
            the input, unless specifically required by the particular partitioner's design. If this is not
            followed, the output ordering may be scrambled.</li>
            </ol>
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)">
            <summary>
            Partitions the underlying collection into the given number of partitions.
            </summary>
            <param name="partitionCount">The number of partitions to create.</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions">
            <summary>
            Gets whether additional partitions can be created dynamically.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Concurrent.Partitioner`1"/> can create partitions dynamically as they are
            requested; false if the <see cref="T:System.Collections.Concurrent.Partitioner`1"/> can only allocate
            partitions statically.
            </returns>
            <remarks>
            <para>
            If a derived class does not override and implement <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/>,
            <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/> should return false. The value of <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/> should not vary over the lifetime of this instance.
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions">
            <summary>
            Creates an object that can partition the underlying collection into a variable number of
            partitions.
            </summary>
            <remarks>
            <para>
            The returned object implements the <see
            cref="T:System.Collections.Generic.IEnumerable{TSource}"/> interface. Calling <see
            cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">GetEnumerator</see> on the
            object creates another partition over the sequence.
            </para>
            <para>
            The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions"/> method is only supported if the <see
            cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions"/>
            property returns true.
            </para>
            </remarks>
            <returns>An object that can create partitions over the underlying data source.</returns>
            <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this
            partitioner.</exception>
        </member>
        <member name="T:System.Collections.Concurrent.EnumerablePartitionerOptions">
            <summary>
            Out-of-the-box partitioners are created with a set of default behaviors.  
            For example, by default, some form of buffering and chunking will be employed to achieve 
            optimal performance in the common scenario where an <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementation is fast and 
            non-blocking.  These behaviors can be overridden via this enumeration.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.None">
            <summary>
            Use the default behavior (i.e., use buffering to achieve optimal performance)
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.EnumerablePartitionerOptions.NoBuffering">
            <summary>
            Creates a partitioner that will take items from the source enumerable one at a time
            and will not use intermediate storage that can be accessed more efficiently by multiple threads.  
            This option provides support for low latency (items will be processed as soon as they are available from 
            the source) and partial support for dependencies between items (a thread cannot deadlock waiting for an item 
            that it, itself, is responsible for processing).
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner">
            <summary>
            Provides common partitioning strategies for arrays, lists, and enumerables.
            </summary>
            <remarks>
            <para>
            The static methods on <see cref="T:System.Collections.Concurrent.Partitioner"/> are all thread-safe and may be used concurrently
            from multiple threads. However, while a created partitioner is in use, the underlying data source
            should not be modified, whether from the same thread that's using a partitioner or from a separate
            thread.
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>
            Creates an orderable partitioner from an <see cref="T:System.Collections.Generic.IList`1"/>
            instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source list.</typeparam>
            <param name="list">The list to be partitioned.</param>
            <param name="loadBalance">
            A Boolean value that indicates whether the created partitioner should dynamically
            load balance between partitions rather than statically partition.
            </param>
            <returns>
            An orderable partitioner based on the input list.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(``0[],System.Boolean)">
            <summary>
            Creates an orderable partitioner from a <see cref="T:System.Array"/> instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source array.</typeparam>
            <param name="array">The array to be partitioned.</param>
            <param name="loadBalance">
            A Boolean value that indicates whether the created partitioner should dynamically load balance
            between partitions rather than statically partition.
            </param>
            <returns>
            An orderable partitioner based on the input array.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an orderable partitioner from a <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source enumerable.</typeparam>
            <param name="source">The enumerable to be partitioned.</param>
            <returns>
            An orderable partitioner based on the input array.
            </returns>
            <remarks>
            The ordering used in the created partitioner is determined by the natural order of the elements 
            as retrieved from the source enumerable.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Concurrent.EnumerablePartitionerOptions)">
            <summary>
            Creates an orderable partitioner from a <see cref="T:System.Collections.Generic.IEnumerable`1"/> instance.
            </summary>
            <typeparam name="TSource">Type of the elements in source enumerable.</typeparam>
            <param name="source">The enumerable to be partitioned.</param>
            <param name="partitionerOptions">Options to control the buffering behavior of the partitioner.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="partitionerOptions"/> argument specifies an invalid value for <see
            cref="T:System.Collections.Concurrent.EnumerablePartitionerOptions"/>.
            </exception>
            <returns>
            An orderable partitioner based on the input array.
            </returns>
            <remarks>
            The ordering used in the created partitioner is determined by the natural order of the elements 
            as retrieved from the source enumerable.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is 
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int64,System.Int64,System.Int64)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <param name="rangeSize">The size of each subrange.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is 
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="rangeSize"/> argument is 
            less than or equal to 0.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is 
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.Create(System.Int32,System.Int32,System.Int32)">
            <summary>Creates a partitioner that chunks the user-specified range.</summary>
            <param name="fromInclusive">The lower, inclusive bound of the range.</param>
            <param name="toExclusive">The upper, exclusive bound of the range.</param>
            <param name="rangeSize">The size of each subrange.</param>
            <returns>A partitioner.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="toExclusive"/> argument is 
            less than or equal to the <paramref name="fromInclusive"/> argument.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> The <paramref name="rangeSize"/> argument is 
            less than or equal to 0.</exception>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2">
            <summary>
            DynamicPartitionEnumerator_Abstract defines the enumerator for each partition for the dynamic load-balance
            partitioning algorithm. 
            - Partition is an enumerator of KeyValuePairs, each corresponding to an item in the data source: 
              the key is the index in the source collection; the value is the item itself.
            - a set of such partitions share a reader over data source. The type of the reader is specified by
              TSourceReader. 
            - each partition requests a contiguous chunk of elements at a time from the source data. The chunk 
              size is initially 1, and doubles every time until it reaches the maximum chunk size. 
              The implementation for GrabNextChunk() method has two versions: one for data source of IndexRange 
              types (IList and the array), one for data source of IEnumerable.
            - The method "Reset" is not supported for any partitioning algorithm.
            - The implementation for MoveNext() method is same for all dynamic partitioners, so we provide it
              in this abstract class.
            </summary>
            <typeparam name="TSource">Type of the elements in the data source</typeparam>
            <typeparam name="TSourceReader">Type of the reader on the data source</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.GrabNextChunk(System.Int32)">
            <summary>
            Abstract method to request a contiguous chunk of elements from the source collection
            </summary>
            <param name="requestedChunkSize">specified number of elements requested</param>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize) 
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.HasNoElementsLeft">
            <summary>
            Abstract property, returns whether or not the shared reader has already read the last 
            element of the source data 
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Current">
            <summary>
            Get the current element in the current partition. Property required by IEnumerator interface
            This property is abstract because the implementation is different depending on the type
            of the source data: IList, Array or IEnumerable
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Dispose">
            <summary>
            Dispose is abstract, and depends on the type of the source data:
            - For source data type IList and Array, the type of the shared reader is just the data itself.
              We don't do anything in Dispose method for IList and Array. 
            - For source data type IEnumerable, the type of the shared reader is an enumerator we created.
              Thus we need to dispose this shared reader enumerator, when there is no more active partitions
              left.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.Reset">
            <summary>
            Reset on partitions is not supported
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.System#Collections#IEnumerator#Current">
            <summary>
            Get the current element in the current partition. Property required by IEnumerator interface
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract`2.MoveNext">
            <summary>
            Moves to the next element if any.
            Try current chunk first, if the current chunk do not have any elements left, then we 
            attempt to grab a chunk from the source collection.
            </summary>
            <returns>
            true if successfully moving to the next position;
            false otherwise, if and only if there is no more elements left in the current chunk 
            AND the source collection is exhausted. 
            </returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1">
            <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForIEnumerator defined internally
            </summary>
            <typeparam name="TSource">Type of elements in the source data</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.GetOrderablePartitions(System.Int32)">
            <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions.
            Partitions the underlying collection into the given number of orderable partitions.
            </summary>
            <param name="partitionCount">number of partitions requested</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.GetOrderableDynamicPartitions">
            <summary>
            Overrides OrderablePartitioner.GetOrderableDynamicPartitions
            </summary>
            <returns>a enumerable collection of orderable partitions</returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.SupportsDynamicPartitions">
            <summary>
            Whether additional partitions can be created dynamically.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable">
            <summary>
            Provides customized implementation for source data of IEnumerable
            Different from the counterpart for IList/Array, this enumerable maintains several additional fields
            shared by the partitions it owns, including a boolean "_hasNoElementsLef", a shared lock, and a 
            shared count "_activePartitionCount" used to track active partitions when they were created statically
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable.GrabChunk(System.Collections.Generic.KeyValuePair{System.Int64,`0}[],System.Int32,System.Int32@)">
            <summary>
            This is the common entry point for consuming items from the source enumerable
            </summary>
            <returns>
            true if we successfully reserved at least one element 
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable.GrabChunk_Single(System.Collections.Generic.KeyValuePair{System.Int64,`0}[],System.Int32,System.Int32@)">
            <summary>
            Version of GrabChunk that grabs a single element at a time from the source enumerable
            </summary>
            <returns>
            true if we successfully reserved an element 
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerable.GrabChunk_Buffered(System.Collections.Generic.KeyValuePair{System.Int64,`0}[],System.Int32,System.Int32@)">
            <summary>
            Version of GrabChunk that uses buffering scheme to grab items out of source enumerable
            </summary>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize) 
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator">
            <summary>
            Inherits from DynamicPartitionEnumerator_Abstract directly
            Provides customized implementation for: GrabNextChunk, HasNoElementsLeft, Current, Dispose
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator.GrabNextChunk(System.Int32)">
            <summary>
            Reserves a contiguous range of elements from source data
            </summary>
            <param name="requestedChunkSize">specified number of elements requested</param>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize) 
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable`1.InternalPartitionEnumerator.HasNoElementsLeft">
            <summary>
            Returns whether or not the shared reader has already read the last 
            element of the source data 
            </summary>
            <remarks>
            We cannot call _sharedReader.MoveNext(), to see if it hits the last element
            or not, because we can't undo MoveNext(). Thus we need to maintain a shared 
            boolean value _hasNoElementsLeft across all partitions
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2">
            <summary>
            Dynamic load-balance partitioner. This class is abstract and to be derived from by 
            the customized partitioner classes for IList, Array, and IEnumerable
            </summary>
            <typeparam name="TSource">Type of the elements in the source data</typeparam>
            <typeparam name="TCollection"> Type of the source data collection</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.#ctor(`1)">
            <summary>
            Constructs a new orderable partitioner 
            </summary>
            <param name="data">source data collection</param>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderableDynamicPartitions_Factory(`1)">
            <summary>
            Partition the source data and create an enumerable over the resulting partitions. 
            </summary>
            <param name="data">the source data collection</param>
            <returns>an enumerable of partitions of </returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderablePartitions(System.Int32)">
            <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions.
            Partitions the underlying collection into the given number of orderable partitions.
            </summary>
            <param name="partitionCount">number of partitions requested</param>
            <returns>A list containing <paramref name="partitionCount"/> enumerators.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.GetOrderableDynamicPartitions">
            <summary>
            Overrides OrderablePartitioner.GetOrderableDynamicPartitions
            </summary>
            <returns>a enumerable collection of orderable partitions</returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract`2.SupportsDynamicPartitions">
            <summary>
            Whether additional partitions can be created dynamically.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2">
            <summary>
            Defines dynamic partition for source data of IList and Array. 
            This class inherits DynamicPartitionEnumerator_Abstract
              - implements GrabNextChunk, HasNoElementsLeft, and Dispose methods for IList and Array
              - Current property still remains abstract, implementation is different for IList and Array
              - introduces another abstract method SourceCount, which returns the number of elements in
                the source data. Implementation differs for IList and Array
            </summary>
            <typeparam name="TSource">Type of the elements in the data source</typeparam>
            <typeparam name="TSourceReader">Type of the reader on the source data</typeparam>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.SourceCount">
            <summary>
            Get the number of elements from the source reader.
            It calls IList.Count or Array.Length
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.GrabNextChunk(System.Int32)">
            <summary>
            Reserves a contiguous range of elements from source data
            </summary>
            <param name="requestedChunkSize">specified number of elements requested</param>
            <returns>
            true if we successfully reserved at least one element (up to #=requestedChunkSize) 
            false if all elements in the source collection have been reserved.
            </returns>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.HasNoElementsLeft">
            <summary>
            Returns whether or not the shared reader has already read the last 
            element of the source data 
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract`2.Dispose">
            <summary>
            For source data type IList and Array, the type of the shared reader is just the data itself.
            We don't do anything in Dispose method for IList and Array. 
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1">
            <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForIList defined internally
            </summary>
            <typeparam name="TSource">Type of elements in the source data</typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerable">
            <summary>
            Inherits from PartitionList_Abstract 
            Provides customized implementation for source data of IList
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerator">
            <summary>
            Inherits from DynamicPartitionEnumeratorForIndexRange_Abstract
            Provides customized implementation of SourceCount property and Current property for IList
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.DynamicPartitionerForIList`1.InternalPartitionEnumerator.Current">
            <summary>
            return a KeyValuePair of the current element and its key 
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1">
            <summary>
            Inherits from DynamicPartitioners
            Provides customized implementation of GetOrderableDynamicPartitions_Factory method, to return an instance
            of EnumerableOfPartitionsForArray defined internally
            </summary>
            <typeparam name="TSource">Type of elements in the source data</typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1.InternalPartitionEnumerable">
            <summary>
            Inherits from PartitionList_Abstract 
            Provides customized implementation for source data of Array
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.DynamicPartitionerForArray`1.InternalPartitionEnumerator">
            <summary>
            Inherits from DynamicPartitionEnumeratorForIndexRange_Abstract
            Provides customized implementation of SourceCount property and Current property for Array
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2">
            <summary>
            Static partitioning over IList. 
            - dynamic and load-balance
            - Keys are ordered within each partition
            - Keys are ordered across partitions
            - Keys are normalized
            - Number of partitions is fixed once specified, and the elements of the source data are 
            distributed to each partition as evenly as possible. 
            </summary>
            <typeparam name="TSource">type of the elements</typeparam>        
            <typeparam name="TCollection">Type of the source data collection</typeparam>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.SourceCount">
            <summary>
            Abstract method to return the number of elements in the source data
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.CreatePartition(System.Int32,System.Int32)">
            <summary>
            Abstract method to create a partition that covers a range over source data, 
            starting from "startIndex", ending at "endIndex"
            </summary>
            <param name="startIndex">start index of the current partition on the source data</param>
            <param name="endIndex">end index of the current partition on the source data</param>
            <returns>a partition enumerator over the specified range</returns>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner`2.GetOrderablePartitions(System.Int32)">
            <summary>
            Overrides OrderablePartitioner.GetOrderablePartitions
            Return a list of partitions, each of which enumerate a fixed part of the source data
            The elements of the source data are distributed to each partition as evenly as possible. 
            Specifically, if the total number of elements is N, and number of partitions is x, and N = a*x +b, 
            where a is the quotient, and b is the remainder. Then the first b partitions each has a + 1 elements,
            and the last x-b partitions each has a elements.
            For example, if N=10, x =3, then 
               partition 0 ranges [0,3],
               partition 1 ranges [4,6],
               partition 2 ranges [7,9].
            This also takes care of the situation of (x&gt;N), the last x-N partitions are empty enumerators. 
            An empty enumerator is indicated by 
                 (_startIndex == list.Count &amp;&amp; _endIndex == list.Count -1)
            </summary>
            <param name="partitionCount">specified number of partitions</param>
            <returns>a list of partitions</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1">
            <summary>
            Static Partition for IList/Array.
            This class implements all methods required by IEnumerator interface, except for the Current property.
            Current Property is different for IList and Array. Arrays calls 'ldelem' instructions for faster element 
            retrieval.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an instance of StaticIndexRangePartition
            </summary>
            <param name="startIndex">the start index in the source collection for the current partition </param>
            <param name="endIndex">the end index in the source collection for the current partition</param>
        </member>
        <member name="P:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.Current">
            <summary>
            Current Property is different for IList and Array. Arrays calls 'ldelem' instructions for faster 
            element retrieval.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.Dispose">
            <summary>
            We don't dispose the source for IList and array
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.Partitioner.StaticIndexRangePartition`1.MoveNext">
            <summary>
            Moves to the next item
            Before the first MoveNext is called: _offset == _startIndex-1;
            </summary>
            <returns>true if successful, false if there is no item left</returns>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionerForIList`1">
            <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionForIList`1">
            <summary>
            Inherits from StaticIndexRangePartition
            Provides customized implementation of Current property
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionerForArray`1">
            <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition for Array
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.StaticIndexRangePartitionForArray`1">
            <summary>
            Inherits from StaticIndexRangePartitioner
            Provides customized implementation of SourceCount and CreatePartition
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.SharedInt">
            <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.SharedBool">
            <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.Partitioner.SharedLong">
            <summary>
            A very simple primitive that allows us to share a value across multiple threads.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1">
            <summary>
            A debugger view of the IProducerConsumerCollection that makes it simple to browse the
            collection's contents at a point in time.
            </summary>
            <typeparam name="T">The type of elements stored within.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Constructs a new debugger view object for the provided collection object.
            </summary>
            <param name="collection">A collection to browse in the debugger.</param>
        </member>
        <member name="P:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.Items">
            <summary>
            Returns a snapshot of the underlying collection's elements.
            </summary>
        </member>
        <member name="T:System.Threading.PlatformHelper">
            <summary>
            A helper class to get the number of processors, it updates the number of processors every sampling interval
            </summary>
        </member>
        <member name="P:System.Threading.PlatformHelper.ProcessorCount">
            <summary>
            Gets the number of available processors
            </summary>
        </member>
        <member name="P:System.SR.BlockingCollection_Add_ConcurrentCompleteAdd">
            <summary>CompleteAdding may not be used concurrently with additions to the collection.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_Add_Failed">
            <summary>The underlying collection didn't accept the item.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_CantAddAnyWhenCompleted">
            <summary>At least one of the specified collections is marked as complete with regards to additions.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_CantTakeAnyWhenAllDone">
            <summary>All collections are marked as complete with regards to additions.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_CantTakeWhenDone">
            <summary>The collection argument is empty and has been marked as complete with regards to additions.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_Completed">
            <summary>The collection has been marked as complete with regards to additions.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_CopyTo_IncorrectType">
            <summary>The array argument is of the incorrect type.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_CopyTo_MultiDim">
            <summary>The array argument is multidimensional.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_CopyTo_NonNegative">
            <summary>The index argument must be greater than or equal zero.</summary>
        </member>
        <member name="P:System.SR.Collection_CopyTo_TooManyElems">
            <summary>The number of elements in the collection is greater than the available space from index to the end of the destination array.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_ctor_BoundedCapacityRange">
            <summary>The boundedCapacity argument must be positive.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_ctor_CountMoreThanCapacity">
            <summary>The collection argument contains more items than are allowed by the boundedCapacity.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_Disposed">
            <summary>The collection has been disposed.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_Take_CollectionModified">
            <summary>The underlying collection was modified from outside of the BlockingCollection&lt;T&gt;.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_TimeoutInvalid">
            <summary>The specified timeout must represent a value between -1 and {0}, inclusive.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_ValidateCollectionsArray_DispElems">
            <summary>The collections argument contains at least one disposed element.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_ValidateCollectionsArray_LargeSize">
            <summary>The collections length is greater than the supported range for 32 bit machine.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_ValidateCollectionsArray_NullElems">
            <summary>The collections argument contains at least one null element.</summary>
        </member>
        <member name="P:System.SR.BlockingCollection_ValidateCollectionsArray_ZeroSize">
            <summary>The collections argument is a zero-length array.</summary>
        </member>
        <member name="P:System.SR.Common_OperationCanceled">
            <summary>The operation was canceled.</summary>
        </member>
        <member name="P:System.SR.ConcurrentBag_Ctor_ArgumentNullException">
            <summary>The collection argument is null.</summary>
        </member>
        <member name="P:System.SR.ConcurrentBag_CopyTo_ArgumentNullException">
            <summary>The array argument is null.</summary>
        </member>
        <member name="P:System.SR.Collection_CopyTo_ArgumentOutOfRangeException">
            <summary>The index argument must be greater than or equal zero.</summary>
        </member>
        <member name="P:System.SR.ConcurrentCollection_SyncRoot_NotSupported">
            <summary>The SyncRoot property may not be used for the synchronization of concurrent collections.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_ArrayIncorrectType">
            <summary>The array is multidimensional, or the type parameter for the set cannot be cast automatically to the type of the destination array.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_SourceContainsDuplicateKeys">
            <summary>The source argument contains duplicate keys.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_ConcurrencyLevelMustBePositive">
            <summary>The concurrencyLevel argument must be positive.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_CapacityMustNotBeNegative">
            <summary>The capacity argument must be greater than or equal to zero.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_IndexIsNegative">
            <summary>The index argument is less than zero.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_ArrayNotLargeEnough">
            <summary>The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_KeyAlreadyExisted">
            <summary>The key already existed in the dictionary.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_ItemKeyIsNull">
            <summary>TKey is a reference type and item.Key is null.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_TypeOfKeyIncorrect">
            <summary>The key was of an incorrect type for this dictionary.</summary>
        </member>
        <member name="P:System.SR.ConcurrentDictionary_TypeOfValueIncorrect">
            <summary>The value was of an incorrect type for this dictionary.</summary>
        </member>
        <member name="P:System.SR.ConcurrentStack_PushPopRange_CountOutOfRange">
            <summary>The count argument must be greater than or equal to zero.</summary>
        </member>
        <member name="P:System.SR.ConcurrentStack_PushPopRange_InvalidCount">
            <summary>The sum of the startIndex and count arguments must be less than or equal to the collection's Count.</summary>
        </member>
        <member name="P:System.SR.ConcurrentStack_PushPopRange_StartOutOfRange">
            <summary>The startIndex argument must be greater than or equal to zero.</summary>
        </member>
        <member name="P:System.SR.Partitioner_DynamicPartitionsNotSupported">
            <summary>Dynamic partitions are not supported by this partitioner.</summary>
        </member>
        <member name="P:System.SR.PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed">
            <summary>Can not call GetEnumerator on partitions after the source enumerable is disposed</summary>
        </member>
        <member name="P:System.SR.PartitionerStatic_CurrentCalledBeforeMoveNext">
            <summary>MoveNext must be called at least once before calling Current.</summary>
        </member>
        <member name="P:System.SR.ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished">
            <summary>Enumeration has either not started or has already finished.</summary>
        </member>
        <member name="P:System.SR.Arg_KeyNotFoundWithKey">
            <summary>The given key '{0}' was not present in the dictionary.</summary>
        </member>
    </members>
</doc>
