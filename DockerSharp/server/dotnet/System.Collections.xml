<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Collections</name>
    </assembly>
    <members>
        <member name="M:System.Collections.BitArray.GetInt32ArrayLengthFromBitLength(System.Int32)">
            <summary>
            Used for conversion between different representations of bit array. 
            Returns (n + (32 - 1)) / 32, rearranged to avoid arithmetic overflow. 
            For example, in the bit to int case, the straightforward calc would 
            be (n + 31) / 32, but that would cause overflow. So instead it's 
            rearranged to ((n - 1) / 32) + 1.
            Due to sign extension, we don't need to special case for n == 0, if we use
            bitwise operations (since ((n - 1) >> 5) + 1 = 0).
            This doesn't hold true for ((n - 1) / 32) + 1, which equals 1.
            
            Usage:
            GetArrayLength(77): returns how many ints must be 
            allocated to store 77 bits.
            </summary>
            <param name="n"></param>
            <returns>how many ints are required to store n bytes</returns>
        </member>
        <member name="M:System.Collections.Generic.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>How many ints must be allocated to represent n bits. Returns (n+31)/32, but avoids overflow.</summary>
        </member>
        <member name="T:System.Collections.Generic.HashSet`1">
            <summary>
            Implementation notes:
            This uses an array-based implementation similar to <see cref="T:System.Collections.Generic.Dictionary`2"/>, using a buckets array
            to map hash values to the Slots array. Items in the Slots array that hash to the same value
            are chained together through the "next" indices. 
            
            The capacity is always prime; so during resizing, the capacity is chosen as the next prime
            greater than double the last capacity. 
            
            The underlying data structures are lazily initialized. Because of the observation that, 
            in practice, hashtables tend to contain only a few elements, the initial capacity is
            set very small (3 elements) unless the ctor with a collection is used.
            
            The +/- 1 modifications in methods that add, check for containment, etc allow us to 
            distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
            reset each bucket to -1 when resizing. See Contains, for example.
            
            Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
            this set.
            
            Some operations can perform faster if we can assume "other" contains unique elements
            according to this equality comparer. The only times this is efficient to check is if
            other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
            also have to check that the hashset is using the same equality comparer. If other 
            has a different equality comparer, it will have unique elements according to its own
            equality comparer, but not necessarily according to ours. Therefore, to go these 
            optimized routes we check that other is a hashset using the same equality comparer.
            
            A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
            special empty set checks.)
            
            A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
            If we didn't have these checks, we could be iterating over the set and modifying at
            the same time. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
            <param name="collection"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add item to this hashset. This is the explicit implementation of the <see cref="T:System.Collections.Generic.ICollection`1"/>
            interface. The other Add method returns bool indicating whether item was added.
            </summary>
            <param name="item">item to add</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying 
            buckets and slots array. Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
            <summary>
            Checks if this hashset contains the item
            </summary>
            <param name="item">item to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Count">
            <summary>
            Number of elements in this hashset
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
            <summary>
            Add item to this HashSet. Returns bool indicating whether item was added (won't be 
            added if already present)
            </summary>
            <param name="item"></param>
            <returns>true if added, false if already present</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)">
            <summary>
            Searches the set for a given value and returns the equal value it finds, if any.
            </summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of 
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Take the union of this HashSet with other. Modifies this set.
            
            Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
            multiple resizes ended up not being useful in practice; quickly gets to the 
            point where it's a wasteful check.
            </summary>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            
            Implementation Notes: 
            We get better perf if other is a hashset using same equality comparer, because we 
            get constant contains check in other. Resulting cost is O(n1) to iterate over this.
            
            If we can't go above route, iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </summary>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to XOR</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a subset of other.
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a subset of anything, including the empty set
            2. If other has unique elements according to this equality comparer, and this has more
            elements than other, then it can't be a subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            2. If other has unique elements according to this equality comparer, and this has >=
            the number of elements in other, then this can't be a proper subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a superset of other
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            2. If other has unique elements according to this equality comparer, and this has less 
            than the number of elements in other, then this can't be a superset
            
            </summary>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            
            Implementation Notes: 
            This is slightly more complicated than above because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            3. If other has unique elements according to this equality comparer, and other's count
            is greater than or equal to this count, then this can't be a proper superset
            
            Furthermore, if other has unique elements according to this equality comparer, we can
            use a faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Remove elements that match specified predicate. Returns the number of elements removed
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Comparer">
            <summary>
            Gets the IEqualityComparer that is used to determine equality of keys for 
            the HashSet.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the hash set can hold up to 'capacity' entries without any further expansion of its backing storage.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list (rounded up to nearest prime),
            unless count is 0, in which case we release references.
            
            This method can be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and release all 
            memory referenced by the list, execute the following statements:
            
            list.Clear();
            list.TrimExcess(); 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
            <summary>
            Used for deep equality of HashSet testing
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IncreaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested 
            size. This is called when the underlying array is filled. This performs no 
            defragmentation, allowing faster execution; note that this is reasonable since 
            AddIfNotPresent attempts to insert new elements in re-opened spots.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SetCapacity(System.Int32)">
            <summary>
            Set the underlying buckets array to size newSize and rehash.  Note that newSize
            *must* be a prime.  It is very likely that you want to call IncreaseCapacity()
            instead of this method.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AddIfNotPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already
            Returns true if added and false if already present
            </summary>
            <param name="value">value to find</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ContainsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOfHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWithHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Iterate over other. If contained in this, mark an element in bit array corresponding to
            its position in _slots. If anything is unmarked (in bit array), remove it.
            
            This attempts to allocate on the stack, if below StackAllocThreshold.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.InternalIndexOf(`0)">
            <summary>
            Used internally by set operations which have to rely on bit array marking. This is like
            Contains but returns index in slots array. 
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWithUniqueHashSet(System.Collections.Generic.HashSet{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
             
             Used for symmetric except when other isn't a HashSet. This is more tedious because 
             other may contain duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then 
             remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other. 
             
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AddOrGetLocation(`0,System.Int32@)">
            <summary>
            Add if not already in hashset. Returns an out param indicating index where added. This 
            is used by SymmetricExcept because it needs to know the following things:
            - whether the item was already present in the collection or added from other
            - where it's located (if already present, it will get marked for removal, otherwise
            marked for keeping)
            </summary>
            <param name="value"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than _count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.HashSetEquals(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
            to specified comparer.
            
            Because items are hashed according to a specific equality comparer, we have to resort
            to n^2 search if they're using different equality comparers.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AreEqualityComparersEqual(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.InternalGetHashCode(`0)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <param name="item"></param>
            <returns>hash code</returns>
        </member>
        <member name="T:System.Collections.Generic.HashSetEqualityComparer`1">
            <summary>
            Equality comparer for hashsets of hashsets
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.Collections.Generic.Queue`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="T:System.Collections.Generic.TreeSet`1">
            <summary>
            This class is intended as a helper for backwards compatibility with existing SortedDictionaries.
            TreeSet has been converted into SortedSet{T}, which will be exposed publicly. SortedDictionaries
            have the problem where they have already been serialized to disk as having a backing class named
            TreeSet. To ensure that we can read back anything that has already been written to disk, we need to
            make sure that we have a class named TreeSet that does everything the way it used to.
            
            The only thing that makes it different from SortedSet is that it throws on duplicates
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.InOrderTreeWalk(System.Collections.Generic.TreeWalkPredicate{`0})">
            <summary>
            Does an in-order tree walk and calls the delegate for each node.
            </summary>
            <param name="action">
            The delegate to invoke on each node.
            If the delegate returns <c>false</c>, the walk is stopped.
            </param>
            <returns><c>true</c> if the entire tree has been walked; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.BreadthFirstTreeWalk(System.Collections.Generic.TreeWalkPredicate{`0})">
            <summary>
            Does a left-to-right breadth-first tree walk and calls the delegate for each node.
            </summary>
            <param name="action">
            The delegate to invoke on each node.
            If the delegate returns <c>false</c>, the walk is stopped.
            </param>
            <returns><c>true</c> if the entire tree has been walked; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.ReplaceChildOrRoot(System.Collections.Generic.SortedSet{`0}.Node,System.Collections.Generic.SortedSet{`0}.Node,System.Collections.Generic.SortedSet{`0}.Node)">
            <summary>
            Replaces the child of a parent node, or replaces the root if the parent is <c>null</c>.
            </summary>
            <param name="parent">The (possibly <c>null</c>) parent.</param>
            <param name="child">The child node to replace.</param>
            <param name="newChild">The node to replace <paramref name="child"/> with.</param>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.ReplaceNode(System.Collections.Generic.SortedSet{`0}.Node,System.Collections.Generic.SortedSet{`0}.Node,System.Collections.Generic.SortedSet{`0}.Node,System.Collections.Generic.SortedSet{`0}.Node)">
            <summary>
            Replaces the matching node with its successor.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.InternalIndexOf(`0)">
            <summary>
            Searches for an item and returns its zero-based index in this set.
            </summary>
            <param name="item">The item.</param>
            <returns>The item's zero-based index in this set, or -1 if it isn't found.</returns>
            <remarks>
            <para>
            This implementation is based off of http://en.wikipedia.org/wiki/Binary_Tree#Methods_for_storing_binary_trees.
            </para>
            <para>
            This method is used with the <see cref="T:System.Collections.Generic.BitHelper"/> class. Note that this implementation is
            completely different from <see cref="T:System.Collections.Generic.SortedSet`1.TreeSubSet"/>'s, and that the two should not be mixed.
            </para>
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.CreateSetComparer">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> object that can be used to create a collection that contains individual sets.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.CreateSetComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> object, according to a specified comparer, that can be used to create a collection that contains individual sets.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.SortedSetEquals(System.Collections.Generic.SortedSet{`0},System.Collections.Generic.SortedSet{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Decides whether two sets have equal contents, using a fallback comparer if the sets do not have equivalent equality comparers.
            </summary>
            <param name="set1">The first set.</param>
            <param name="set2">The second set.</param>
            <param name="comparer">The fallback comparer to use if the sets do not have equal comparers.</param>
            <returns><c>true</c> if the sets have equal contents; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.HasEqualComparer(System.Collections.Generic.SortedSet{`0})">
            <summary>
            Determines whether two <see cref="T:System.Collections.Generic.SortedSet`1"/> instances have the same comparer.
            </summary>
            <param name="other">The other <see cref="T:System.Collections.Generic.SortedSet`1"/>.</param>
            <returns>A value indicating whether both sets have the same comparer.</returns>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
             <summary>
             This works similar to HashSet's CheckUniqueAndUnfound (description below), except that the bit
             array maps differently than in the HashSet. We can only use this for the bulk boolean checks.
            
             Determines counts that can be used to determine equality, subset, and superset. This
             is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
             these properties can be checked faster without use of marking because we can assume
             other has no duplicates.
            
             The following count checks are performed by callers:
             1. Equals: checks if UnfoundCount = 0 and uniqueFoundCount = Count; i.e. everything
             in other is in this and everything in this is in other
             2. Subset: checks if UnfoundCount >= 0 and uniqueFoundCount = Count; i.e. other may
             have elements not in this and everything in this is in other
             3. Proper subset: checks if UnfoundCount > 0 and uniqueFoundCount = Count; i.e
             other must have at least one element not in this and everything in this is in other
             4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
             than Count; i.e. everything in other was in this and this had at least one element
             not contained in other.
            
             An earlier implementation used delegates to perform these checks rather than returning
             an ElementCount struct; however this was changed due to the perf overhead of delegates.
             </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.GetRotation(System.Collections.Generic.SortedSet{`0}.Node,System.Collections.Generic.SortedSet{`0}.Node)">
            <summary>
            Gets the rotation this node should undergo during a removal.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.GetSibling(System.Collections.Generic.SortedSet{`0}.Node)">
            <summary>
            Gets the sibling of one of this node's children.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.Rotate(System.Collections.Generic.TreeRotation)">
            <summary>
            Does a rotation on this tree. May change the color of a grandchild from red to black.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.RotateLeft">
            <summary>
            Does a left rotation on this tree, making this node the new left child of the current right child.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.RotateLeftRight">
            <summary>
            Does a left-right rotation on this tree. The left child is rotated left, then this node is rotated right.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.RotateRight">
            <summary>
            Does a right rotation on this tree, making this node the new right child of the current left child.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.RotateRightLeft">
            <summary>
            Does a right-left rotation on this tree. The right child is rotated right, then this node is rotated left.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.Merge2Nodes">
            <summary>
            Combines two 2-nodes into a 4-node.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.Node.ReplaceChild(System.Collections.Generic.SortedSet{`0}.Node,System.Collections.Generic.SortedSet{`0}.Node)">
            <summary>
            Replaces a child of this node with a new node.
            </summary>
            <param name="child">The child to replace.</param>
            <param name="newChild">The node to replace <paramref name="child"/> with.</param>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.TryGetValue(`0,`0@)">
            <summary>
            Searches the set for a given value and returns the equal value it finds, if any.
            </summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of 
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.SortedSet`1.TreeSubSet">
            <summary>
            This class represents a subset view into the tree. Any changes to this view
            are reflected in the actual tree. It uses the comparer of the underlying tree.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.TreeSubSet.VersionCheck(System.Boolean)">
            <summary>
            Checks whether this subset is out of date, and updates it if necessary.
            <param name="updateCount">Updates the count variable if necessary.</param>
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSet`1.TreeSubSet.TotalCount">
            <summary>
            Returns the number of elements <c>count</c> of the parent set.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.SortedSetEqualityComparer`1">
            <summary>
            A comparer for two <see cref="T:System.Collections.Generic.SortedSet`1"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SortedSetEqualityComparer`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a new SetEqualityComparer, given a comparer for member order and another for member equality (these
            must be consistent in their definition of equality)
            </summary>        
        </member>
        <member name="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="T:System.Collections.Generic.EnumerableHelpers">
            <summary>
            Internal helper functions for working with enumerables.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.EnumerableHelpers.ToArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary>Converts an enumerable to an array using the same logic as List{T}.</summary>
            <param name="source">The enumerable to convert.</param>
            <param name="length">The number of items stored in the resulting array, 0-indexed.</param>
            <returns>
            The resulting array.  The length of the array may be greater than <paramref name="length"/>,
            which is the actual number of elements in the array.
            </returns>
        </member>
        <member name="P:System.SR.Arg_NonZeroLowerBound">
            <summary>The lower bound of target array must be zero.</summary>
        </member>
        <member name="P:System.SR.Arg_WrongType">
            <summary>The value '{0}' is not of type '{1}' and cannot be used in this generic collection.</summary>
        </member>
        <member name="P:System.SR.Arg_ArrayPlusOffTooSmall">
            <summary>Destination array is not long enough to copy all the items in the collection. Check array index and length.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NeedNonNegNum">
            <summary>Non-negative number required.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_SmallCapacity">
            <summary>capacity was less than the current size.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidOffLen">
            <summary>Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.</summary>
        </member>
        <member name="P:System.SR.Argument_AddingDuplicate">
            <summary>An item with the same key has already been added. Key: {0}</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_ConcurrentOperationsNotSupported">
            <summary>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EmptyQueue">
            <summary>Queue empty.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumOpCantHappen">
            <summary>Enumeration has either not started or has already finished.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumFailedVersion">
            <summary>Collection was modified after the enumerator was instantiated.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EmptyStack">
            <summary>Stack empty.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumNotStarted">
            <summary>Enumeration has not started. Call MoveNext.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_EnumEnded">
            <summary>Enumeration already finished.</summary>
        </member>
        <member name="P:System.SR.NotSupported_KeyCollectionSet">
            <summary>Mutating a key collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:System.SR.NotSupported_ValueCollectionSet">
            <summary>Mutating a value collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:System.SR.Arg_ArrayLengthsDiffer">
            <summary>Array lengths must be the same.</summary>
        </member>
        <member name="P:System.SR.Arg_BitArrayTypeUnsupported">
            <summary>Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].</summary>
        </member>
        <member name="P:System.SR.Arg_HSCapacityOverflow">
            <summary>HashSet capacity is too big.</summary>
        </member>
        <member name="P:System.SR.Arg_HTCapacityOverflow">
            <summary>Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.</summary>
        </member>
        <member name="P:System.SR.Arg_InsufficientSpace">
            <summary>Insufficient space in the target location to copy the information.</summary>
        </member>
        <member name="P:System.SR.Arg_RankMultiDimNotSupported">
            <summary>Only single dimensional arrays are supported for the requested action.</summary>
        </member>
        <member name="P:System.SR.Argument_ArrayTooLarge">
            <summary>The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidArrayType">
            <summary>Target array type is not compatible with the type of items in the collection.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_BiggerThanCollection">
            <summary>Must be less than or equal to the size of the collection.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Index">
            <summary>Index was out of range. Must be non-negative and less than the size of the collection.</summary>
        </member>
        <member name="P:System.SR.ExternalLinkedListNode">
            <summary>The LinkedList node does not belong to current LinkedList.</summary>
        </member>
        <member name="P:System.SR.LinkedListEmpty">
            <summary>The LinkedList is empty.</summary>
        </member>
        <member name="P:System.SR.LinkedListNodeIsAttached">
            <summary>The LinkedList node already belongs to a LinkedList.</summary>
        </member>
        <member name="P:System.SR.NotSupported_SortedListNestedWrite">
            <summary>This operation is not supported on SortedList nested types because they require modifying the original SortedList.</summary>
        </member>
        <member name="P:System.SR.SortedSet_LowerValueGreaterThanUpperValue">
            <summary>Must be less than or equal to upperValue.</summary>
        </member>
        <member name="P:System.SR.Serialization_InvalidOnDeser">
            <summary>OnDeserialization method was called while the object was not being deserialized.</summary>
        </member>
        <member name="P:System.SR.Serialization_MismatchedCount">
            <summary>The serialized Count information doesn't match the number of items.</summary>
        </member>
        <member name="P:System.SR.Serialization_MissingKeys">
            <summary>The keys for this dictionary are missing.</summary>
        </member>
        <member name="P:System.SR.Serialization_MissingValues">
            <summary>The values for this dictionary are missing.</summary>
        </member>
        <member name="P:System.SR.Arg_KeyNotFoundWithKey">
            <summary>The given key '{0}' was not present in the dictionary.</summary>
        </member>
    </members>
</doc>
